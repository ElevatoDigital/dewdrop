{"version":3,"sources":["webpack:///0.js","webpack:///./www/src/js/summernote.js","webpack:///./~/codemirror/lib/codemirror.js","webpack:///./~/summernote-webpack/dist/summernote.js","webpack:///(webpack)/buildin/amd-options.js"],"names":["webpackJsonp","145","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_0_jquery__","__WEBPACK_IMPORTED_MODULE_0_jquery___default","n","__WEBPACK_IMPORTED_MODULE_1_summernote_webpack__","SummerNote","this","summernote","height","149","exports","global","factory","classTest","cls","RegExp","removeChildren","e","count","childNodes","length","removeChild","firstChild","removeChildrenAndAdd","parent","appendChild","elt","tag","content","className","style","document","createElement","cssText","createTextNode","i","eltP","setAttribute","contains","child","nodeType","parentNode","host","activeElt","activeElement","body","shadowRoot","addClass","node","current","test","joinClasses","a","b","as","split","bind","f","args","Array","prototype","slice","call","arguments","apply","copyObj","obj","target","overwrite","prop","hasOwnProperty","countColumn","string","end","tabSize","startIndex","startValue","search","nextTab","indexOf","array","findColumn","goal","pos","col","skipped","Math","min","spaceStr","spaceStrs","push","lst","arr","map","out","insertSorted","score","priority","splice","nothing","createObj","base","props","inst","create","isWordCharBasic","ch","toUpperCase","toLowerCase","nonASCIISingleCaseWordChar","isWordChar","helper","source","isEmpty","isExtendingChar","charCodeAt","extendingChars","skipExtendingChars","str","dir","charAt","findFirst","pred","from","to","abs","mid","floor","Display","place","doc","input","d","scrollbarFiller","gutterFiller","lineDiv","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","lines","mover","sizer","sizerWidth","heightForcer","scrollerGap","gutters","lineGutter","scroller","wrapper","ie","ie_version","zIndex","paddingRight","webkit","gecko","mobile","draggable","viewFrom","viewTo","first","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","shift","selForContextMenu","activeTouch","init","getLine","size","Error","chunk","children","sz","chunkSize","getBetween","start","line","iter","text","getLines","updateLineHeight","diff","lineNo","cur","no","lineAtHeight","h","outer","i$1","lh","isLine","l","lineNumberFor","options","String","lineNumberFormatter","firstLineNumber","Pos","sticky","cmp","equalCursorPos","copyPos","x","maxPos","minPos","clipLine","max","clipPos","last","clipToLen","linelen","clipPosArray","seeReadOnlySpans","sawReadOnlySpans","seeCollapsedSpans","sawCollapsedSpans","MarkedSpan","marker","getMarkedSpanFor","spans","span","removeMarkedSpan","r","addMarkedSpan","markedSpans","concat","attachLine","markedSpansBefore","old","startCh","isInsert","nw","startsBefore","inclusiveLeft","type","insertLeft","endsAfter","inclusiveRight","markedSpansAfter","endCh","stretchSpansOverChange","change","full","oldFirst","oldLast","sameLine","offset","found","span$1","found$1","clearEmptySpans","newMarkers","gapMarkers","gap","i$2","i$3","clearWhenEmpty","removeReadOnlyRanges","markers","mark","readOnly","parts","mk","m","find","j","p","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","id","collapsedSpanAtSide","sps","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","conflictingCollapsedRange","lineNo$$1","visualLine","merged","visualLineEnd","visualLineContinued","visualLineNo","lineN","vis","visualLineEndNo","lastLine","lineIsHidden","widgetNode","lineIsHiddenInner","heightAtLine","lineObj","lineLength","len","findMaxLine","cm","display","iterateBidiSections","order","part","level","getBidiPartAt","bidiOther","getOrder","direction","bidiOrdering","moveCharLogically","moveLogically","endOfLine","visually","moveInStorageOrder","prep","prepareMeasureForLine","targetTop","measureCharPrepared","top","moveVisually","bidi","partPos","mv","getWrappedLineExtent","lineWrapping","wrappedLineExtentChar","begin","wrappedLineExtent","searchInVisualLine","getRes","res","nextCh","getHandlers","emitter","_handlers","noHandlers","off","removeEventListener","detachEvent","map$$1","index","signal","handlers","signalDOMEvent","override","preventDefault","defaultPrevented","e_defaultPrevented","codemirrorIgnore","signalCursorActivity","cursorActivity","set","curOp","cursorActivityHandlers","hasHandler","eventMixin","ctor","on","e_preventDefault","returnValue","e_stopPropagation","stopPropagation","cancelBubble","e_stop","e_target","srcElement","e_button","which","button","mac","ctrlKey","zeroWidthElement","zwspSupported","offsetHeight","offsetWidth","hasBadBidiRects","badBidiRects","txt","r0","range","getBoundingClientRect","r1","left","right","hasBadZoomedRects","badZoomedRects","normal","fromRange","defineMode","name","mode","dependencies","modes","defineMIME","mime","spec","mimeModes","resolveMode","getMode","mfactory","modeObj","modeExtensions","exts","helperType","modeProps","prop$1","extendMode","properties","copyState","state","nstate","val","innerMode","info","startState","a1","a2","highlightLine","forceToEnd","st","modeGen","lineClasses","runMode","o","overlays","overlay","at","i_end","opaque","styles","classes","bgClass","textClass","getLineStyles","updateFrontier","getStateBefore","result","maxHighlightLength","stateAfter","styleClasses","frontier","precise","findStartLine","processLine","save","startAt","stream","StringStream","callBlankLine","eol","readToken","blankLine","inner","token","takeToken","asArray","getObj","copy","tokens","extractLineClasses","output","lineClass","match","flattenSpans","curStart","curStyle","addModeClass","mName","minindent","minline","lim","indented","updateLine","estimateHeight","estHeight","cleanUpLine","interpretTokenStyle","cache","styleToClassCacheWithMode","styleToClassCache","replace","buildLineContent","lineView","builder","pre","trailingSpace","splitSpaces","getOption","rest","addToken","buildToken","buildTokenBadBidi","insertLineContent","maps","caches","lastChild","querySelector","defaultSpecialCharPlaceholder","title","toString","startStyle","endStyle","css","displayText","special","specialChars","mustWrap","createDocumentFragment","lastIndex","exec","txt$1","tabWidth","specialCharPlaceholder","fullStyle","trailingBefore","spaceBefore","buildCollapsedSpan","ignoreWidget","widget","needsContentAttribute","setUneditable","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","Infinity","foundBookmarks","endStyles","j$1","j$2","upto","tokenText","LineView","hidden","buildViewArray","nextPos","pushOperation","op","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","group","callbacks","cursorActivityCalled","finishOperation","endCb","signalLater","list","orphanDelayedCallbacks","setTimeout","fireOrphanDelayed","delayed","updateLineForChanges","dims","changes","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","updateLineBackground","background","wrap","insertBefore","getLineContent","ext","built","wrapClass","gutter","gutterBackground","gutterClass","fixedGutter","fixedPos","gutterTotalWidth","gutterMarkers","lineNumbers","wrap$1","gutterWrap","lineNumber","gutterLeft","k","gutterWidth","alignable","next","nextSibling","insertLineWidgets","buildLineElement","insertLineWidgetsFor","allowAbove","widgets","ws","handleMouseEvents","positionLineWidget","above","noHScroll","width","wrapperWidth","coverGutter","paddingLeft","position","marginLeft","widgetHeight","parentStyle","clientWidth","eventInWidget","getAttribute","paddingTop","offsetTop","paddingVert","paddingH","window","getComputedStyle","currentStyle","data","parseInt","isNaN","scrollGap","displayWidth","displayHeight","clientHeight","ensureLineHeights","rect","wrapping","curWidth","heights","rects","getClientRects","bottom","mapFromLineView","before","updateExternalMeasurement","measureChar","bias","findViewForLine","findViewIndex","getDimensions","forceUpdate","hasHeights","prepared","varHeight","key","measureCharInner","bogus","rtop","rbottom","nodeAndOffsetInLineMap","collapse","mStart","mEnd","coverStart","coverEnd","getUsefulRect","nullRect","maybeUpdateRectForZooming","rSpan","charWidth","rbot","bot","singleCursorHeightPerLine","screen","logicalXDPI","deviceXDPI","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","clearCaches","pageScrollX","chrome","android","pageXOffset","documentElement","scrollLeft","pageScrollY","marginTop","pageYOffset","scrollTop","intoCoordSystem","context","includeWidgets","yOff","lOff","xOff","fromCoordSystem","coords","localBox","lineSpaceBox","charCoords","cursorCoords","preparedMeasure","get","getBidi","invert","other","estimateCoords","PosWithInfo","outside","xRel","coordsChar","y","coordsCharInner","mergedPos","assign","prevDiff","prevPos","beginLeft","box","textHeight","measureText","anchor","clientLeft","offsetLeft","compensateForHScroll","th","perLine","widgetsHeight","ceil","estimateLineHeights","est","posFromMouse","liberal","forRect","space","clientX","clientY","colDiff","round","updateSelection","showSelection","prepareSelection","primary","curFragment","cursors","selFragment","selection","sel","ranges","primIndex","range$$1","empty","showCursorWhenSelecting","drawSelectionCursor","head","drawSelectionRange","cursor","cursorHeight","otherCursor","add","fragment","rightSide","drawForLine","fromArg","toArg","lineLen","rightPos","leftPos","tmp","leftSide","padding","sFrom","sTo","fromLine","toLine","singleVLine","leftEnd","rightStart","restartBlink","focused","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","ensureFocus","focus","onFocus","delayBlurEvent","delayingBlurEvent","onBlur","reset","receivedFocus","rmClass","updateHeightsInViewport","prevBottom","updateWidgetHeight","visibleLines","viewport","ensure","ensureFrom","ensureTo","alignHorizontally","comp","gutterW","align","maybeUpdateLineNumberWidth","innerW","updateGutterSpace","maybeScrollWindow","doScroll","innerHeight","phantom","scrollNode","scrollIntoView","scrollPosIntoView","margin","limit","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","updateScrollTop","setScrollLeft","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollTop","resolveScrollToPos","ensureCursorVisible","getCursor","scrollToPos","cursorScrollMargin","scrollToCoords","scrollToRange","scrollToCoordsRange","sPos","updateDisplaySimple","setScrollTop","startWorker","forceScroll","scrollHeight","scrollbars","isScroller","scrollWidth","measureForScrollbars","docH","viewHeight","viewWidth","barLeft","docHeight","updateScrollbars","startWidth","startHeight","updateScrollbarsInner","sizes","update","paddingBottom","borderBottom","coverGutterNextToScrollbar","initScrollbars","clear","scrollbarModel","scrollbarStyle","axis","startOperation","viewChanged","updateInput","typing","changeObjs","selectionChanged","updateMaxLine","nextOpId","endOperation","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","i$4","endOperation_finish","maybeClipScrollbars","mustUpdate","DisplayUpdate","updatedDisplay","updateDisplayIfNeeded","barMeasure","adjustWidthTo","maxScrollLeft","preparedSelection","minWidth","takeFocus","hasFocus","setDocumentHeight","postUpdateDisplay","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","finish","runInOp","operation","methodOp","docMethodOp","regChange","lendiff","resetView","cut","viewCuttingPoint","cut$1","cutTop","cutBot","regLineChange","oldN","newN","adjustView","countDirtyView","dirty","time","highlight","highlightWorker","Date","workTime","changedLines","oldStyles","tooLong","highlighted","oldCls","newCls","ischange","workDelay","marginBottom","borderRightWidth","selectionSnapshot","active","getSelection","anchorNode","extend","anchorOffset","focusNode","focusOffset","restoreSelection","snapshot","createRange","setEnd","removeAllRanges","addRange","editorIsHidden","force","visible","viewportMargin","different","wrapperHeight","toUpdate","selSnapshot","patchDisplay","minHeight","oldDisplayWidth","updateNumbersFrom","rm","currentWheelTarget","container","updateNumber","updateGutters","specs","gElt","setGuttersForLineNumbers","wheelEventDelta","dx","wheelDeltaX","dy","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","delta","wheelPixelsPerUnit","onScrollWheel","scroll","canScrollX","canScrollY","presto","pixels","wheelSamples","movedX","movedY","sample","normalizeSelection","prim","sort","prev","inv","Range","Selection","simpleSelection","changeEnd","adjustForChange","computeSelAfterChange","offsetPos","computeReplacedSel","hint","oldPrev","newPrev","loadMode","modeOption","resetModeState","isWholeLineUpdate","wholeLineUpdateBefore","updateDoc","estimateHeight$$1","spansFor","linesFor","Line","firstLine","lastText","lastSpans","nlines","insert","remove","added","added$1","added$2","linkedDocs","sharedHistOnly","propagate","skip","sharedHist","linked","rel","shared","attachDoc","setDirectionClass","directionChanged","History","startGen","done","undone","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","histChange","attachLocalSpans","clearSelectionEvents","pop","lastChangeEvent","hist","addChangeToHistory","selAfter","opId","history","origin","historyEventDelay","pushSelectionToHistory","selectionEventCanBeMerged","somethingSelected","addSelectionToHistory","clearRedo","dest","equals","existing","removeClearedSpans","explicitlyCleared","getOldSpans","mergeOldSpans","stretched","oldCur","stretchCur","copyHistoryArray","events","newGroup","instantiateSel","event","deepCopy","newChanges","Number","extendRange","posBefore","extendSelection","setSelection","extendSelections","heads","replaceOneSelection","setSimpleSelection","filterSelectionChange","this$1","setSelectionReplaceHistory","setSelectionNoUndo","NaN","setSelectionInner","skipAtomicInSelection","reCheckSelection","mayClear","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","atomic","near","movePos","far","cantEdit","selectAll","sel_dontScroll","filterChange","canceled","cancel","undefined","makeChange","ignoreReadOnly","suppressEdits","makeChangeInner","makeChangeSingleDoc","rebased","rebaseHist","makeChangeFromHistory","allowSelectionOnly","antiChanges","filter","returned","after","v","shiftDoc","distance","removed","makeChangeSingleDocInEditor","recomputeMaxLength","checkWidthStart","changesHandler","changeHandler","replaceRange","code","splitLines","rebaseHistSelSingle","rebaseHistArray","sub","ok","copied","changeLine","handle","changeType","adjustScrollWhenAboveVisible","addLineWidget","LineWidget","insertAt","aboveVisible","markText","markTextShared","TextMarker","replacedWith","addToHistory","curLine","clearOnEnter","clearHistory","nextMarkerId","cloneNode","isParent","SharedTextMarker","findSharedMarkers","findMarks","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","onDrop","clearDragCursor","lastDrop","files","dataTransfer","isReadOnly","FileReader","File","read","file","allowDropFileTypes","reader","onload","join","lineSeparator","readAsText","draggingText","text$1","getData","selected","listSelections","replaceSelection","onDragStart","setData","effectAllowed","setDragImage","safari","img","src","_top","onDragOver","frag","dragCursor","forEachCodeMirror","getElementsByClassName","byClass","CodeMirror","ensureGlobalHandlers","globalsRegistered","registerGlobalHandlers","resizeTimer","onResize","setSize","normalizeKeyName","alt","ctrl","cmd","mod","normalizeKeyMap","keymap","keyname","keys","lookupKey","getKeyMap","fallthrough","isModifierKey","keyNames","keyCode","keyName","noShift","altGraphKey","altKey","flipCtrlCmd","metaKey","shiftKey","keyMap","deleteNearSelection","compute","kill","toKill","replaced","lineStart","visual","lineEnd","lineStartSmart","firstNonWS","inWS","doHandleBinding","bound","dropShift","commands","ensurePolled","prevShift","Pass","lookupKeyForEditor","keyMaps","extraKeys","dispatchKey","seq","keySeq","stopSeq","handleKeyBinding","motion","handleCharBinding","onKeyDown","handled","lastStoppedKey","hasCopyEvent","showCrossHair","up","onKeyUp","onKeyPress","charCode","fromCharCode","onMouseDown","supportsTouch","clickInGutter","selectingText","leftButtonDown","lastMiddleDown","captureRightClick","onContextMenu","now","lastDoubleClick","lastClick","contained","modifier","dragDrop","dragAndDrop","leftButtonStartDrag","leftButtonSelect","moved","dragEnd","mouseMove","dragStart","e2","addNew","extendTo","lastPos","startCol","posCol","startSel","ourIndex","oldRange","ourRange","findWordAt","ranges$1","sel_mouse","curCount","counter","editorSize","move","chromeOS","word","gutterEvent","prevent","mX","mY","lineBox","g","contextMenuInGutter","themeChanged","theme","guttersChanged","dragDropChanged","Init","funcs","dragFunctions","toggle","enter","over","leave","drop","wrappingChanged","CodeMirror$1","defaults","Doc","inputStyles","inputStyle","pasteIncoming","cutIncoming","Delayed","autofocus","registerEventHandlers","opt","optionHandlers","finishInit","initHooks","textRendering","finishTouch","touchFinished","prevTouch","isMouseLikeTouchEvent","touches","touch","radiusX","radiusY","farAway","clearTimeout","pageX","pageY","inp","getField","indentLine","how","aggressive","indent","curSpace","indentation","curSpaceString","indentUnit","indentString","indentWithTabs","pos$1","setLastCopied","newLastCopied","lastCopied","applyTextInput","inserted","deleted","paste","textLines","splitLinesAuto","multiPaste","lineWise","changeEvent","triggerElectric","handlePaste","pasted","clipboardData","disableInput","electricChars","smartIndent","getModeAt","electricInput","copyableRanges","lineRange","getRange","disableBrowserMagic","field","spellcheck","hiddenTextarea","te","div","ios","border","findPosH","unit","findNextLine","moveOnce","boundToLine","origDir","sawType","getHelper","hitSide","findPosV","pageSize","moveAmount","posToDOM","side","isInGutter","scan","badPos","bad","domTextBetween","recognizeMarker","close","closing","lineSep","addText","walk","cmText","textContent","markerID","isBlock","nodeName","nodeValue","domToPos","lineNode","locateNodeInLineView","textNode","topNode","curNode","dist","previousSibling","dist$1","fromTextArea","textarea","getValue","tabindex","tabIndex","placeholder","realSubmit","form","leaveSubmitMethodAlone","submit","wrappedSubmit","getTextArea","toTextArea","getWrapperElement","userAgent","navigator","platform","ie_upto10","ie_11up","edge","documentMode","qtwebkit","vendor","mac_geMountainLion","windows","presto_version","endNode","setStart","createTextRange","moveToElementText","moveEnd","moveStart","selectInput","select","selectionStart","selectionEnd","_e","ms","sel_move","charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","types","type$1","prev$1","type$2","type$3","i$5","cur$1","type$4","i$6","end$1","replace$1","i$7","nstart","unshift","reverse","addEventListener","attachEvent","nl","rt","hasSelection","ownerDocument","parentElement","compareEndPoints","oncopy","lastColumnPos","lastColumnValue","sol","peek","eat","eatWhile","eatSpace","skipToEnd","skipTo","backUp","column","pattern","consume","caseInsensitive","cased","substr","hideFirstChars","NativeScrollbars","vert","horiz","checkedZeroWidth","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","w","pointerEvents","bar","delay","maybeDisable","elementFromPoint","NullScrollbars","native","null","here","there","LeafChunk","removeInner","insertInner","iterN","BranchChunk","oldHeight","remaining","leaf","maybeSpill","me","spilled","sibling","myIndex","used","oldH","withOp","dHeight","nextDocId","cleanGeneration","constructor","setValue","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","setCursor","extendSelectionsBy","setSelections","addSelection","getSelections","dup","replaceSelections","newSel","undo","redo","undoSelection","redoSelection","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","setGutterMarker","gutterID","clearGutter","lineInfo","addLineClass","where","removeLineClass","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","unlinkDoc","link","splitIds","iterLinkedDocs","getEditor","setDirection","eachLine","3","8","9","13","16","17","18","19","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","93","106","107","109","110","111","127","173","186","187","188","189","190","191","192","219","220","221","222","63232","63233","63234","63235","63272","63273","63275","63276","63277","63302","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","Ctrl-O","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","moveV","goLineDown","goPageUp","goPageDown","goCharLeft","moveH","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","deleteH","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentSelection","indentMore","indentLess","insertTab","insertSoftTab","spaces","defaultTab","execCommand","transposeChars","newlineAndIndent","sels","openLine","toggleOverwrite","defineInitHook","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","composing","gracePeriod","readDOMTimeout","onCopyCut","lineWiseCopyCut","clearData","kludge","hadFocus","showPrimarySelection","updateFromDOM","readFromDOMSoon","forceCompositionEnd","showMultipleSelections","curAnchor","curFocus","rng","rangeCount","getRangeAt","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","blur","poll","pollSelection","pollInterval","triggerOnKeyDown","pollContent","fromIndex","fromNode","toNode","toIndex","newText","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","readOnlyChanged","resetPosition","TextareaInput","prevInput","pollingFast","inaccurateSelection","prepareCopyCut","fastPoll","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","minimal","slowPoll","missed","same","prepareSelectAllHack","extval","rehide","oldWrapperCSS","oldCSS","detectingSelectAll","resetSelectionOnContextMenu","wrapperBox","oldScrollY","scrollY","scrollTo","mouseup","option","deflt","notOnInit","defineOption","newBreaks","refresh","getInputField","detach","attach","integer","disabled","helpers","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","modeSpec","removeOverlay","newRanges","getTokenAt","getLineTokens","getTokenTypeAt","getHelpers","help","_global","getStateAfter","defaultTextHeight","defaultCharWidth","getViewport","addWidget","vspace","hspace","triggerOnKeyPress","triggerOnKeyUp","amount","rtlMoveVisually","goalColumn","goals","startChar","check","getScrollInfo","interpret","swapDoc","getScrollerElement","getGutterElement","registerHelper","registerGlobalHelper","predicate","dontDelegate","method","contenteditable","defineExtension","func","defineDocExtension","cmpPos","version","151","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","$","browserVersion","eq","itemA","itemB","eq2","peq2","propName","fail","not","and","fA","fB","item","idCounter","self","invoke","uniqueId","prefix","rect2bnd","$document","invertObject","inverted","namespaceToCamel","namespace","substring","initial","tail","idx","all","inArray","sum","fn","reduce","memo","collection","clusterBy","aLast","compact","aResult","unique","results","isSupportAmd","isFontInstalled","fontName","testFontName","$tester","fontSize","appendTo","originalWidth","isMSIE","matches","parseFloat","isEdge","hasCodeMirror","agent","isMac","appVersion","isFF","isPhantom","isWebkit","isChrome","isSafari","jqueryVersion","jquery","isW3CRangeSupport","NBSP_CHAR","dom","isEditable","hasClass","isControlSizing","makePredByNodeName","isText","isElement","isVoid","isPara","isHeading","isPre","isLi","isPurePara","isTable","isInline","isBodyContainer","isList","isHr","isBlockquote","isCell","isAnchor","isParaInline","ancestor","isBodyInline","isBody","isClosestSibling","nodeA","nodeB","withClosestSiblings","siblings","blankHTML","nodeLength","innerHTML","paddingBlankHTML","singleChildAncestor","listAncestor","ancestors","el","lastAncestor","commonAncestor","listPrev","nodes","listNext","listDescendant","descendants","fnWalk","wrapperName","insertAfter","preceding","appendChildNodes","aChild","each","isLeftEdgePoint","point","isRightEdgePoint","isEdgePoint","isLeftEdgeOf","isRightEdgeOf","isLeftEdgePointOf","isRightEdgePointOf","hasChildren","prevPoint","isSkipInnerOffset","nextPoint","isSamePoint","pointA","pointB","isVisiblePoint","leftNode","rightNode","prevPointUntil","nextPointUntil","isCharPoint","walkPoint","startPoint","endPoint","handler","isSkipOffset","makeOffsetPath","fromOffsetPath","offsets","splitNode","isSkipPaddingBlankHTML","isNotSplitEdgePoint","splitText","childNode","clone","splitTree","root","splitPoint","splitRoot","topAncestor","pivot","createText","isRemoveChild","removeNode","removeWhile","newNode","isTextarea","$node","stripLinebreaks","html","isNewlineOnBlock","markup","regexTag","endSlash","isEndOfInlineContainer","isBlockNode","trim","posFromPlaceholder","$placeholder","outerHeight","attachEvents","forEach","detachEvents","ZERO_WIDTH_NBSP_CHAR","blank","emptyPara","isDiv","isBR","isSpan","isB","isU","isS","isI","isImg","isEmptyAnchor","Context","$note","ui","memos","modules","layoutInfo","initialize","createLayout","_initialize","hide","destroy","_destroy","removeData","removeLayout","isDisabled","disable","buttons","plugins","initializeModule","removeModule","removeMemo","isActivated","codable","editable","triggerEvent","attr","enable","callback","trigger","shouldInitialize","ModuleClass","withoutIntialize","createInvokeHandler","closest","splits","hasSeparator","moduleName","methodName","isExternalAPICalled","hasInitOptions","langInfo","lang","note","Renderer","render","$parent","contents","click","$container","append","renderer","isArray","editor","toolbar","editingArea","statusbar","airEditor","airEditable","buttonGroup","tooltip","placement","dropdown","items","template","dropdownCheck","icon","checkClassName","palette","row","rowSize","colors","eventName","colSize","color","dialog","fade","footer","popover","hideArrow","iconClassName","tagName","toggleBtn","$btn","isEnable","toggleClass","toggleBtnActive","isActive","onDialogShown","$dialog","one","onDialogHidden","showDialog","modal","hideDialog","$editor","airMode","show","en-US","font","bold","italic","underline","strikethrough","subscript","superscript","image","resizeFull","resizeHalf","resizeQuarter","floatLeft","floatRight","floatNone","shapeRounded","shapeCircle","shapeThumbnail","shapeNone","dragImageHere","dropImage","selectFromFiles","maximumFileSize","maximumFileSizeError","url","video","videoLink","providers","unlink","edit","textToDisplay","openInNewWindow","table","hr","blockquote","h1","h2","h3","h4","h5","h6","lists","unordered","ordered","fullscreen","codeview","paragraph","outdent","center","justify","recent","more","foreground","transparent","setTransparent","resetToDefault","shortcut","shortcuts","textFormatting","action","paragraphFormatting","documentStyle","insertParagraph","tab","untab","removeFormat","justifyLeft","justifyCenter","justifyRight","justifyFull","insertUnorderedList","insertOrderedList","formatPara","formatH1","formatH2","formatH3","formatH4","formatH5","formatH6","insertHorizontalRule","linkDialog.show","specialChar","BACKSPACE","TAB","ENTER","SPACE","LEFT","UP","RIGHT","DOWN","NUM0","NUM1","NUM2","NUM3","NUM4","NUM5","NUM6","NUM7","NUM8","B","E","I","J","K","L","R","S","U","V","Y","Z","SLASH","LEFTBRACKET","BACKSLASH","RIGHTBRACKET","isEdit","isMove","nameFromCode","textRangeToPoint","textRange","isStart","prevContainer","tester","textRangeStart","curTextNode","pointTester","duplicate","setEndPoint","textCount","cont","pointToTextRange","textRangeInfo","isCollapseToStart","prevTextNodes","collapseToStart","WrappedRange","sc","so","ec","eo","nativeRange","w3cRange","getPoints","getStartPoint","getEndPoint","nativeRng","normalize","getVisiblePoint","isLeftToRight","block","isCollapsed","includeAncestor","fullyContains","leftEdgeNodes","expand","startAncestor","endAncestor","boundaryPoints","isSameContainer","deleteContents","emptyParents","makeIsOn","isOnEditable","isOnList","isOnAnchor","isOnCell","wrapBodyInlineWithPara","inlineSiblings","para","insertNode","pasteHTML","contentsContainer","getWordRange","findAfter","bookmark","s","path","paraBookmark","paras","wrappedRange","createFromSelection","createFromNode","startContainer","startOffset","endContainer","endOffset","textRangeEnd","isTextNode","createFromNodeBefore","createFromNodeAfter","createFromBookmark","createFromParaBookmark","async","readFileAsDataURL","Deferred","deferred","dataURL","resolve","onerror","reject","readAsDataURL","promise","createImage","$img","$editable","stack","stackOffset","makeSnapshot","emptyBookmark","applySnapshot","rewind","recordUndo","Style","jQueryCSS","$obj","propertyNames","propertyName","styleInfo","stylePara","styleNodes","expandClosestSibling","onlyPartialContains","nodesInRange","tails","elem","$cont","font-bold","queryCommandState","font-italic","font-underline","font-subscript","font-superscript","font-strikethrough","orderedTypes","isUnordered","lineHeight","toFixed","Bullet","toggleList","clustereds","wrapList","releaseList","listName","wrappedParas","diffLists","listNode","prevList","nextList","isEscapseToBody","releasedParas","headList","lastList","middleList","rootLists","rootList","listNodes","Typing","bullet","tabsize","nextPara","emptyAnchors","Table","isShift","cell","cells","nextCell","createTable","colCount","rowCount","tdHTML","tds","idxCol","trHTML","trs","idxRow","$table","tableClassName","Editor","lastRange","isDefaultPrevented","handleKeyMap","changeEventName","setHeight","maxHeight","afterCommand","saveRange","thenCollapse","restoreRange","saveTarget","clearTarget","restoreTarget","styleFromNode","beforeCommand","isPreventTrigger","sCmd","wrapCommand","insertImage","param","then","$image","insertImages","filename","maximumImageFileSize","insertImagesOrCallback","onImageUpload","insertText","getSelectedText","formatBlock","firstSpan","font-size","hrNode","removeBogus","bogusNode","bogusCharIdx","deleteData","createLink","linkInfo","linkUrl","linkText","isNewWindow","isTextChanged","onCreateLink","anchors","removeAttr","startRange","endRange","getLinkInfo","$anchor","colorInfo","foreColor","backColor","insertTable","dim","dimension","floatMe","resize","resizeTo","$target","bKeepRatio","imageSize","newRatio","ratio","removeMedia","is","Clipboard","summernote.keydown","we","needKeydownHook","$paste","pasteByHook","opacity","pasteByEvent","dataURI","decodedData","atob","Uint8Array","blob","Blob","pasteContent","originalEvent","kind","getAsFile","Dropzone","$dropzone","prependTo","disableDragAndDrop","attachDragAndDropEvent","$dropzoneMessage","isCodeview","hasEditorSize","removeClass","Promise","__WEBPACK_AMD_REQUIRE_ARRAY__","catch","oe","Codeview","$codable","sync","deactivate","activate","prettifyHtml","cmEditor","codemirror","tern","server","TernServer","ternServer","updateArgHints","isChange","Statusbar","$statusbar","disableResizeEditor","editableTop","minheight","Fullscreen","$toolbar","$window","$scrollbar","setsize","isFullscreen","Handle","$editingArea","summernote.mousedown","summernote.keyup summernote.scroll summernote.change summernote.dialog.shown","$handle","disableResizeImage","posStart","isImage","$selection","outerWidth","sizingText","AutoLink","linkPattern","summernote.keyup","handleKeyup","handleKeydown","lastWordRange","keyword","wordRange","AutoSync","summernote.change","Placeholder","summernote.init summernote.change","summernote.codeview.toggled","isShow","Buttons","invertedKeyMap","representShortcut","editorMethod","addToolbarButtons","addImagePopoverButtons","addLinkPopoverButtons","fontInstalledMap","fontNamesIgnoreCheck","icons","magic","caret","styleTags","eraser","menuCheck","fontNames","fontSizes","$button","currentTarget","$dropdown","$holder","$color","$currentButton","unorderedlist","orderedlist","alignLeft","alignCenter","alignRight","alignJustify","lineHeights","insertTableMaxSize","mousedown","tableMoveHandler","picture","minus","arrowsAlt","question","trash","build","groups","groupIdx","groupLen","groupName","$group","updateCurrentStyle","updateBtnStates",".note-btn-bold",".note-btn-italic",".note-btn-underline",".note-btn-subscript",".note-btn-superscript",".note-btn-strikethrough","isChecked","infos","selector","posOffset","$picker","$dimensionDisplay","$catcher","$highlighted","$unhighlighted","offsetX","posCatcher","offsetY","c","Toolbar","toolbarContainer","updateFullscreen","updateCodeview","isIncludeCodeview","LinkDialog","dialogsInBody","disableLinkTarget","dialogsFade","bindEnterKey","$input","showLinkDialog","$linkText","$linkUrl","$linkBtn","$openInNewWindow","LinkPopover","summernote.keyup summernote.mouseup summernote.change summernote.scroll","summernote.dialog.shown","$popover","prepend","$content","href","ImageDialog","imageLimitation","log","readableSize","pow","showImageDialog","$imageInput","$imageUrl","$imageBtn","replaceWith","ImagePopover","VideoDialog","createVideoNode","$video","ytRegExp","ytMatch","igRegExp","igMatch","vRegExp","vMatch","vimRegExp","vimMatch","dmRegExp","dmMatch","youkuRegExp","youkuMatch","mp4RegExp","mp4Match","oggRegExp","oggMatch","webmRegExp","webmMatch","youtubeId","showVideoDialog","$videoUrl","$videoBtn","HelpDialog","createShortCutList","command","$row","margin-right","max-height","overflow","showHelpDialog","AirPopover","summernote.keyup summernote.mouseup summernote.scroll","summernote.change summernote.dialog.shown","summernote.focusout","relatedTarget","air","bnd","HintPopover","hintDirection","hints","selectItem","$item","moveDown","$current","$next","$nextGroup","moveUp","$prev","$prevGroup","nodeFromItem","createItemTemplates","hintIdx","searchKeyword","createGroup","clipboard","dropzone","hintPopover","autoLink","autoSync","linkDialog","linkPopover","imageDialog","imagePopover","videoDialog","helpDialog","airPopover","styleWithSpan","textareaAutoSync","onInit","onEnter","onKeyup","onKeydown","onSubmit","onImageUploadError","htmlMode","pc","CTRL+Z","CTRL+Y","SHIFT+TAB","CTRL+B","CTRL+I","CTRL+U","CTRL+SHIFT+S","CTRL+BACKSLASH","CTRL+SHIFT+L","CTRL+SHIFT+E","CTRL+SHIFT+R","CTRL+SHIFT+J","CTRL+SHIFT+NUM7","CTRL+SHIFT+NUM8","CTRL+LEFTBRACKET","CTRL+RIGHTBRACKET","CTRL+NUM0","CTRL+NUM1","CTRL+NUM2","CTRL+NUM3","CTRL+NUM4","CTRL+NUM5","CTRL+NUM6","CTRL+ENTER","CTRL+K","CMD+Z","CMD+SHIFT+Z","CMD+B","CMD+I","CMD+U","CMD+SHIFT+S","CMD+BACKSLASH","CMD+SHIFT+L","CMD+SHIFT+E","CMD+SHIFT+R","CMD+SHIFT+J","CMD+SHIFT+NUM7","CMD+SHIFT+NUM8","CMD+LEFTBRACKET","CMD+RIGHTBRACKET","CMD+NUM0","CMD+NUM1","CMD+NUM2","CMD+NUM3","CMD+NUM4","CMD+NUM5","CMD+NUM6","CMD+ENTER","CMD+K","circle","frame","pencil","square","152","__webpack_amd_options__"],"mappings":"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","file":"0.js","sourcesContent":["webpackJsonp([0],{\n\n/***/ 145:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_jquery__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_summernote_webpack__ = __webpack_require__(151);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_summernote_webpack___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_summernote_webpack__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\nvar SummerNote = function SummerNote() {\n    _classCallCheck(this, SummerNote);\n\n    __WEBPACK_IMPORTED_MODULE_0_jquery___default()('.summernote').summernote({\n        height: 400\n    });\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SummerNote);\n\n/***/ }),\n\n/***/ 149:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n// Kludges for bugs and behavior differences that can't be feature\n// detected are enabled based on userAgent etc sniffing.\nvar userAgent = navigator.userAgent;\nvar platform = navigator.platform;\n\nvar gecko = /gecko\\/\\d/i.test(userAgent);\nvar ie_upto10 = /MSIE \\d/.test(userAgent);\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\nvar edge = /Edge\\/(\\d+)/.exec(userAgent);\nvar ie = ie_upto10 || ie_11up || edge;\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\nvar webkit = !edge && /WebKit\\//.test(userAgent);\nvar qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\nvar chrome = !edge && /Chrome\\//.test(userAgent);\nvar presto = /Opera\\//.test(userAgent);\nvar safari = /Apple Computer/.test(navigator.vendor);\nvar mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\nvar phantom = /PhantomJS/.test(userAgent);\n\nvar ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\nvar android = /Android/.test(userAgent);\n// This is woefully incomplete. Suggestions for alternative methods welcome.\nvar mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\nvar mac = ios || /Mac/.test(platform);\nvar chromeOS = /\\bCrOS\\b/.test(userAgent);\nvar windows = /win/i.test(platform);\n\nvar presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\nif (presto_version) { presto_version = Number(presto_version[1]); }\nif (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\nvar captureRightClick = gecko || (ie && ie_version >= 9);\n\nfunction classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\nvar rmClass = function(node, cls) {\n  var current = node.className;\n  var match = classTest(cls).exec(current);\n  if (match) {\n    var after = current.slice(match.index + match[0].length);\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n  }\n};\n\nfunction removeChildren(e) {\n  for (var count = e.childNodes.length; count > 0; --count)\n    { e.removeChild(e.firstChild); }\n  return e\n}\n\nfunction removeChildrenAndAdd(parent, e) {\n  return removeChildren(parent).appendChild(e)\n}\n\nfunction elt(tag, content, className, style) {\n  var e = document.createElement(tag);\n  if (className) { e.className = className; }\n  if (style) { e.style.cssText = style; }\n  if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n  return e\n}\n// wrapper for elt, which removes the elt from the accessibility tree\nfunction eltP(tag, content, className, style) {\n  var e = elt(tag, content, className, style);\n  e.setAttribute(\"role\", \"presentation\");\n  return e\n}\n\nvar range;\nif (document.createRange) { range = function(node, start, end, endNode) {\n  var r = document.createRange();\n  r.setEnd(endNode || node, end);\n  r.setStart(node, start);\n  return r\n}; }\nelse { range = function(node, start, end) {\n  var r = document.body.createTextRange();\n  try { r.moveToElementText(node.parentNode); }\n  catch(e) { return r }\n  r.collapse(true);\n  r.moveEnd(\"character\", end);\n  r.moveStart(\"character\", start);\n  return r\n}; }\n\nfunction contains(parent, child) {\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n    { child = child.parentNode; }\n  if (parent.contains)\n    { return parent.contains(child) }\n  do {\n    if (child.nodeType == 11) { child = child.host; }\n    if (child == parent) { return true }\n  } while (child = child.parentNode)\n}\n\nfunction activeElt() {\n  // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n  var activeElement;\n  try {\n    activeElement = document.activeElement;\n  } catch(e) {\n    activeElement = document.body || null;\n  }\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n    { activeElement = activeElement.shadowRoot.activeElement; }\n  return activeElement\n}\n\nfunction addClass(node, cls) {\n  var current = node.className;\n  if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n}\nfunction joinClasses(a, b) {\n  var as = a.split(\" \");\n  for (var i = 0; i < as.length; i++)\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n  return b\n}\n\nvar selectInput = function(node) { node.select(); };\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\nelse if (ie) // Suppress mysterious IE10 errors\n  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\nfunction bind(f) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function(){return f.apply(null, args)}\n}\n\nfunction copyObj(obj, target, overwrite) {\n  if (!target) { target = {}; }\n  for (var prop in obj)\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n      { target[prop] = obj[prop]; } }\n  return target\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) { end = string.length; }\n  }\n  for (var i = startIndex || 0, n = startValue || 0;;) {\n    var nextTab = string.indexOf(\"\\t\", i);\n    if (nextTab < 0 || nextTab >= end)\n      { return n + (end - i) }\n    n += nextTab - i;\n    n += tabSize - (n % tabSize);\n    i = nextTab + 1;\n  }\n}\n\nvar Delayed = function() {this.id = null;};\nDelayed.prototype.set = function (ms, f) {\n  clearTimeout(this.id);\n  this.id = setTimeout(f, ms);\n};\n\nfunction indexOf(array, elt) {\n  for (var i = 0; i < array.length; ++i)\n    { if (array[i] == elt) { return i } }\n  return -1\n}\n\n// Number of pixels added to scroller and sizer to hide scrollbar\nvar scrollerGap = 30;\n\n// Returned or thrown by various protocols to signal 'I'm not\n// handling this'.\nvar Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n// Reused option objects for setSelection & friends\nvar sel_dontScroll = {scroll: false};\nvar sel_mouse = {origin: \"*mouse\"};\nvar sel_move = {origin: \"+move\"};\n\n// The inverse of countColumn -- find the offset that corresponds to\n// a particular column.\nfunction findColumn(string, goal, tabSize) {\n  for (var pos = 0, col = 0;;) {\n    var nextTab = string.indexOf(\"\\t\", pos);\n    if (nextTab == -1) { nextTab = string.length; }\n    var skipped = nextTab - pos;\n    if (nextTab == string.length || col + skipped >= goal)\n      { return pos + Math.min(skipped, goal - col) }\n    col += nextTab - pos;\n    col += tabSize - (col % tabSize);\n    pos = nextTab + 1;\n    if (col >= goal) { return pos }\n  }\n}\n\nvar spaceStrs = [\"\"];\nfunction spaceStr(n) {\n  while (spaceStrs.length <= n)\n    { spaceStrs.push(lst(spaceStrs) + \" \"); }\n  return spaceStrs[n]\n}\n\nfunction lst(arr) { return arr[arr.length-1] }\n\nfunction map(array, f) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n  return out\n}\n\nfunction insertSorted(array, value, score) {\n  var pos = 0, priority = score(value);\n  while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n  array.splice(pos, 0, value);\n}\n\nfunction nothing() {}\n\nfunction createObj(base, props) {\n  var inst;\n  if (Object.create) {\n    inst = Object.create(base);\n  } else {\n    nothing.prototype = base;\n    inst = new nothing();\n  }\n  if (props) { copyObj(props, inst); }\n  return inst\n}\n\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nfunction isWordCharBasic(ch) {\n  return /\\w/.test(ch) || ch > \"\\x80\" &&\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n}\nfunction isWordChar(ch, helper) {\n  if (!helper) { return isWordCharBasic(ch) }\n  if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n  return helper.test(ch)\n}\n\nfunction isEmpty(obj) {\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n  return true\n}\n\n// Extending unicode characters. A series of a non-extending char +\n// any number of extending chars is treated as a single unit as far\n// as editing and measuring is concerned. This is not fully correct,\n// since some scripts/fonts/browsers also treat other configurations\n// of code points as a group.\nvar extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\nfunction skipExtendingChars(str, pos, dir) {\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n  return pos\n}\n\n// Returns the value from the range [`from`; `to`] that satisfies\n// `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`.\nfunction findFirst(pred, from, to) {\n  for (;;) {\n    if (Math.abs(from - to) <= 1) { return pred(from) ? from : to }\n    var mid = Math.floor((from + to) / 2);\n    if (pred(mid)) { to = mid; }\n    else { from = mid; }\n  }\n}\n\n// The display handles the DOM integration, both for input reading\n// and content drawing. It holds references to DOM nodes and\n// display-related state.\n\nfunction Display(place, doc, input) {\n  var d = this;\n  this.input = input;\n\n  // Covers bottom-right square when both scrollbars are present.\n  d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n  d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\n  // and h scrollbar is present.\n  d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n  d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Will contain the actual code, positioned to cover the viewport.\n  d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n  // Elements are added to these to represent selection and cursors.\n  d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n  d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n  // A visibility: hidden element used to find the size of things.\n  d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n  // When lines outside of the viewport are measured, they are drawn in this.\n  d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\n  d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                    null, \"position: relative; outline: none\");\n  var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n  // Moved around its parent to cover visible view.\n  d.mover = elt(\"div\", [lines], null, \"position: relative\");\n  // Set to the height of the document, allowing scrolling.\n  d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n  d.sizerWidth = null;\n  // Behavior of elts with overflow: auto and padding is\n  // inconsistent across browsers. This is used to ensure the\n  // scrollable area is big enough.\n  d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n  // Will contain the gutters, if any.\n  d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n  d.lineGutter = null;\n  // Actual scrollable element.\n  d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n  d.scroller.setAttribute(\"tabIndex\", \"-1\");\n  // The element in which the editor lives.\n  d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n  if (place) {\n    if (place.appendChild) { place.appendChild(d.wrapper); }\n    else { place(d.wrapper); }\n  }\n\n  // Current rendered range (may be bigger than the view window).\n  d.viewFrom = d.viewTo = doc.first;\n  d.reportedViewFrom = d.reportedViewTo = doc.first;\n  // Information about the rendered lines.\n  d.view = [];\n  d.renderedView = null;\n  // Holds info about a single rendered line when it was rendered\n  // for measurement, while not in view.\n  d.externalMeasured = null;\n  // Empty space (in pixels) above the view\n  d.viewOffset = 0;\n  d.lastWrapHeight = d.lastWrapWidth = 0;\n  d.updateLineNumbers = null;\n\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n  d.scrollbarsClipped = false;\n\n  // Used to only resize the line number gutter when necessary (when\n  // the amount of lines crosses a boundary that makes its width change)\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n  // Set to true when a non-horizontal-scrolling line widget is\n  // added. As an optimization, line widget aligning is skipped when\n  // this is false.\n  d.alignWidgets = false;\n\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n  // Tracks the maximum line length so that the horizontal scrollbar\n  // can be kept static when scrolling.\n  d.maxLine = null;\n  d.maxLineLength = 0;\n  d.maxLineChanged = false;\n\n  // Used for measuring wheel scrolling granularity\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n  // True when shift is held down.\n  d.shift = false;\n\n  // Used to track whether anything happened since the context menu\n  // was opened.\n  d.selForContextMenu = null;\n\n  d.activeTouch = null;\n\n  input.init(d);\n}\n\n// Find the line object corresponding to the given line number.\nfunction getLine(doc, n) {\n  n -= doc.first;\n  if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n  var chunk = doc;\n  while (!chunk.lines) {\n    for (var i = 0;; ++i) {\n      var child = chunk.children[i], sz = child.chunkSize();\n      if (n < sz) { chunk = child; break }\n      n -= sz;\n    }\n  }\n  return chunk.lines[n]\n}\n\n// Get the part of a document between two positions, as an array of\n// strings.\nfunction getBetween(doc, start, end) {\n  var out = [], n = start.line;\n  doc.iter(start.line, end.line + 1, function (line) {\n    var text = line.text;\n    if (n == end.line) { text = text.slice(0, end.ch); }\n    if (n == start.line) { text = text.slice(start.ch); }\n    out.push(text);\n    ++n;\n  });\n  return out\n}\n// Get the lines between from and to, as array of strings.\nfunction getLines(doc, from, to) {\n  var out = [];\n  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n  return out\n}\n\n// Update the height of a line, propagating the height change\n// upwards to parent nodes.\nfunction updateLineHeight(line, height) {\n  var diff = height - line.height;\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n}\n\n// Given a line object, find its line number by walking up through\n// its parent links.\nfunction lineNo(line) {\n  if (line.parent == null) { return null }\n  var cur = line.parent, no = indexOf(cur.lines, line);\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n    for (var i = 0;; ++i) {\n      if (chunk.children[i] == cur) { break }\n      no += chunk.children[i].chunkSize();\n    }\n  }\n  return no + cur.first\n}\n\n// Find the line at the given vertical position, using the height\n// information in the document tree.\nfunction lineAtHeight(chunk, h) {\n  var n = chunk.first;\n  outer: do {\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n      var child = chunk.children[i$1], ch = child.height;\n      if (h < ch) { chunk = child; continue outer }\n      h -= ch;\n      n += child.chunkSize();\n    }\n    return n\n  } while (!chunk.lines)\n  var i = 0;\n  for (; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i], lh = line.height;\n    if (h < lh) { break }\n    h -= lh;\n  }\n  return n + i\n}\n\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\nfunction lineNumberFor(options, i) {\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\n}\n\n// A Pos instance represents a position within the text.\nfunction Pos(line, ch, sticky) {\n  if ( sticky === void 0 ) sticky = null;\n\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n  this.line = line;\n  this.ch = ch;\n  this.sticky = sticky;\n}\n\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\nfunction copyPos(x) {return Pos(x.line, x.ch)}\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n// Most of the external API clips given positions to make sure they\n// actually exist within the document.\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\nfunction clipPos(doc, pos) {\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\n  var last = doc.first + doc.size - 1;\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\n}\nfunction clipToLen(pos, linelen) {\n  var ch = pos.ch;\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n  else if (ch < 0) { return Pos(pos.line, 0) }\n  else { return pos }\n}\nfunction clipPosArray(doc, array) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n  return out\n}\n\n// Optimize some code when these features are not used.\nvar sawReadOnlySpans = false;\nvar sawCollapsedSpans = false;\n\nfunction seeReadOnlySpans() {\n  sawReadOnlySpans = true;\n}\n\nfunction seeCollapsedSpans() {\n  sawCollapsedSpans = true;\n}\n\n// TEXTMARKER SPANS\n\nfunction MarkedSpan(marker, from, to) {\n  this.marker = marker;\n  this.from = from; this.to = to;\n}\n\n// Search an array of spans for a span matching the given marker.\nfunction getMarkedSpanFor(spans, marker) {\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.marker == marker) { return span }\n  } }\n}\n// Remove a span from an array, returning undefined if no spans are\n// left (we don't store arrays for lines without spans).\nfunction removeMarkedSpan(spans, span) {\n  var r;\n  for (var i = 0; i < spans.length; ++i)\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n  return r\n}\n// Add a span to a line.\nfunction addMarkedSpan(line, span) {\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n  span.marker.attachLine(line);\n}\n\n// Used for the algorithm that adjusts markers for a change in the\n// document. These functions cut an array of spans at a given\n// character position, returning an array of remaining chunks (or\n// undefined if nothing remains).\nfunction markedSpansBefore(old, startCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n    if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n    }\n  } }\n  return nw\n}\nfunction markedSpansAfter(old, endCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n    if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                            span.to == null ? null : span.to - endCh));\n    }\n  } }\n  return nw\n}\n\n// Given a change object, compute the new set of marker spans that\n// cover the line in which the change took place. Removes spans\n// entirely within the change, reconnects spans belonging to the\n// same marker that appear on both sides of the change, and cuts off\n// spans partially within the change. Returns an array of span\n// arrays with one element for each line in (after) the change.\nfunction stretchSpansOverChange(doc, change) {\n  if (change.full) { return null }\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n  if (!oldFirst && !oldLast) { return null }\n\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n  // Get the spans that 'stick out' on both sides\n  var first = markedSpansBefore(oldFirst, startCh, isInsert);\n  var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n  // Next, merge those two ends\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n  if (first) {\n    // Fix up .to properties of first\n    for (var i = 0; i < first.length; ++i) {\n      var span = first[i];\n      if (span.to == null) {\n        var found = getMarkedSpanFor(last, span.marker);\n        if (!found) { span.to = startCh; }\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n      }\n    }\n  }\n  if (last) {\n    // Fix up .from in last (or move them into first in case of sameLine)\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\n      var span$1 = last[i$1];\n      if (span$1.to != null) { span$1.to += offset; }\n      if (span$1.from == null) {\n        var found$1 = getMarkedSpanFor(first, span$1.marker);\n        if (!found$1) {\n          span$1.from = offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      } else {\n        span$1.from += offset;\n        if (sameLine) { (first || (first = [])).push(span$1); }\n      }\n    }\n  }\n  // Make sure we didn't create any zero-length spans\n  if (first) { first = clearEmptySpans(first); }\n  if (last && last != first) { last = clearEmptySpans(last); }\n\n  var newMarkers = [first];\n  if (!sameLine) {\n    // Fill gap with whole-line-spans\n    var gap = change.text.length - 2, gapMarkers;\n    if (gap > 0 && first)\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\n        { if (first[i$2].to == null)\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n    for (var i$3 = 0; i$3 < gap; ++i$3)\n      { newMarkers.push(gapMarkers); }\n    newMarkers.push(last);\n  }\n  return newMarkers\n}\n\n// Remove spans that are empty and don't have a clearWhenEmpty\n// option of false.\nfunction clearEmptySpans(spans) {\n  for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n      { spans.splice(i--, 1); }\n  }\n  if (!spans.length) { return null }\n  return spans\n}\n\n// Used to 'clip' out readOnly ranges when making a change.\nfunction removeReadOnlyRanges(doc, from, to) {\n  var markers = null;\n  doc.iter(from.line, to.line + 1, function (line) {\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var mark = line.markedSpans[i].marker;\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n        { (markers || (markers = [])).push(mark); }\n    } }\n  });\n  if (!markers) { return null }\n  var parts = [{from: from, to: to}];\n  for (var i = 0; i < markers.length; ++i) {\n    var mk = markers[i], m = mk.find(0);\n    for (var j = 0; j < parts.length; ++j) {\n      var p = parts[j];\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n        { newParts.push({from: p.from, to: m.from}); }\n      if (dto > 0 || !mk.inclusiveRight && !dto)\n        { newParts.push({from: m.to, to: p.to}); }\n      parts.splice.apply(parts, newParts);\n      j += newParts.length - 3;\n    }\n  }\n  return parts\n}\n\n// Connect or disconnect spans from a line.\nfunction detachMarkedSpans(line) {\n  var spans = line.markedSpans;\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.detachLine(line); }\n  line.markedSpans = null;\n}\nfunction attachMarkedSpans(line, spans) {\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.attachLine(line); }\n  line.markedSpans = spans;\n}\n\n// Helpers used when computing which overlapping collapsed span\n// counts as the larger one.\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n// Returns a number indicating which of two overlapping collapsed\n// spans is larger (and thus includes the other). Falls back to\n// comparing ids when the spans cover exactly the same range.\nfunction compareCollapsedMarkers(a, b) {\n  var lenDiff = a.lines.length - b.lines.length;\n  if (lenDiff != 0) { return lenDiff }\n  var aPos = a.find(), bPos = b.find();\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n  if (fromCmp) { return -fromCmp }\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n  if (toCmp) { return toCmp }\n  return b.id - a.id\n}\n\n// Find out whether a line ends or starts in a collapsed span. If\n// so, return the marker for that span.\nfunction collapsedSpanAtSide(line, start) {\n  var sps = sawCollapsedSpans && line.markedSpans, found;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n      { found = sp.marker; }\n  } }\n  return found\n}\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n// Test whether there exists a collapsed span that partially\n// overlaps (covers the start or end, but not both) of a new span.\n// Such overlap is not allowed.\nfunction conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n  var line = getLine(doc, lineNo$$1);\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\n    var sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    var found = sp.marker.find(0);\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n      { return true }\n  } }\n}\n\n// A visual line is a line as drawn on the screen. Folding, for\n// example, can cause multiple logical lines to appear on the same\n// visual line. This finds the start of the visual line that the\n// given line is part of (usually that is the line itself).\nfunction visualLine(line) {\n  var merged;\n  while (merged = collapsedSpanAtStart(line))\n    { line = merged.find(-1, true).line; }\n  return line\n}\n\nfunction visualLineEnd(line) {\n  var merged;\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return line\n}\n\n// Returns an array of logical lines that continue the visual line\n// started by the argument, or undefined if there are no such lines.\nfunction visualLineContinued(line) {\n  var merged, lines;\n  while (merged = collapsedSpanAtEnd(line)) {\n    line = merged.find(1, true).line\n    ;(lines || (lines = [])).push(line);\n  }\n  return lines\n}\n\n// Get the line number of the start of the visual line that the\n// given line number is part of.\nfunction visualLineNo(doc, lineN) {\n  var line = getLine(doc, lineN), vis = visualLine(line);\n  if (line == vis) { return lineN }\n  return lineNo(vis)\n}\n\n// Get the line number of the start of the next visual line after\n// the given line.\nfunction visualLineEndNo(doc, lineN) {\n  if (lineN > doc.lastLine()) { return lineN }\n  var line = getLine(doc, lineN), merged;\n  if (!lineIsHidden(doc, line)) { return lineN }\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return lineNo(line) + 1\n}\n\n// Compute whether a line is hidden. Lines count as hidden when they\n// are part of a visual line that starts with another line, or when\n// they are entirely covered by collapsed, non-widget span.\nfunction lineIsHidden(doc, line) {\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    if (sp.from == null) { return true }\n    if (sp.marker.widgetNode) { continue }\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n      { return true }\n  } }\n}\nfunction lineIsHiddenInner(doc, line, span) {\n  if (span.to == null) {\n    var end = span.marker.find(1, true);\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n  }\n  if (span.marker.inclusiveRight && span.to == line.text.length)\n    { return true }\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n    sp = line.markedSpans[i];\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n        (sp.to == null || sp.to != span.from) &&\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n        lineIsHiddenInner(doc, line, sp)) { return true }\n  }\n}\n\n// Find the height above the given line.\nfunction heightAtLine(lineObj) {\n  lineObj = visualLine(lineObj);\n\n  var h = 0, chunk = lineObj.parent;\n  for (var i = 0; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i];\n    if (line == lineObj) { break }\n    else { h += line.height; }\n  }\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n      var cur = p.children[i$1];\n      if (cur == chunk) { break }\n      else { h += cur.height; }\n    }\n  }\n  return h\n}\n\n// Compute the character length of a line, taking into account\n// collapsed ranges (see markText) that might hide parts, and join\n// other lines onto it.\nfunction lineLength(line) {\n  if (line.height == 0) { return 0 }\n  var len = line.text.length, merged, cur = line;\n  while (merged = collapsedSpanAtStart(cur)) {\n    var found = merged.find(0, true);\n    cur = found.from.line;\n    len += found.from.ch - found.to.ch;\n  }\n  cur = line;\n  while (merged = collapsedSpanAtEnd(cur)) {\n    var found$1 = merged.find(0, true);\n    len -= cur.text.length - found$1.from.ch;\n    cur = found$1.to.line;\n    len += cur.text.length - found$1.to.ch;\n  }\n  return len\n}\n\n// Find the longest line in the document.\nfunction findMaxLine(cm) {\n  var d = cm.display, doc = cm.doc;\n  d.maxLine = getLine(doc, doc.first);\n  d.maxLineLength = lineLength(d.maxLine);\n  d.maxLineChanged = true;\n  doc.iter(function (line) {\n    var len = lineLength(line);\n    if (len > d.maxLineLength) {\n      d.maxLineLength = len;\n      d.maxLine = line;\n    }\n  });\n}\n\n// BIDI HELPERS\n\nfunction iterateBidiSections(order, from, to, f) {\n  if (!order) { return f(from, to, \"ltr\") }\n  var found = false;\n  for (var i = 0; i < order.length; ++i) {\n    var part = order[i];\n    if (part.from < to && part.to > from || from == to && part.to == from) {\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n      found = true;\n    }\n  }\n  if (!found) { f(from, to, \"ltr\"); }\n}\n\nvar bidiOther = null;\nfunction getBidiPartAt(order, ch, sticky) {\n  var found;\n  bidiOther = null;\n  for (var i = 0; i < order.length; ++i) {\n    var cur = order[i];\n    if (cur.from < ch && cur.to > ch) { return i }\n    if (cur.to == ch) {\n      if (cur.from != cur.to && sticky == \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n    if (cur.from == ch) {\n      if (cur.from != cur.to && sticky != \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n  }\n  return found != null ? found : bidiOther\n}\n\n// Bidirectional ordering algorithm\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n// that this (partially) implements.\n\n// One-char codes used for character types:\n// L (L):   Left-to-Right\n// R (R):   Right-to-Left\n// r (AL):  Right-to-Left Arabic\n// 1 (EN):  European Number\n// + (ES):  European Number Separator\n// % (ET):  European Number Terminator\n// n (AN):  Arabic Number\n// , (CS):  Common Number Separator\n// m (NSM): Non-Spacing Mark\n// b (BN):  Boundary Neutral\n// s (B):   Paragraph Separator\n// t (S):   Segment Separator\n// w (WS):  Whitespace\n// N (ON):  Other Neutrals\n\n// Returns null if characters are ordered as they appear\n// (left-to-right), or an array of sections ({from, to, level}\n// objects) in the order in which they occur visually.\nvar bidiOrdering = (function() {\n  // Character types for codepoints 0 to 0xff\n  var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n  // Character types for codepoints 0x600 to 0x6f9\n  var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n  function charType(code) {\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\n    else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n    else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n    else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n    else if (code == 0x200c) { return \"b\" }\n    else { return \"L\" }\n  }\n\n  var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n  function BidiSpan(level, from, to) {\n    this.level = level;\n    this.from = from; this.to = to;\n  }\n\n  return function(str, direction) {\n    var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n    if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n    var len = str.length, types = [];\n    for (var i = 0; i < len; ++i)\n      { types.push(charType(str.charCodeAt(i))); }\n\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\n    // change the type of the NSM to the type of the previous\n    // character. If the NSM is at the start of the level run, it will\n    // get the type of sor.\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n      var type = types[i$1];\n      if (type == \"m\") { types[i$1] = prev; }\n      else { prev = type; }\n    }\n\n    // W2. Search backwards from each instance of a European number\n    // until the first strong type (R, L, AL, or sor) is found. If an\n    // AL is found, change the type of the European number to Arabic\n    // number.\n    // W3. Change all ALs to R.\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n      var type$1 = types[i$2];\n      if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n    }\n\n    // W4. A single European separator between two European numbers\n    // changes to a European number. A single common separator between\n    // two numbers of the same type changes to that type.\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n      var type$2 = types[i$3];\n      if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n      else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n               (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n      prev$1 = type$2;\n    }\n\n    // W5. A sequence of European terminators adjacent to European\n    // numbers changes to all European numbers.\n    // W6. Otherwise, separators and terminators change to Other\n    // Neutral.\n    for (var i$4 = 0; i$4 < len; ++i$4) {\n      var type$3 = types[i$4];\n      if (type$3 == \",\") { types[i$4] = \"N\"; }\n      else if (type$3 == \"%\") {\n        var end = (void 0);\n        for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n        var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n        for (var j = i$4; j < end; ++j) { types[j] = replace; }\n        i$4 = end - 1;\n      }\n    }\n\n    // W7. Search backwards from each instance of a European number\n    // until the first strong type (R, L, or sor) is found. If an L is\n    // found, then change the type of the European number to L.\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n      var type$4 = types[i$5];\n      if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n      else if (isStrong.test(type$4)) { cur$1 = type$4; }\n    }\n\n    // N1. A sequence of neutrals takes the direction of the\n    // surrounding strong text if the text on both sides has the same\n    // direction. European and Arabic numbers act as if they were R in\n    // terms of their influence on neutrals. Start-of-level-run (sor)\n    // and end-of-level-run (eor) are used at level run boundaries.\n    // N2. Any remaining neutrals take the embedding direction.\n    for (var i$6 = 0; i$6 < len; ++i$6) {\n      if (isNeutral.test(types[i$6])) {\n        var end$1 = (void 0);\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n        var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n        var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n        var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n        i$6 = end$1 - 1;\n      }\n    }\n\n    // Here we depart from the documented algorithm, in order to avoid\n    // building up an actual levels array. Since there are only three\n    // levels (0, 1, 2) in an implementation that doesn't take\n    // explicit embedding into account, we can build up the order on\n    // the fly, without following the level-based algorithm.\n    var order = [], m;\n    for (var i$7 = 0; i$7 < len;) {\n      if (countsAsLeft.test(types[i$7])) {\n        var start = i$7;\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n        order.push(new BidiSpan(0, start, i$7));\n      } else {\n        var pos = i$7, at = order.length;\n        for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n        for (var j$2 = pos; j$2 < i$7;) {\n          if (countsAsNum.test(types[j$2])) {\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n            var nstart = j$2;\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n            pos = j$2;\n          } else { ++j$2; }\n        }\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n      }\n    }\n    if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n      order[0].from = m[0].length;\n      order.unshift(new BidiSpan(0, 0, m[0].length));\n    }\n    if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n      lst(order).to -= m[0].length;\n      order.push(new BidiSpan(0, len - m[0].length, len));\n    }\n\n    return direction == \"rtl\" ? order.reverse() : order\n  }\n})();\n\n// Get the bidi ordering for the given line (and cache it). Returns\n// false for lines that are fully left-to-right, and an array of\n// BidiSpan objects otherwise.\nfunction getOrder(line, direction) {\n  var order = line.order;\n  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n  return order\n}\n\nfunction moveCharLogically(line, ch, dir) {\n  var target = skipExtendingChars(line.text, ch + dir, dir);\n  return target < 0 || target > line.text.length ? null : target\n}\n\nfunction moveLogically(line, start, dir) {\n  var ch = moveCharLogically(line, start.ch, dir);\n  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n}\n\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\n  if (visually) {\n    var order = getOrder(lineObj, cm.doc.direction);\n    if (order) {\n      var part = dir < 0 ? lst(order) : order[0];\n      var moveInStorageOrder = (dir < 0) == (part.level == 1);\n      var sticky = moveInStorageOrder ? \"after\" : \"before\";\n      var ch;\n      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n      // it could be that the last bidi part is not on the last visual line,\n      // since visual lines contain content order-consecutive chunks.\n      // Thus, in rtl, we are looking for the first (content-order) character\n      // in the rtl chunk that is on the last line (that is, the same line\n      // as the last (content-order) character).\n      if (part.level > 0) {\n        var prep = prepareMeasureForLine(cm, lineObj);\n        ch = dir < 0 ? lineObj.text.length - 1 : 0;\n        var targetTop = measureCharPrepared(cm, prep, ch).top;\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n        if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n      } else { ch = dir < 0 ? part.to : part.from; }\n      return new Pos(lineNo, ch, sticky)\n    }\n  }\n  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n}\n\nfunction moveVisually(cm, line, start, dir) {\n  var bidi = getOrder(line, cm.doc.direction);\n  if (!bidi) { return moveLogically(line, start, dir) }\n  if (start.ch >= line.text.length) {\n    start.ch = line.text.length;\n    start.sticky = \"before\";\n  } else if (start.ch <= 0) {\n    start.ch = 0;\n    start.sticky = \"after\";\n  }\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n  if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n    // nothing interesting happens.\n    return moveLogically(line, start, dir)\n  }\n\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n  var prep;\n  var getWrappedLineExtent = function (ch) {\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n    prep = prep || prepareMeasureForLine(cm, line);\n    return wrappedLineExtentChar(cm, line, prep, ch)\n  };\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n  if (cm.doc.direction == \"rtl\" || part.level == 1) {\n    var moveInStorageOrder = (part.level == 1) == (dir < 0);\n    var ch = mv(start, moveInStorageOrder ? 1 : -1);\n    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n      // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n      var sticky = moveInStorageOrder ? \"before\" : \"after\";\n      return new Pos(start.line, ch, sticky)\n    }\n  }\n\n  // Case 3: Could not move within this bidi part in this visual line, so leave\n  // the current bidi part\n\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n      ? new Pos(start.line, mv(ch, 1), \"before\")\n      : new Pos(start.line, ch, \"after\"); };\n\n    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n      var part = bidi[partPos];\n      var moveInStorageOrder = (dir > 0) == (part.level != 1);\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n    }\n  };\n\n  // Case 3a: Look for other bidi parts on the same visual line\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n  if (res) { return res }\n\n  // Case 3b: Look for other bidi parts on the next visual line\n  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n    if (res) { return res }\n  }\n\n  // Case 4: Nowhere to move\n  return null\n}\n\n// EVENT HANDLING\n\n// Lightweight event framework. on/off also work on DOM nodes,\n// registering native DOM handlers.\n\nvar noHandlers = [];\n\nvar on = function(emitter, type, f) {\n  if (emitter.addEventListener) {\n    emitter.addEventListener(type, f, false);\n  } else if (emitter.attachEvent) {\n    emitter.attachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers || (emitter._handlers = {});\n    map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n  }\n};\n\nfunction getHandlers(emitter, type) {\n  return emitter._handlers && emitter._handlers[type] || noHandlers\n}\n\nfunction off(emitter, type, f) {\n  if (emitter.removeEventListener) {\n    emitter.removeEventListener(type, f, false);\n  } else if (emitter.detachEvent) {\n    emitter.detachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\n    if (arr) {\n      var index = indexOf(arr, f);\n      if (index > -1)\n        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n    }\n  }\n}\n\nfunction signal(emitter, type /*, values...*/) {\n  var handlers = getHandlers(emitter, type);\n  if (!handlers.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2);\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n}\n\n// The DOM events that CodeMirror handles can be overridden by\n// registering a (non-DOM) handler on the editor for the event name,\n// and preventDefault-ing the event in that handler.\nfunction signalDOMEvent(cm, e, override) {\n  if (typeof e == \"string\")\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n  signal(cm, override || e.type, cm, e);\n  return e_defaultPrevented(e) || e.codemirrorIgnore\n}\n\nfunction signalCursorActivity(cm) {\n  var arr = cm._handlers && cm._handlers.cursorActivity;\n  if (!arr) { return }\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n    { set.push(arr[i]); } }\n}\n\nfunction hasHandler(emitter, type) {\n  return getHandlers(emitter, type).length > 0\n}\n\n// Add on and off methods to a constructor's prototype, to make\n// registering events on such objects more convenient.\nfunction eventMixin(ctor) {\n  ctor.prototype.on = function(type, f) {on(this, type, f);};\n  ctor.prototype.off = function(type, f) {off(this, type, f);};\n}\n\n// Due to the fact that we still support jurassic IE versions, some\n// compatibility wrappers are needed.\n\nfunction e_preventDefault(e) {\n  if (e.preventDefault) { e.preventDefault(); }\n  else { e.returnValue = false; }\n}\nfunction e_stopPropagation(e) {\n  if (e.stopPropagation) { e.stopPropagation(); }\n  else { e.cancelBubble = true; }\n}\nfunction e_defaultPrevented(e) {\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n}\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\nfunction e_target(e) {return e.target || e.srcElement}\nfunction e_button(e) {\n  var b = e.which;\n  if (b == null) {\n    if (e.button & 1) { b = 1; }\n    else if (e.button & 2) { b = 3; }\n    else if (e.button & 4) { b = 2; }\n  }\n  if (mac && e.ctrlKey && b == 1) { b = 3; }\n  return b\n}\n\n// Detect drag-and-drop\nvar dragAndDrop = function() {\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\n  // couldn't get it to work yet.\n  if (ie && ie_version < 9) { return false }\n  var div = elt('div');\n  return \"draggable\" in div || \"dragDrop\" in div\n}();\n\nvar zwspSupported;\nfunction zeroWidthElement(measure) {\n  if (zwspSupported == null) {\n    var test = elt(\"span\", \"\\u200b\");\n    removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n    if (measure.firstChild.offsetHeight != 0)\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n  }\n  var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n    elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  node.setAttribute(\"cm-text\", \"\");\n  return node\n}\n\n// Feature-detect IE's crummy client rect reporting for bidi text\nvar badBidiRects;\nfunction hasBadBidiRects(measure) {\n  if (badBidiRects != null) { return badBidiRects }\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n  var r0 = range(txt, 0, 1).getBoundingClientRect();\n  var r1 = range(txt, 1, 2).getBoundingClientRect();\n  removeChildren(measure);\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n  return badBidiRects = (r1.right - r0.right < 3)\n}\n\n// See if \"\".split is the broken IE version, if so, provide an\n// alternative way to split lines.\nvar splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n  var pos = 0, result = [], l = string.length;\n  while (pos <= l) {\n    var nl = string.indexOf(\"\\n\", pos);\n    if (nl == -1) { nl = string.length; }\n    var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n    var rt = line.indexOf(\"\\r\");\n    if (rt != -1) {\n      result.push(line.slice(0, rt));\n      pos += rt + 1;\n    } else {\n      result.push(line);\n      pos = nl + 1;\n    }\n  }\n  return result\n} : function (string) { return string.split(/\\r\\n?|\\n/); };\n\nvar hasSelection = window.getSelection ? function (te) {\n  try { return te.selectionStart != te.selectionEnd }\n  catch(e) { return false }\n} : function (te) {\n  var range$$1;\n  try {range$$1 = te.ownerDocument.selection.createRange();}\n  catch(e) {}\n  if (!range$$1 || range$$1.parentElement() != te) { return false }\n  return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n};\n\nvar hasCopyEvent = (function () {\n  var e = elt(\"div\");\n  if (\"oncopy\" in e) { return true }\n  e.setAttribute(\"oncopy\", \"return;\");\n  return typeof e.oncopy == \"function\"\n})();\n\nvar badZoomedRects = null;\nfunction hasBadZoomedRects(measure) {\n  if (badZoomedRects != null) { return badZoomedRects }\n  var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n  var normal = node.getBoundingClientRect();\n  var fromRange = range(node, 0, 1).getBoundingClientRect();\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n}\n\n// Known modes, by name and by MIME\nvar modes = {};\nvar mimeModes = {};\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nfunction defineMode(name, mode) {\n  if (arguments.length > 2)\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n  modes[name] = mode;\n}\n\nfunction defineMIME(mime, spec) {\n  mimeModes[mime] = spec;\n}\n\n// Given a MIME type, a {name, ...options} config object, or a name\n// string, return a mode config object.\nfunction resolveMode(spec) {\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n    spec = mimeModes[spec];\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n    var found = mimeModes[spec.name];\n    if (typeof found == \"string\") { found = {name: found}; }\n    spec = createObj(found, spec);\n    spec.name = found.name;\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n    return resolveMode(\"application/xml\")\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n    return resolveMode(\"application/json\")\n  }\n  if (typeof spec == \"string\") { return {name: spec} }\n  else { return spec || {name: \"null\"} }\n}\n\n// Given a mode spec (anything that resolveMode accepts), find and\n// initialize an actual mode object.\nfunction getMode(options, spec) {\n  spec = resolveMode(spec);\n  var mfactory = modes[spec.name];\n  if (!mfactory) { return getMode(options, \"text/plain\") }\n  var modeObj = mfactory(options, spec);\n  if (modeExtensions.hasOwnProperty(spec.name)) {\n    var exts = modeExtensions[spec.name];\n    for (var prop in exts) {\n      if (!exts.hasOwnProperty(prop)) { continue }\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n      modeObj[prop] = exts[prop];\n    }\n  }\n  modeObj.name = spec.name;\n  if (spec.helperType) { modeObj.helperType = spec.helperType; }\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n    { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n  return modeObj\n}\n\n// This can be used to attach properties to mode objects from\n// outside the actual mode definition.\nvar modeExtensions = {};\nfunction extendMode(mode, properties) {\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n  copyObj(properties, exts);\n}\n\nfunction copyState(mode, state) {\n  if (state === true) { return state }\n  if (mode.copyState) { return mode.copyState(state) }\n  var nstate = {};\n  for (var n in state) {\n    var val = state[n];\n    if (val instanceof Array) { val = val.concat([]); }\n    nstate[n] = val;\n  }\n  return nstate\n}\n\n// Given a mode and a state (for that mode), find the inner mode and\n// state at the position that the state refers to.\nfunction innerMode(mode, state) {\n  var info;\n  while (mode.innerMode) {\n    info = mode.innerMode(state);\n    if (!info || info.mode == mode) { break }\n    state = info.state;\n    mode = info.mode;\n  }\n  return info || {mode: mode, state: state}\n}\n\nfunction startState(mode, a1, a2) {\n  return mode.startState ? mode.startState(a1, a2) : true\n}\n\n// STRING STREAM\n\n// Fed to the mode parsers, provides helper functions to make\n// parsers more succinct.\n\nvar StringStream = function(string, tabSize) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n};\n\nStringStream.prototype.eol = function () {return this.pos >= this.string.length};\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\nStringStream.prototype.next = function () {\n  if (this.pos < this.string.length)\n    { return this.string.charAt(this.pos++) }\n};\nStringStream.prototype.eat = function (match) {\n  var ch = this.string.charAt(this.pos);\n  var ok;\n  if (typeof match == \"string\") { ok = ch == match; }\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n  if (ok) {++this.pos; return ch}\n};\nStringStream.prototype.eatWhile = function (match) {\n  var start = this.pos;\n  while (this.eat(match)){}\n  return this.pos > start\n};\nStringStream.prototype.eatSpace = function () {\n    var this$1 = this;\n\n  var start = this.pos;\n  while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n  return this.pos > start\n};\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\nStringStream.prototype.skipTo = function (ch) {\n  var found = this.string.indexOf(ch, this.pos);\n  if (found > -1) {this.pos = found; return true}\n};\nStringStream.prototype.backUp = function (n) {this.pos -= n;};\nStringStream.prototype.column = function () {\n  if (this.lastColumnPos < this.start) {\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n    this.lastColumnPos = this.start;\n  }\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.indentation = function () {\n  return countColumn(this.string, null, this.tabSize) -\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n  if (typeof pattern == \"string\") {\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n    var substr = this.string.substr(this.pos, pattern.length);\n    if (cased(substr) == cased(pattern)) {\n      if (consume !== false) { this.pos += pattern.length; }\n      return true\n    }\n  } else {\n    var match = this.string.slice(this.pos).match(pattern);\n    if (match && match.index > 0) { return null }\n    if (match && consume !== false) { this.pos += match[0].length; }\n    return match\n  }\n};\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\nStringStream.prototype.hideFirstChars = function (n, inner) {\n  this.lineStart += n;\n  try { return inner() }\n  finally { this.lineStart -= n; }\n};\n\n// Compute a style array (an array starting with a mode generation\n// -- for invalidation -- followed by pairs of end positions and\n// style strings), which is used to highlight the tokens on the\n// line.\nfunction highlightLine(cm, line, state, forceToEnd) {\n  // A styles array always starts with a number identifying the\n  // mode/overlays that it is based on (for easy invalidation).\n  var st = [cm.state.modeGen], lineClasses = {};\n  // Compute the base array of styles\n  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },\n    lineClasses, forceToEnd);\n\n  // Run overlays, adjust style array.\n  var loop = function ( o ) {\n    var overlay = cm.state.overlays[o], i = 1, at = 0;\n    runMode(cm, line.text, overlay.mode, true, function (end, style) {\n      var start = i;\n      // Ensure there's a token end at the current position, and that i points at it\n      while (at < end) {\n        var i_end = st[i];\n        if (i_end > end)\n          { st.splice(i, 1, end, st[i+1], i_end); }\n        i += 2;\n        at = Math.min(end, i_end);\n      }\n      if (!style) { return }\n      if (overlay.opaque) {\n        st.splice(start, i - start, end, \"overlay \" + style);\n        i = start + 2;\n      } else {\n        for (; start < i; start += 2) {\n          var cur = st[start+1];\n          st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n        }\n      }\n    }, lineClasses);\n  };\n\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n}\n\nfunction getLineStyles(cm, line, updateFrontier) {\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\n    var state = getStateBefore(cm, lineNo(line));\n    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n    line.stateAfter = state;\n    line.styles = result.styles;\n    if (result.classes) { line.styleClasses = result.classes; }\n    else if (line.styleClasses) { line.styleClasses = null; }\n    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++; }\n  }\n  return line.styles\n}\n\nfunction getStateBefore(cm, n, precise) {\n  var doc = cm.doc, display = cm.display;\n  if (!doc.mode.startState) { return true }\n  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n  if (!state) { state = startState(doc.mode); }\n  else { state = copyState(doc.mode, state); }\n  doc.iter(pos, n, function (line) {\n    processLine(cm, line.text, state);\n    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n    line.stateAfter = save ? copyState(doc.mode, state) : null;\n    ++pos;\n  });\n  if (precise) { doc.frontier = pos; }\n  return state\n}\n\n// Lightweight form of highlight -- proceed over this line and\n// update state, but don't save a style array. Used for lines that\n// aren't currently visible.\nfunction processLine(cm, text, state, startAt) {\n  var mode = cm.doc.mode;\n  var stream = new StringStream(text, cm.options.tabSize);\n  stream.start = stream.pos = startAt || 0;\n  if (text == \"\") { callBlankLine(mode, state); }\n  while (!stream.eol()) {\n    readToken(mode, stream, state);\n    stream.start = stream.pos;\n  }\n}\n\nfunction callBlankLine(mode, state) {\n  if (mode.blankLine) { return mode.blankLine(state) }\n  if (!mode.innerMode) { return }\n  var inner = innerMode(mode, state);\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n}\n\nfunction readToken(mode, stream, state, inner) {\n  for (var i = 0; i < 10; i++) {\n    if (inner) { inner[0] = innerMode(mode, state).mode; }\n    var style = mode.token(stream, state);\n    if (stream.pos > stream.start) { return style }\n  }\n  throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n}\n\n// Utility for getTokenAt and getLineTokens\nfunction takeToken(cm, pos, precise, asArray) {\n  var getObj = function (copy) { return ({\n    start: stream.start, end: stream.pos,\n    string: stream.current(),\n    type: style || null,\n    state: copy ? copyState(doc.mode, state) : state\n  }); };\n\n  var doc = cm.doc, mode = doc.mode, style;\n  pos = clipPos(doc, pos);\n  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n  var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n  if (asArray) { tokens = []; }\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n    stream.start = stream.pos;\n    style = readToken(mode, stream, state);\n    if (asArray) { tokens.push(getObj(true)); }\n  }\n  return asArray ? tokens : getObj()\n}\n\nfunction extractLineClasses(type, output) {\n  if (type) { for (;;) {\n    var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n    if (!lineClass) { break }\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n    var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n    if (output[prop] == null)\n      { output[prop] = lineClass[2]; }\n    else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n      { output[prop] += \" \" + lineClass[2]; }\n  } }\n  return type\n}\n\n// Run the given mode's parser over a line, calling f for each token.\nfunction runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n  var flattenSpans = mode.flattenSpans;\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n  var curStart = 0, curStyle = null;\n  var stream = new StringStream(text, cm.options.tabSize), style;\n  var inner = cm.options.addModeClass && [null];\n  if (text == \"\") { extractLineClasses(callBlankLine(mode, state), lineClasses); }\n  while (!stream.eol()) {\n    if (stream.pos > cm.options.maxHighlightLength) {\n      flattenSpans = false;\n      if (forceToEnd) { processLine(cm, text, state, stream.pos); }\n      stream.pos = text.length;\n      style = null;\n    } else {\n      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n    }\n    if (inner) {\n      var mName = inner[0].name;\n      if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n    }\n    if (!flattenSpans || curStyle != style) {\n      while (curStart < stream.start) {\n        curStart = Math.min(stream.start, curStart + 5000);\n        f(curStart, curStyle);\n      }\n      curStyle = style;\n    }\n    stream.start = stream.pos;\n  }\n  while (curStart < stream.pos) {\n    // Webkit seems to refuse to render text nodes longer than 57444\n    // characters, and returns inaccurate measurements in nodes\n    // starting around 5000 chars.\n    var pos = Math.min(stream.pos, curStart + 5000);\n    f(pos, curStyle);\n    curStart = pos;\n  }\n}\n\n// Finds the line to start with when starting a parse. Tries to\n// find a line with a stateAfter, so that it can start with a\n// valid state. If that fails, it returns the line with the\n// smallest indentation, which tends to need the least context to\n// parse correctly.\nfunction findStartLine(cm, n, precise) {\n  var minindent, minline, doc = cm.doc;\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n  for (var search = n; search > lim; --search) {\n    if (search <= doc.first) { return doc.first }\n    var line = getLine(doc, search - 1);\n    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }\n    var indented = countColumn(line.text, null, cm.options.tabSize);\n    if (minline == null || minindent > indented) {\n      minline = search - 1;\n      minindent = indented;\n    }\n  }\n  return minline\n}\n\n// LINE DATA STRUCTURE\n\n// Line objects. These hold state related to a line, including\n// highlighting info (the styles array).\nvar Line = function(text, markedSpans, estimateHeight) {\n  this.text = text;\n  attachMarkedSpans(this, markedSpans);\n  this.height = estimateHeight ? estimateHeight(this) : 1;\n};\n\nLine.prototype.lineNo = function () { return lineNo(this) };\neventMixin(Line);\n\n// Change the content (text, markers) of a line. Automatically\n// invalidates cached information and tries to re-estimate the\n// line's height.\nfunction updateLine(line, text, markedSpans, estimateHeight) {\n  line.text = text;\n  if (line.stateAfter) { line.stateAfter = null; }\n  if (line.styles) { line.styles = null; }\n  if (line.order != null) { line.order = null; }\n  detachMarkedSpans(line);\n  attachMarkedSpans(line, markedSpans);\n  var estHeight = estimateHeight ? estimateHeight(line) : 1;\n  if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n}\n\n// Detach a line from the document tree and its markers.\nfunction cleanUpLine(line) {\n  line.parent = null;\n  detachMarkedSpans(line);\n}\n\n// Convert a style as returned by a mode (either null, or a string\n// containing one or more styles) to a CSS style. This is cached,\n// and also looks for line-wide styles.\nvar styleToClassCache = {};\nvar styleToClassCacheWithMode = {};\nfunction interpretTokenStyle(style, options) {\n  if (!style || /^\\s*$/.test(style)) { return null }\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n  return cache[style] ||\n    (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n}\n\n// Render the DOM representation of the text of a line. Also builds\n// up a 'line map', which points at the DOM nodes that represent\n// specific stretches of text, and is used by the measuring code.\n// The returned object contains the DOM node, this map, and\n// information about line-wide styles that were set by the mode.\nfunction buildLineContent(cm, lineView) {\n  // The padding-right forces the element to have a 'border', which\n  // is needed on Webkit to be able to get line-level bounding\n  // rectangles for it (in measureChar).\n  var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n  var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                 col: 0, pos: 0, cm: cm,\n                 trailingSpace: false,\n                 splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n  lineView.measure = {};\n\n  // Iterate over the logical lines that make up this visual line.\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n    builder.pos = 0;\n    builder.addToken = buildToken;\n    // Optionally wire in some hacks into the token-rendering\n    // algorithm, to deal with browser quirks.\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n    builder.map = [];\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n    if (line.styleClasses) {\n      if (line.styleClasses.bgClass)\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n      if (line.styleClasses.textClass)\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n    }\n\n    // Ensure at least a single node is present, for measuring.\n    if (builder.map.length == 0)\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n    // Store the map and a cache object for the current logical line\n    if (i == 0) {\n      lineView.measure.map = builder.map;\n      lineView.measure.cache = {};\n    } else {\n      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n    }\n  }\n\n  // See issue #2901\n  if (webkit) {\n    var last = builder.content.lastChild;\n    if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n      { builder.content.className = \"cm-tab-wrap-hack\"; }\n  }\n\n  signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n  if (builder.pre.className)\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n  return builder\n}\n\nfunction defaultSpecialCharPlaceholder(ch) {\n  var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n  token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n  token.setAttribute(\"aria-label\", token.title);\n  return token\n}\n\n// Build up the DOM representation for a single token, and add it to\n// the line map. Takes care to render special characters separately.\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\n  if (!text) { return }\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n  var special = builder.cm.state.specialChars, mustWrap = false;\n  var content;\n  if (!special.test(text)) {\n    builder.col += text.length;\n    content = document.createTextNode(displayText);\n    builder.map.push(builder.pos, builder.pos + text.length, content);\n    if (ie && ie_version < 9) { mustWrap = true; }\n    builder.pos += text.length;\n  } else {\n    content = document.createDocumentFragment();\n    var pos = 0;\n    while (true) {\n      special.lastIndex = pos;\n      var m = special.exec(text);\n      var skipped = m ? m.index - pos : text.length - pos;\n      if (skipped) {\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n        else { content.appendChild(txt); }\n        builder.map.push(builder.pos, builder.pos + skipped, txt);\n        builder.col += skipped;\n        builder.pos += skipped;\n      }\n      if (!m) { break }\n      pos += skipped + 1;\n      var txt$1 = (void 0);\n      if (m[0] == \"\\t\") {\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n        txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n        txt$1.setAttribute(\"role\", \"presentation\");\n        txt$1.setAttribute(\"cm-text\", \"\\t\");\n        builder.col += tabWidth;\n      } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n        txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        builder.col += 1;\n      } else {\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n        else { content.appendChild(txt$1); }\n        builder.col += 1;\n      }\n      builder.map.push(builder.pos, builder.pos + 1, txt$1);\n      builder.pos++;\n    }\n  }\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n  if (style || startStyle || endStyle || mustWrap || css) {\n    var fullStyle = style || \"\";\n    if (startStyle) { fullStyle += startStyle; }\n    if (endStyle) { fullStyle += endStyle; }\n    var token = elt(\"span\", [content], fullStyle, css);\n    if (title) { token.title = title; }\n    return builder.content.appendChild(token)\n  }\n  builder.content.appendChild(content);\n}\n\nfunction splitSpaces(text, trailingBefore) {\n  if (text.length > 1 && !/  /.test(text)) { return text }\n  var spaceBefore = trailingBefore, result = \"\";\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n    if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n      { ch = \"\\u00a0\"; }\n    result += ch;\n    spaceBefore = ch == \" \";\n  }\n  return result\n}\n\n// Work around nonsense dimensions being reported for stretches of\n// right-to-left text.\nfunction buildTokenBadBidi(inner, order) {\n  return function (builder, text, style, startStyle, endStyle, title, css) {\n    style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n    var start = builder.pos, end = start + text.length;\n    for (;;) {\n      // Find the part that overlaps with the start of this text\n      var part = (void 0);\n      for (var i = 0; i < order.length; i++) {\n        part = order[i];\n        if (part.to > start && part.from <= start) { break }\n      }\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n      startStyle = null;\n      text = text.slice(part.to - start);\n      start = part.to;\n    }\n  }\n}\n\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n  var widget = !ignoreWidget && marker.widgetNode;\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n    if (!widget)\n      { widget = builder.content.appendChild(document.createElement(\"span\")); }\n    widget.setAttribute(\"cm-marker\", marker.id);\n  }\n  if (widget) {\n    builder.cm.display.input.setUneditable(widget);\n    builder.content.appendChild(widget);\n  }\n  builder.pos += size;\n  builder.trailingSpace = false;\n}\n\n// Outputs a number of spans to make up a line, taking highlighting\n// and marked text into account.\nfunction insertLineContent(line, builder, styles) {\n  var spans = line.markedSpans, allText = line.text, at = 0;\n  if (!spans) {\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n    return\n  }\n\n  var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n  for (;;) {\n    if (nextChange == pos) { // Update current marker set\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n      collapsed = null; nextChange = Infinity;\n      var foundBookmarks = [], endStyles = (void 0);\n      for (var j = 0; j < spans.length; ++j) {\n        var sp = spans[j], m = sp.marker;\n        if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n          foundBookmarks.push(m);\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n            nextChange = sp.to;\n            spanEndStyle = \"\";\n          }\n          if (m.className) { spanStyle += \" \" + m.className; }\n          if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n          if (m.title && !title) { title = m.title; }\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n            { collapsed = sp; }\n        } else if (sp.from > pos && nextChange > sp.from) {\n          nextChange = sp.from;\n        }\n      }\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n      if (collapsed && (collapsed.from || 0) == pos) {\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                           collapsed.marker, collapsed.from == null);\n        if (collapsed.to == null) { return }\n        if (collapsed.to == pos) { collapsed = false; }\n      }\n    }\n    if (pos >= len) { break }\n\n    var upto = Math.min(len, nextChange);\n    while (true) {\n      if (text) {\n        var end = pos + text.length;\n        if (!collapsed) {\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n        }\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n        pos = end;\n        spanStartStyle = \"\";\n      }\n      text = allText.slice(at, at = styles[i++]);\n      style = interpretTokenStyle(styles[i++], builder.cm.options);\n    }\n  }\n}\n\n\n// These objects are used to represent the visible (currently drawn)\n// part of the document. A LineView may correspond to multiple\n// logical lines, if those are connected by collapsed ranges.\nfunction LineView(doc, line, lineN) {\n  // The starting line\n  this.line = line;\n  // Continuing lines, if any\n  this.rest = visualLineContinued(line);\n  // Number of logical lines in this visual line\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n  this.node = this.text = null;\n  this.hidden = lineIsHidden(doc, line);\n}\n\n// Create a range of LineView objects for the given lines.\nfunction buildViewArray(cm, from, to) {\n  var array = [], nextPos;\n  for (var pos = from; pos < to; pos = nextPos) {\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n    nextPos = pos + view.size;\n    array.push(view);\n  }\n  return array\n}\n\nvar operationGroup = null;\n\nfunction pushOperation(op) {\n  if (operationGroup) {\n    operationGroup.ops.push(op);\n  } else {\n    op.ownsGroup = operationGroup = {\n      ops: [op],\n      delayedCallbacks: []\n    };\n  }\n}\n\nfunction fireCallbacksForOps(group) {\n  // Calls delayed callbacks and cursorActivity handlers until no\n  // new ones appear\n  var callbacks = group.delayedCallbacks, i = 0;\n  do {\n    for (; i < callbacks.length; i++)\n      { callbacks[i].call(null); }\n    for (var j = 0; j < group.ops.length; j++) {\n      var op = group.ops[j];\n      if (op.cursorActivityHandlers)\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n    }\n  } while (i < callbacks.length)\n}\n\nfunction finishOperation(op, endCb) {\n  var group = op.ownsGroup;\n  if (!group) { return }\n\n  try { fireCallbacksForOps(group); }\n  finally {\n    operationGroup = null;\n    endCb(group);\n  }\n}\n\nvar orphanDelayedCallbacks = null;\n\n// Often, we want to signal events at a point where we are in the\n// middle of some work, but don't want the handler to start calling\n// other methods on the editor, which might be in an inconsistent\n// state or simply not expect any other events to happen.\n// signalLater looks whether there are any handlers, and schedules\n// them to be executed when the last operation ends, or, if no\n// operation is active, when a timeout fires.\nfunction signalLater(emitter, type /*, values...*/) {\n  var arr = getHandlers(emitter, type);\n  if (!arr.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2), list;\n  if (operationGroup) {\n    list = operationGroup.delayedCallbacks;\n  } else if (orphanDelayedCallbacks) {\n    list = orphanDelayedCallbacks;\n  } else {\n    list = orphanDelayedCallbacks = [];\n    setTimeout(fireOrphanDelayed, 0);\n  }\n  var loop = function ( i ) {\n    list.push(function () { return arr[i].apply(null, args); });\n  };\n\n  for (var i = 0; i < arr.length; ++i)\n    loop( i );\n}\n\nfunction fireOrphanDelayed() {\n  var delayed = orphanDelayedCallbacks;\n  orphanDelayedCallbacks = null;\n  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n}\n\n// When an aspect of a line changes, a string is added to\n// lineView.changes. This updates the relevant part of the line's\n// DOM structure.\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\n  for (var j = 0; j < lineView.changes.length; j++) {\n    var type = lineView.changes[j];\n    if (type == \"text\") { updateLineText(cm, lineView); }\n    else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n    else if (type == \"class\") { updateLineClasses(cm, lineView); }\n    else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n  }\n  lineView.changes = null;\n}\n\n// Lines with gutter elements, widgets or a background class need to\n// be wrapped, and have the extra elements added to the wrapper div\nfunction ensureLineWrapped(lineView) {\n  if (lineView.node == lineView.text) {\n    lineView.node = elt(\"div\", null, null, \"position: relative\");\n    if (lineView.text.parentNode)\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n    lineView.node.appendChild(lineView.text);\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n  }\n  return lineView.node\n}\n\nfunction updateLineBackground(cm, lineView) {\n  var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n  if (cls) { cls += \" CodeMirror-linebackground\"; }\n  if (lineView.background) {\n    if (cls) { lineView.background.className = cls; }\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n  } else if (cls) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    cm.display.input.setUneditable(lineView.background);\n  }\n}\n\n// Wrapper around buildLineContent which will reuse the structure\n// in display.externalMeasured when possible.\nfunction getLineContent(cm, lineView) {\n  var ext = cm.display.externalMeasured;\n  if (ext && ext.line == lineView.line) {\n    cm.display.externalMeasured = null;\n    lineView.measure = ext.measure;\n    return ext.built\n  }\n  return buildLineContent(cm, lineView)\n}\n\n// Redraw the line's text. Interacts with the background and text\n// classes because the mode may output tokens that influence these\n// classes.\nfunction updateLineText(cm, lineView) {\n  var cls = lineView.text.className;\n  var built = getLineContent(cm, lineView);\n  if (lineView.text == lineView.node) { lineView.node = built.pre; }\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n  lineView.text = built.pre;\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n    lineView.bgClass = built.bgClass;\n    lineView.textClass = built.textClass;\n    updateLineClasses(cm, lineView);\n  } else if (cls) {\n    lineView.text.className = cls;\n  }\n}\n\nfunction updateLineClasses(cm, lineView) {\n  updateLineBackground(cm, lineView);\n  if (lineView.line.wrapClass)\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n  else if (lineView.node != lineView.text)\n    { lineView.node.className = \"\"; }\n  var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n  lineView.text.className = textClass || \"\";\n}\n\nfunction updateLineGutter(cm, lineView, lineN, dims) {\n  if (lineView.gutter) {\n    lineView.node.removeChild(lineView.gutter);\n    lineView.gutter = null;\n  }\n  if (lineView.gutterBackground) {\n    lineView.node.removeChild(lineView.gutterBackground);\n    lineView.gutterBackground = null;\n  }\n  if (lineView.line.gutterClass) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                    (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(lineView.gutterBackground);\n    wrap.insertBefore(lineView.gutterBackground, lineView.text);\n  }\n  var markers = lineView.line.gutterMarkers;\n  if (cm.options.lineNumbers || markers) {\n    var wrap$1 = ensureLineWrapped(lineView);\n    var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(gutterWrap);\n    wrap$1.insertBefore(gutterWrap, lineView.text);\n    if (lineView.line.gutterClass)\n      { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n    if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n      { lineView.lineNumber = gutterWrap.appendChild(\n        elt(\"div\", lineNumberFor(cm.options, lineN),\n            \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n            (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n      if (found)\n        { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                   (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n    } }\n  }\n}\n\nfunction updateLineWidgets(cm, lineView, dims) {\n  if (lineView.alignable) { lineView.alignable = null; }\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n    next = node.nextSibling;\n    if (node.className == \"CodeMirror-linewidget\")\n      { lineView.node.removeChild(node); }\n  }\n  insertLineWidgets(cm, lineView, dims);\n}\n\n// Build a line's DOM representation from scratch\nfunction buildLineElement(cm, lineView, lineN, dims) {\n  var built = getLineContent(cm, lineView);\n  lineView.text = lineView.node = built.pre;\n  if (built.bgClass) { lineView.bgClass = built.bgClass; }\n  if (built.textClass) { lineView.textClass = built.textClass; }\n\n  updateLineClasses(cm, lineView);\n  updateLineGutter(cm, lineView, lineN, dims);\n  insertLineWidgets(cm, lineView, dims);\n  return lineView.node\n}\n\n// A lineView may contain multiple logical lines (when merged by\n// collapsed spans). The widgets for all of them need to be drawn.\nfunction insertLineWidgets(cm, lineView, dims) {\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n}\n\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n  if (!line.widgets) { return }\n  var wrap = ensureLineWrapped(lineView);\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n    var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n    if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n    positionLineWidget(widget, node, lineView, dims);\n    cm.display.input.setUneditable(node);\n    if (allowAbove && widget.above)\n      { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n    else\n      { wrap.appendChild(node); }\n    signalLater(widget, \"redraw\");\n  }\n}\n\nfunction positionLineWidget(widget, node, lineView, dims) {\n  if (widget.noHScroll) {\n    (lineView.alignable || (lineView.alignable = [])).push(node);\n    var width = dims.wrapperWidth;\n    node.style.left = dims.fixedPos + \"px\";\n    if (!widget.coverGutter) {\n      width -= dims.gutterTotalWidth;\n      node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n    }\n    node.style.width = width + \"px\";\n  }\n  if (widget.coverGutter) {\n    node.style.zIndex = 5;\n    node.style.position = \"relative\";\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n  }\n}\n\nfunction widgetHeight(widget) {\n  if (widget.height != null) { return widget.height }\n  var cm = widget.doc.cm;\n  if (!cm) { return 0 }\n  if (!contains(document.body, widget.node)) {\n    var parentStyle = \"position: relative;\";\n    if (widget.coverGutter)\n      { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n    if (widget.noHScroll)\n      { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n    removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n  }\n  return widget.height = widget.node.parentNode.offsetHeight\n}\n\n// Return true when the given mouse event happened in a widget\nfunction eventInWidget(display, e) {\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n    if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n        (n.parentNode == display.sizer && n != display.mover))\n      { return true }\n  }\n}\n\n// POSITION MEASUREMENT\n\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\nfunction paddingH(display) {\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\n  var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n  return data\n}\n\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\nfunction displayWidth(cm) {\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n}\nfunction displayHeight(cm) {\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n}\n\n// Ensure the lineView.wrapping.heights array is populated. This is\n// an array of bottom offsets for the lines that make up a drawn\n// line. When lineWrapping is on, there might be more than one\n// height.\nfunction ensureLineHeights(cm, lineView, rect) {\n  var wrapping = cm.options.lineWrapping;\n  var curWidth = wrapping && displayWidth(cm);\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n    var heights = lineView.measure.heights = [];\n    if (wrapping) {\n      lineView.measure.width = curWidth;\n      var rects = lineView.text.firstChild.getClientRects();\n      for (var i = 0; i < rects.length - 1; i++) {\n        var cur = rects[i], next = rects[i + 1];\n        if (Math.abs(cur.bottom - next.bottom) > 2)\n          { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n      }\n    }\n    heights.push(rect.bottom - rect.top);\n  }\n}\n\n// Find a line map (mapping character offsets to text nodes) and a\n// measurement cache for the given line number. (A line view might\n// contain multiple lines when collapsed ranges are present.)\nfunction mapFromLineView(lineView, line, lineN) {\n  if (lineView.line == line)\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n  for (var i = 0; i < lineView.rest.length; i++)\n    { if (lineView.rest[i] == line)\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n    { if (lineNo(lineView.rest[i$1]) > lineN)\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n}\n\n// Render a line into the hidden node display.externalMeasured. Used\n// when measurement is needed for a line that's not in the viewport.\nfunction updateExternalMeasurement(cm, line) {\n  line = visualLine(line);\n  var lineN = lineNo(line);\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n  view.lineN = lineN;\n  var built = view.built = buildLineContent(cm, view);\n  view.text = built.pre;\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n  return view\n}\n\n// Get a {top, bottom, left, right} box (in line-local coordinates)\n// for a given character.\nfunction measureChar(cm, line, ch, bias) {\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n}\n\n// Find a line view that corresponds to the given line number.\nfunction findViewForLine(cm, lineN) {\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n    { return cm.display.view[findViewIndex(cm, lineN)] }\n  var ext = cm.display.externalMeasured;\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n    { return ext }\n}\n\n// Measurement can be split in two steps, the set-up work that\n// applies to the whole line, and the measurement of the actual\n// character. Functions like coordsChar, that need to do a lot of\n// measurements in a row, can thus ensure that the set-up work is\n// only done once.\nfunction prepareMeasureForLine(cm, line) {\n  var lineN = lineNo(line);\n  var view = findViewForLine(cm, lineN);\n  if (view && !view.text) {\n    view = null;\n  } else if (view && view.changes) {\n    updateLineForChanges(cm, view, lineN, getDimensions(cm));\n    cm.curOp.forceUpdate = true;\n  }\n  if (!view)\n    { view = updateExternalMeasurement(cm, line); }\n\n  var info = mapFromLineView(view, line, lineN);\n  return {\n    line: line, view: view, rect: null,\n    map: info.map, cache: info.cache, before: info.before,\n    hasHeights: false\n  }\n}\n\n// Given a prepared measurement object, measures the position of an\n// actual character (or fetches it from the cache).\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n  if (prepared.before) { ch = -1; }\n  var key = ch + (bias || \"\"), found;\n  if (prepared.cache.hasOwnProperty(key)) {\n    found = prepared.cache[key];\n  } else {\n    if (!prepared.rect)\n      { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n    if (!prepared.hasHeights) {\n      ensureLineHeights(cm, prepared.view, prepared.rect);\n      prepared.hasHeights = true;\n    }\n    found = measureCharInner(cm, prepared, ch, bias);\n    if (!found.bogus) { prepared.cache[key] = found; }\n  }\n  return {left: found.left, right: found.right,\n          top: varHeight ? found.rtop : found.top,\n          bottom: varHeight ? found.rbottom : found.bottom}\n}\n\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\nfunction nodeAndOffsetInLineMap(map$$1, ch, bias) {\n  var node, start, end, collapse, mStart, mEnd;\n  // First, search the line map for the text node corresponding to,\n  // or closest to, the target character.\n  for (var i = 0; i < map$$1.length; i += 3) {\n    mStart = map$$1[i];\n    mEnd = map$$1[i + 1];\n    if (ch < mStart) {\n      start = 0; end = 1;\n      collapse = \"left\";\n    } else if (ch < mEnd) {\n      start = ch - mStart;\n      end = start + 1;\n    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n      end = mEnd - mStart;\n      start = end - 1;\n      if (ch >= mEnd) { collapse = \"right\"; }\n    }\n    if (start != null) {\n      node = map$$1[i + 2];\n      if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n        { collapse = bias; }\n      if (bias == \"left\" && start == 0)\n        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n          node = map$$1[(i -= 3) + 2];\n          collapse = \"left\";\n        } }\n      if (bias == \"right\" && start == mEnd - mStart)\n        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n          node = map$$1[(i += 3) + 2];\n          collapse = \"right\";\n        } }\n      break\n    }\n  }\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n}\n\nfunction getUsefulRect(rects, bias) {\n  var rect = nullRect;\n  if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n    if ((rect = rects[i]).left != rect.right) { break }\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n    if ((rect = rects[i$1]).left != rect.right) { break }\n  } }\n  return rect\n}\n\nfunction measureCharInner(cm, prepared, ch, bias) {\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n  var rect;\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n        { rect = node.parentNode.getBoundingClientRect(); }\n      else\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n      if (rect.left || rect.right || start == 0) { break }\n      end = start;\n      start = start - 1;\n      collapse = \"right\";\n    }\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n  } else { // If it is a widget, simply get the box for the whole widget.\n    if (start > 0) { collapse = bias = \"right\"; }\n    var rects;\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n      { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n    else\n      { rect = node.getBoundingClientRect(); }\n  }\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n    var rSpan = node.parentNode.getClientRects()[0];\n    if (rSpan)\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n    else\n      { rect = nullRect; }\n  }\n\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n  var mid = (rtop + rbot) / 2;\n  var heights = prepared.view.measure.heights;\n  var i = 0;\n  for (; i < heights.length - 1; i++)\n    { if (mid < heights[i]) { break } }\n  var top = i ? heights[i - 1] : 0, bot = heights[i];\n  var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                top: top, bottom: bot};\n  if (!rect.left && !rect.right) { result.bogus = true; }\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n  return result\n}\n\n// Work around problem with bounding client rects on ranges being\n// returned incorrectly when zoomed on IE10 and below.\nfunction maybeUpdateRectForZooming(measure, rect) {\n  if (!window.screen || screen.logicalXDPI == null ||\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n    { return rect }\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n}\n\nfunction clearLineMeasurementCacheFor(lineView) {\n  if (lineView.measure) {\n    lineView.measure.cache = {};\n    lineView.measure.heights = null;\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { lineView.measure.caches[i] = {}; } }\n  }\n}\n\nfunction clearLineMeasurementCache(cm) {\n  cm.display.externalMeasure = null;\n  removeChildren(cm.display.lineMeasure);\n  for (var i = 0; i < cm.display.view.length; i++)\n    { clearLineMeasurementCacheFor(cm.display.view[i]); }\n}\n\nfunction clearCaches(cm) {\n  clearLineMeasurementCache(cm);\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n  cm.display.lineNumChars = null;\n}\n\nfunction pageScrollX() {\n  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n  // which causes page_Offset and bounding client rects to use\n  // different reference viewports and invalidate our calculations.\n  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n  return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n}\nfunction pageScrollY() {\n  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n  return window.pageYOffset || (document.documentElement || document.body).scrollTop\n}\n\n// Converts a {top, bottom, left, right} box from line-local\n// coordinates into another coordinate system. Context may be one of\n// \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n// or \"page\".\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {\n    var size = widgetHeight(lineObj.widgets[i]);\n    rect.top += size; rect.bottom += size;\n  } } }\n  if (context == \"line\") { return rect }\n  if (!context) { context = \"local\"; }\n  var yOff = heightAtLine(lineObj);\n  if (context == \"local\") { yOff += paddingTop(cm.display); }\n  else { yOff -= cm.display.viewOffset; }\n  if (context == \"page\" || context == \"window\") {\n    var lOff = cm.display.lineSpace.getBoundingClientRect();\n    yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n    var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n    rect.left += xOff; rect.right += xOff;\n  }\n  rect.top += yOff; rect.bottom += yOff;\n  return rect\n}\n\n// Coverts a box from \"div\" coords to another coordinate system.\n// Context may be \"window\", \"page\", \"div\", or \"local\"./null.\nfunction fromCoordSystem(cm, coords, context) {\n  if (context == \"div\") { return coords }\n  var left = coords.left, top = coords.top;\n  // First move into \"page\" coordinate system\n  if (context == \"page\") {\n    left -= pageScrollX();\n    top -= pageScrollY();\n  } else if (context == \"local\" || !context) {\n    var localBox = cm.display.sizer.getBoundingClientRect();\n    left += localBox.left;\n    top += localBox.top;\n  }\n\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n}\n\nfunction charCoords(cm, pos, context, lineObj, bias) {\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n}\n\n// Returns a box for a given cursor position, which may have an\n// 'other' property containing the position of the secondary cursor\n// on a bidi boundary.\n// A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n// and after `char - 1` in writing order of `char - 1`\n// A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n// and before `char` in writing order of `char`\n// Examples (upper-case letters are RTL, lower-case are LTR):\n//     Pos(0, 1, ...)\n//     before   after\n// ab     a|b     a|b\n// aB     a|B     aB|\n// Ab     |Ab     A|b\n// AB     B|A     B|A\n// Every position after the last character on a line is considered to stick\n// to the last character on the line.\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n  lineObj = lineObj || getLine(cm.doc, pos.line);\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n  function get(ch, right) {\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n    if (right) { m.left = m.right; } else { m.right = m.left; }\n    return intoCoordSystem(cm, lineObj, m, context)\n  }\n  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n  if (ch >= lineObj.text.length) {\n    ch = lineObj.text.length;\n    sticky = \"before\";\n  } else if (ch <= 0) {\n    ch = 0;\n    sticky = \"after\";\n  }\n  if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n  function getBidi(ch, partPos, invert) {\n    var part = order[partPos], right = (part.level % 2) != 0;\n    return get(invert ? ch - 1 : ch, right != invert)\n  }\n  var partPos = getBidiPartAt(order, ch, sticky);\n  var other = bidiOther;\n  var val = getBidi(ch, partPos, sticky == \"before\");\n  if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n  return val\n}\n\n// Used to cheaply estimate the coordinates for a position. Used for\n// intermediate scroll updates.\nfunction estimateCoords(cm, pos) {\n  var left = 0;\n  pos = clipPos(cm.doc, pos);\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n  var lineObj = getLine(cm.doc, pos.line);\n  var top = heightAtLine(lineObj) + paddingTop(cm.display);\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\n}\n\n// Positions returned by coordsChar contain some extra information.\n// xRel is the relative x position of the input coordinates compared\n// to the found position (so xRel > 0 means the coordinates are to\n// the right of the character position, for example). When outside\n// is true, that means the coordinates lie outside the line's\n// vertical range.\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\n  var pos = Pos(line, ch, sticky);\n  pos.xRel = xRel;\n  if (outside) { pos.outside = true; }\n  return pos\n}\n\n// Compute the character position closest to the given coordinates.\n// Input must be lineSpace-local (\"div\" coordinate system).\nfunction coordsChar(cm, x, y) {\n  var doc = cm.doc;\n  y += cm.display.viewOffset;\n  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n  if (lineN > last)\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\n  if (x < 0) { x = 0; }\n\n  var lineObj = getLine(doc, lineN);\n  for (;;) {\n    var found = coordsCharInner(cm, lineObj, lineN, x, y);\n    var merged = collapsedSpanAtEnd(lineObj);\n    var mergedPos = merged && merged.find(0, true);\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n      { lineN = lineNo(lineObj = mergedPos.to.line); }\n    else\n      { return found }\n  }\n}\n\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n  var measure = function (ch) { return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \"line\"); };\n  var end = lineObj.text.length;\n  var begin = findFirst(function (ch) { return measure(ch - 1).bottom <= y; }, end, 0);\n  end = findFirst(function (ch) { return measure(ch).top > y; }, begin, end);\n  return {begin: begin, end: end}\n}\n\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n}\n\nfunction coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n  y -= heightAtLine(lineObj);\n  var begin = 0, end = lineObj.text.length;\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n  var pos;\n  var order = getOrder(lineObj, cm.doc.direction);\n  if (order) {\n    if (cm.options.lineWrapping) {\n      var assign;\n      ((assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, end = assign.end, assign));\n    }\n    pos = new Pos(lineNo$$1, begin);\n    var beginLeft = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure).left;\n    var dir = beginLeft < x ? 1 : -1;\n    var prevDiff, diff = beginLeft - x, prevPos;\n    do {\n      prevDiff = diff;\n      prevPos = pos;\n      pos = moveVisually(cm, lineObj, pos, dir);\n      if (pos == null || pos.ch < begin || end <= (pos.sticky == \"before\" ? pos.ch - 1 : pos.ch)) {\n        pos = prevPos;\n        break\n      }\n      diff = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure).left - x;\n    } while ((dir < 0) != (diff < 0) && (Math.abs(diff) <= Math.abs(prevDiff)))\n    if (Math.abs(diff) > Math.abs(prevDiff)) {\n      if ((diff < 0) == (prevDiff < 0)) { throw new Error(\"Broke out of infinite loop in coordsCharInner\") }\n      pos = prevPos;\n    }\n  } else {\n    var ch = findFirst(function (ch) {\n      var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \"line\");\n      if (box.top > y) {\n        // For the cursor stickiness\n        end = Math.min(ch, end);\n        return true\n      }\n      else if (box.bottom <= y) { return false }\n      else if (box.left > x) { return true }\n      else if (box.right < x) { return false }\n      else { return (x - box.left < box.right - x) }\n    }, begin, end);\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    pos = new Pos(lineNo$$1, ch, ch == end ? \"before\" : \"after\");\n  }\n  var coords = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure);\n  if (y < coords.top || coords.bottom < y) { pos.outside = true; }\n  pos.xRel = x < coords.left ? -1 : (x > coords.right ? 1 : 0);\n  return pos\n}\n\nvar measureText;\n// Compute the default text height.\nfunction textHeight(display) {\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n  if (measureText == null) {\n    measureText = elt(\"pre\");\n    // Measure a bunch of lines, for browsers that compute\n    // fractional heights.\n    for (var i = 0; i < 49; ++i) {\n      measureText.appendChild(document.createTextNode(\"x\"));\n      measureText.appendChild(elt(\"br\"));\n    }\n    measureText.appendChild(document.createTextNode(\"x\"));\n  }\n  removeChildrenAndAdd(display.measure, measureText);\n  var height = measureText.offsetHeight / 50;\n  if (height > 3) { display.cachedTextHeight = height; }\n  removeChildren(display.measure);\n  return height || 1\n}\n\n// Compute the default character width.\nfunction charWidth(display) {\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n  var anchor = elt(\"span\", \"xxxxxxxxxx\");\n  var pre = elt(\"pre\", [anchor]);\n  removeChildrenAndAdd(display.measure, pre);\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n  if (width > 2) { display.cachedCharWidth = width; }\n  return width || 10\n}\n\n// Do a bulk-read of the DOM positions and sizes needed to draw the\n// view, so that we don't interleave reading and writing to the DOM.\nfunction getDimensions(cm) {\n  var d = cm.display, left = {}, width = {};\n  var gutterLeft = d.gutters.clientLeft;\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n    width[cm.options.gutters[i]] = n.clientWidth;\n  }\n  return {fixedPos: compensateForHScroll(d),\n          gutterTotalWidth: d.gutters.offsetWidth,\n          gutterLeft: left,\n          gutterWidth: width,\n          wrapperWidth: d.wrapper.clientWidth}\n}\n\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n// but using getBoundingClientRect to get a sub-pixel-accurate\n// result.\nfunction compensateForHScroll(display) {\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n}\n\n// Returns a function that estimates the height of a line, to use as\n// first approximation until the line becomes visible (and is thus\n// properly measurable).\nfunction estimateHeight(cm) {\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n  return function (line) {\n    if (lineIsHidden(cm.doc, line)) { return 0 }\n\n    var widgetsHeight = 0;\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n    } }\n\n    if (wrapping)\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n    else\n      { return widgetsHeight + th }\n  }\n}\n\nfunction estimateLineHeights(cm) {\n  var doc = cm.doc, est = estimateHeight(cm);\n  doc.iter(function (line) {\n    var estHeight = est(line);\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  });\n}\n\n// Given a mouse event, find the corresponding position. If liberal\n// is false, it checks whether a gutter or scrollbar was clicked,\n// and returns null if it was. forRect is used by rectangular\n// selections, and tries to estimate a character position even for\n// coordinates beyond the right of the text.\nfunction posFromMouse(cm, e, liberal, forRect) {\n  var display = cm.display;\n  if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n  var x, y, space = display.lineSpace.getBoundingClientRect();\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n  try { x = e.clientX - space.left; y = e.clientY - space.top; }\n  catch (e) { return null }\n  var coords = coordsChar(cm, x, y), line;\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n  }\n  return coords\n}\n\n// Find the view element corresponding to a given line. Return null\n// when the line isn't visible.\nfunction findViewIndex(cm, n) {\n  if (n >= cm.display.viewTo) { return null }\n  n -= cm.display.viewFrom;\n  if (n < 0) { return null }\n  var view = cm.display.view;\n  for (var i = 0; i < view.length; i++) {\n    n -= view[i].size;\n    if (n < 0) { return i }\n  }\n}\n\nfunction updateSelection(cm) {\n  cm.display.input.showSelection(cm.display.input.prepareSelection());\n}\n\nfunction prepareSelection(cm, primary) {\n  var doc = cm.doc, result = {};\n  var curFragment = result.cursors = document.createDocumentFragment();\n  var selFragment = result.selection = document.createDocumentFragment();\n\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    if (primary === false && i == doc.sel.primIndex) { continue }\n    var range$$1 = doc.sel.ranges[i];\n    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\n    var collapsed = range$$1.empty();\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      { drawSelectionCursor(cm, range$$1.head, curFragment); }\n    if (!collapsed)\n      { drawSelectionRange(cm, range$$1, selFragment); }\n  }\n  return result\n}\n\n// Draws a cursor for the given range\nfunction drawSelectionCursor(cm, head, output) {\n  var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n  var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n  cursor.style.left = pos.left + \"px\";\n  cursor.style.top = pos.top + \"px\";\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n  if (pos.other) {\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n    otherCursor.style.display = \"\";\n    otherCursor.style.left = pos.other.left + \"px\";\n    otherCursor.style.top = pos.other.top + \"px\";\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n  }\n}\n\n// Draws the given range as a highlighted selection\nfunction drawSelectionRange(cm, range$$1, output) {\n  var display = cm.display, doc = cm.doc;\n  var fragment = document.createDocumentFragment();\n  var padding = paddingH(cm.display), leftSide = padding.left;\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\n  function add(left, top, width, bottom) {\n    if (top < 0) { top = 0; }\n    top = Math.round(top);\n    bottom = Math.round(bottom);\n    fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n  }\n\n  function drawForLine(line, fromArg, toArg) {\n    var lineObj = getLine(doc, line);\n    var lineLen = lineObj.text.length;\n    var start, end;\n    function coords(ch, bias) {\n      return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n    }\n\n    iterateBidiSections(getOrder(lineObj, doc.direction), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {\n      var leftPos = coords(from, \"left\"), rightPos, left, right;\n      if (from == to) {\n        rightPos = leftPos;\n        left = right = leftPos.left;\n      } else {\n        rightPos = coords(to - 1, \"right\");\n        if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n        left = leftPos.left;\n        right = rightPos.right;\n      }\n      if (fromArg == null && from == 0) { left = leftSide; }\n      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n        add(left, leftPos.top, null, leftPos.bottom);\n        left = leftSide;\n        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top); }\n      }\n      if (toArg == null && to == lineLen) { right = rightSide; }\n      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n        { start = leftPos; }\n      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n        { end = rightPos; }\n      if (left < leftSide + 1) { left = leftSide; }\n      add(left, rightPos.top, right - left, rightPos.bottom);\n    });\n    return {start: start, end: end}\n  }\n\n  var sFrom = range$$1.from(), sTo = range$$1.to();\n  if (sFrom.line == sTo.line) {\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n  } else {\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n    var singleVLine = visualLine(fromLine) == visualLine(toLine);\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n    if (singleVLine) {\n      if (leftEnd.top < rightStart.top - 2) {\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n      } else {\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n      }\n    }\n    if (leftEnd.bottom < rightStart.top)\n      { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n  }\n\n  output.appendChild(fragment);\n}\n\n// Cursor-blinking\nfunction restartBlink(cm) {\n  if (!cm.state.focused) { return }\n  var display = cm.display;\n  clearInterval(display.blinker);\n  var on = true;\n  display.cursorDiv.style.visibility = \"\";\n  if (cm.options.cursorBlinkRate > 0)\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n      cm.options.cursorBlinkRate); }\n  else if (cm.options.cursorBlinkRate < 0)\n    { display.cursorDiv.style.visibility = \"hidden\"; }\n}\n\nfunction ensureFocus(cm) {\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n}\n\nfunction delayBlurEvent(cm) {\n  cm.state.delayingBlurEvent = true;\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\n    cm.state.delayingBlurEvent = false;\n    onBlur(cm);\n  } }, 100);\n}\n\nfunction onFocus(cm, e) {\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n  if (cm.options.readOnly == \"nocursor\") { return }\n  if (!cm.state.focused) {\n    signal(cm, \"focus\", cm, e);\n    cm.state.focused = true;\n    addClass(cm.display.wrapper, \"CodeMirror-focused\");\n    // This test prevents this from firing when a context\n    // menu is closed (since the input reset would kill the\n    // select-all detection hack)\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n      cm.display.input.reset();\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n    }\n    cm.display.input.receivedFocus();\n  }\n  restartBlink(cm);\n}\nfunction onBlur(cm, e) {\n  if (cm.state.delayingBlurEvent) { return }\n\n  if (cm.state.focused) {\n    signal(cm, \"blur\", cm, e);\n    cm.state.focused = false;\n    rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n  }\n  clearInterval(cm.display.blinker);\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n}\n\n// Read the actual heights of the rendered lines, and update their\n// stored heights to match.\nfunction updateHeightsInViewport(cm) {\n  var display = cm.display;\n  var prevBottom = display.lineDiv.offsetTop;\n  for (var i = 0; i < display.view.length; i++) {\n    var cur = display.view[i], height = (void 0);\n    if (cur.hidden) { continue }\n    if (ie && ie_version < 8) {\n      var bot = cur.node.offsetTop + cur.node.offsetHeight;\n      height = bot - prevBottom;\n      prevBottom = bot;\n    } else {\n      var box = cur.node.getBoundingClientRect();\n      height = box.bottom - box.top;\n    }\n    var diff = cur.line.height - height;\n    if (height < 2) { height = textHeight(display); }\n    if (diff > .001 || diff < -.001) {\n      updateLineHeight(cur.line, height);\n      updateWidgetHeight(cur.line);\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n        { updateWidgetHeight(cur.rest[j]); } }\n    }\n  }\n}\n\n// Read and store the height of line widgets associated with the\n// given line.\nfunction updateWidgetHeight(line) {\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)\n    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }\n}\n\n// Compute the lines that are visible in a given viewport (defaults\n// the the current scroll position). viewport may contain top,\n// height, and ensure (see op.scrollToPos) properties.\nfunction visibleLines(display, doc, viewport) {\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n  top = Math.floor(top - paddingTop(display));\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n  // forces those lines into the viewport (if possible).\n  if (viewport && viewport.ensure) {\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n    if (ensureFrom < from) {\n      from = ensureFrom;\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n      to = ensureTo;\n    }\n  }\n  return {from: from, to: Math.max(to, from + 1)}\n}\n\n// Re-align line numbers and gutter marks to compensate for\n// horizontal scrolling.\nfunction alignHorizontally(cm) {\n  var display = cm.display, view = display.view;\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n  var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n    if (cm.options.fixedGutter) {\n      if (view[i].gutter)\n        { view[i].gutter.style.left = left; }\n      if (view[i].gutterBackground)\n        { view[i].gutterBackground.style.left = left; }\n    }\n    var align = view[i].alignable;\n    if (align) { for (var j = 0; j < align.length; j++)\n      { align[j].style.left = left; } }\n  } }\n  if (cm.options.fixedGutter)\n    { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n}\n\n// Used to ensure that the line number gutter is still the right\n// size for the current document size. Returns true when an update\n// is needed.\nfunction maybeUpdateLineNumberWidth(cm) {\n  if (!cm.options.lineNumbers) { return false }\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n  if (last.length != display.lineNumChars) {\n    var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                               \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n    display.lineGutter.style.width = \"\";\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n    display.lineNumWidth = display.lineNumInnerWidth + padding;\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n    display.lineGutter.style.width = display.lineNumWidth + \"px\";\n    updateGutterSpace(cm);\n    return true\n  }\n  return false\n}\n\n// SCROLLING THINGS INTO VIEW\n\n// If an editor sits on the top or bottom of the window, partially\n// scrolled out of view, this ensures that the cursor is visible.\nfunction maybeScrollWindow(cm, rect) {\n  if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n  if (rect.top + box.top < 0) { doScroll = true; }\n  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n  if (doScroll != null && !phantom) {\n    var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n    cm.display.lineSpace.appendChild(scrollNode);\n    scrollNode.scrollIntoView(doScroll);\n    cm.display.lineSpace.removeChild(scrollNode);\n  }\n}\n\n// Scroll a given position into view (immediately), verifying that\n// it actually became visible (as line heights are accurately\n// measured, the position of something may 'drift' during drawing).\nfunction scrollPosIntoView(cm, pos, end, margin) {\n  if (margin == null) { margin = 0; }\n  var rect;\n  for (var limit = 0; limit < 5; limit++) {\n    var changed = false;\n    var coords = cursorCoords(cm, pos);\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n    rect = {left: Math.min(coords.left, endCoords.left),\n            top: Math.min(coords.top, endCoords.top) - margin,\n            right: Math.max(coords.left, endCoords.left),\n            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n    var scrollPos = calculateScrollPos(cm, rect);\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n    if (scrollPos.scrollTop != null) {\n      updateScrollTop(cm, scrollPos.scrollTop);\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n    }\n    if (scrollPos.scrollLeft != null) {\n      setScrollLeft(cm, scrollPos.scrollLeft);\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n    }\n    if (!changed) { break }\n  }\n  return rect\n}\n\n// Scroll a given set of coordinates into view (immediately).\nfunction scrollIntoView(cm, rect) {\n  var scrollPos = calculateScrollPos(cm, rect);\n  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n}\n\n// Calculate a new scroll position needed to scroll the given\n// rectangle into view. Returns an object with scrollTop and\n// scrollLeft properties. When these are undefined, the\n// vertical/horizontal position does not need to be adjusted.\nfunction calculateScrollPos(cm, rect) {\n  var display = cm.display, snapMargin = textHeight(cm.display);\n  if (rect.top < 0) { rect.top = 0; }\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n  var screen = displayHeight(cm), result = {};\n  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n  var docBottom = cm.doc.height + paddingVert(display);\n  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n  if (rect.top < screentop) {\n    result.scrollTop = atTop ? 0 : rect.top;\n  } else if (rect.bottom > screentop + screen) {\n    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n    if (newTop != screentop) { result.scrollTop = newTop; }\n  }\n\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n  var tooWide = rect.right - rect.left > screenw;\n  if (tooWide) { rect.right = rect.left + screenw; }\n  if (rect.left < 10)\n    { result.scrollLeft = 0; }\n  else if (rect.left < screenleft)\n    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n  else if (rect.right > screenw + screenleft - 3)\n    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n  return result\n}\n\n// Store a relative adjustment to the scroll position in the current\n// operation (to be applied when the operation finishes).\nfunction addToScrollTop(cm, top) {\n  if (top == null) { return }\n  resolveScrollToPos(cm);\n  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n}\n\n// Make sure that at the end of the operation the current cursor is\n// shown.\nfunction ensureCursorVisible(cm) {\n  resolveScrollToPos(cm);\n  var cur = cm.getCursor(), from = cur, to = cur;\n  if (!cm.options.lineWrapping) {\n    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n    to = Pos(cur.line, cur.ch + 1);\n  }\n  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin};\n}\n\nfunction scrollToCoords(cm, x, y) {\n  if (x != null || y != null) { resolveScrollToPos(cm); }\n  if (x != null) { cm.curOp.scrollLeft = x; }\n  if (y != null) { cm.curOp.scrollTop = y; }\n}\n\nfunction scrollToRange(cm, range$$1) {\n  resolveScrollToPos(cm);\n  cm.curOp.scrollToPos = range$$1;\n}\n\n// When an operation has its scrollToPos property set, and another\n// scroll action is applied before the end of the operation, this\n// 'simulates' scrolling that position into view in a cheap way, so\n// that the effect of intermediate scroll commands is not ignored.\nfunction resolveScrollToPos(cm) {\n  var range$$1 = cm.curOp.scrollToPos;\n  if (range$$1) {\n    cm.curOp.scrollToPos = null;\n    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n    scrollToCoordsRange(cm, from, to, range$$1.margin);\n  }\n}\n\nfunction scrollToCoordsRange(cm, from, to, margin) {\n  var sPos = calculateScrollPos(cm, {\n    left: Math.min(from.left, to.left),\n    top: Math.min(from.top, to.top) - margin,\n    right: Math.max(from.right, to.right),\n    bottom: Math.max(from.bottom, to.bottom) + margin\n  });\n  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n}\n\n// Sync the scrollable area and scrollbars, ensure the viewport\n// covers the visible area.\nfunction updateScrollTop(cm, val) {\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n  if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n  setScrollTop(cm, val, true);\n  if (gecko) { updateDisplaySimple(cm); }\n  startWorker(cm, 100);\n}\n\nfunction setScrollTop(cm, val, forceScroll) {\n  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n  cm.doc.scrollTop = val;\n  cm.display.scrollbars.setScrollTop(val);\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n}\n\n// Sync scroller and scrollbar, ensure the gutter elements are\n// aligned.\nfunction setScrollLeft(cm, val, isScroller, forceScroll) {\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n  cm.doc.scrollLeft = val;\n  alignHorizontally(cm);\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n  cm.display.scrollbars.setScrollLeft(val);\n}\n\n// SCROLLBARS\n\n// Prepare DOM reads needed to update the scrollbars. Done in one\n// shot to minimize update/measure roundtrips.\nfunction measureForScrollbars(cm) {\n  var d = cm.display, gutterW = d.gutters.offsetWidth;\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n  return {\n    clientHeight: d.scroller.clientHeight,\n    viewHeight: d.wrapper.clientHeight,\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n    viewWidth: d.wrapper.clientWidth,\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\n    docHeight: docH,\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\n    nativeBarWidth: d.nativeBarWidth,\n    gutterWidth: gutterW\n  }\n}\n\nvar NativeScrollbars = function(place, scroll, cm) {\n  this.cm = cm;\n  var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n  var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n  place(vert); place(horiz);\n\n  on(vert, \"scroll\", function () {\n    if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n  });\n  on(horiz, \"scroll\", function () {\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n  });\n\n  this.checkedZeroWidth = false;\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n};\n\nNativeScrollbars.prototype.update = function (measure) {\n  var needsH = measure.scrollWidth > measure.clientWidth + 1;\n  var needsV = measure.scrollHeight > measure.clientHeight + 1;\n  var sWidth = measure.nativeBarWidth;\n\n  if (needsV) {\n    this.vert.style.display = \"block\";\n    this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n    // A bug in IE8 can cause this value to be negative, so guard it.\n    this.vert.firstChild.style.height =\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n  } else {\n    this.vert.style.display = \"\";\n    this.vert.firstChild.style.height = \"0\";\n  }\n\n  if (needsH) {\n    this.horiz.style.display = \"block\";\n    this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n    this.horiz.style.left = measure.barLeft + \"px\";\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n    this.horiz.firstChild.style.width =\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n  } else {\n    this.horiz.style.display = \"\";\n    this.horiz.firstChild.style.width = \"0\";\n  }\n\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n    if (sWidth == 0) { this.zeroWidthHack(); }\n    this.checkedZeroWidth = true;\n  }\n\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n};\n\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n};\n\nNativeScrollbars.prototype.setScrollTop = function (pos) {\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n};\n\nNativeScrollbars.prototype.zeroWidthHack = function () {\n  var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n  this.horiz.style.height = this.vert.style.width = w;\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n  this.disableHoriz = new Delayed;\n  this.disableVert = new Delayed;\n};\n\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n  bar.style.pointerEvents = \"auto\";\n  function maybeDisable() {\n    // To find out whether the scrollbar is still visible, we\n    // check whether the element under the pixel in the bottom\n    // right corner of the scrollbar box is the scrollbar box\n    // itself (when the bar is still visible) or its filler child\n    // (when the bar is hidden). If it is still visible, we keep\n    // it enabled, if it's hidden, we disable pointer events.\n    var box = bar.getBoundingClientRect();\n    var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n    if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n    else { delay.set(1000, maybeDisable); }\n  }\n  delay.set(1000, maybeDisable);\n};\n\nNativeScrollbars.prototype.clear = function () {\n  var parent = this.horiz.parentNode;\n  parent.removeChild(this.horiz);\n  parent.removeChild(this.vert);\n};\n\nvar NullScrollbars = function () {};\n\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\nNullScrollbars.prototype.setScrollLeft = function () {};\nNullScrollbars.prototype.setScrollTop = function () {};\nNullScrollbars.prototype.clear = function () {};\n\nfunction updateScrollbars(cm, measure) {\n  if (!measure) { measure = measureForScrollbars(cm); }\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n  updateScrollbarsInner(cm, measure);\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n      { updateHeightsInViewport(cm); }\n    updateScrollbarsInner(cm, measureForScrollbars(cm));\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n  }\n}\n\n// Re-synchronize the fake scrollbars with the actual size of the\n// content.\nfunction updateScrollbarsInner(cm, measure) {\n  var d = cm.display;\n  var sizes = d.scrollbars.update(measure);\n\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n  d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n  if (sizes.right && sizes.bottom) {\n    d.scrollbarFiller.style.display = \"block\";\n    d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n    d.scrollbarFiller.style.width = sizes.right + \"px\";\n  } else { d.scrollbarFiller.style.display = \"\"; }\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n    d.gutterFiller.style.display = \"block\";\n    d.gutterFiller.style.height = sizes.bottom + \"px\";\n    d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n  } else { d.gutterFiller.style.display = \"\"; }\n}\n\nvar scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\nfunction initScrollbars(cm) {\n  if (cm.display.scrollbars) {\n    cm.display.scrollbars.clear();\n    if (cm.display.scrollbars.addClass)\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n    // Prevent clicks in the scrollbars from killing focus\n    on(node, \"mousedown\", function () {\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n    });\n    node.setAttribute(\"cm-not-content\", \"true\");\n  }, function (pos, axis) {\n    if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n    else { updateScrollTop(cm, pos); }\n  }, cm);\n  if (cm.display.scrollbars.addClass)\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n}\n\n// Operations are used to wrap a series of changes to the editor\n// state in such a way that each change won't have to update the\n// cursor and display (which would be awkward, slow, and\n// error-prone). Instead, display updates are batched and then all\n// combined and executed at once.\n\nvar nextOpId = 0;\n// Start a new operation.\nfunction startOperation(cm) {\n  cm.curOp = {\n    cm: cm,\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\n    forceUpdate: false,      // Used to force a redraw\n    updateInput: null,       // Whether to reset the input textarea\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n    changeObjs: null,        // Accumulated changes, for firing change events\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n    selectionChanged: false, // Whether the selection needs to be redrawn\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n    scrollToPos: null,       // Used to scroll to a specific position\n    focus: false,\n    id: ++nextOpId           // Unique ID\n  };\n  pushOperation(cm.curOp);\n}\n\n// Finish an operation, updating the display and signalling delayed events\nfunction endOperation(cm) {\n  var op = cm.curOp;\n  finishOperation(op, function (group) {\n    for (var i = 0; i < group.ops.length; i++)\n      { group.ops[i].cm.curOp = null; }\n    endOperations(group);\n  });\n}\n\n// The DOM updates done when an operation finishes are batched so\n// that the minimum number of relayouts are required.\nfunction endOperations(group) {\n  var ops = group.ops;\n  for (var i = 0; i < ops.length; i++) // Read DOM\n    { endOperation_R1(ops[i]); }\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n    { endOperation_W1(ops[i$1]); }\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n    { endOperation_R2(ops[i$2]); }\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n    { endOperation_W2(ops[i$3]); }\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n    { endOperation_finish(ops[i$4]); }\n}\n\nfunction endOperation_R1(op) {\n  var cm = op.cm, display = cm.display;\n  maybeClipScrollbars(cm);\n  if (op.updateMaxLine) { findMaxLine(cm); }\n\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                       op.scrollToPos.to.line >= display.viewTo) ||\n    display.maxLineChanged && cm.options.lineWrapping;\n  op.update = op.mustUpdate &&\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n}\n\nfunction endOperation_W1(op) {\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n}\n\nfunction endOperation_R2(op) {\n  var cm = op.cm, display = cm.display;\n  if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n  op.barMeasure = measureForScrollbars(cm);\n\n  // If the max line changed since it was last measured, measure it,\n  // and ensure the document's width matches it.\n  // updateDisplay_W2 will use these properties to do the actual resizing\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n    cm.display.sizerWidth = op.adjustWidthTo;\n    op.barMeasure.scrollWidth =\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n  }\n\n  if (op.updatedDisplay || op.selectionChanged)\n    { op.preparedSelection = display.input.prepareSelection(op.focus); }\n}\n\nfunction endOperation_W2(op) {\n  var cm = op.cm;\n\n  if (op.adjustWidthTo != null) {\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n    cm.display.maxLineChanged = false;\n  }\n\n  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());\n  if (op.preparedSelection)\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\n    { updateScrollbars(cm, op.barMeasure); }\n  if (op.updatedDisplay)\n    { setDocumentHeight(cm, op.barMeasure); }\n\n  if (op.selectionChanged) { restartBlink(cm); }\n\n  if (cm.state.focused && op.updateInput)\n    { cm.display.input.reset(op.typing); }\n  if (takeFocus) { ensureFocus(op.cm); }\n}\n\nfunction endOperation_finish(op) {\n  var cm = op.cm, display = cm.display, doc = cm.doc;\n\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n  // Abort mouse wheel delta measurement, when scrolling explicitly\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n    { display.wheelStartX = display.wheelStartY = null; }\n\n  // Propagate the scroll position to the actual DOM scroller\n  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n  // If we need to scroll a specific position into view, do so.\n  if (op.scrollToPos) {\n    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n    maybeScrollWindow(cm, rect);\n  }\n\n  // Fire events for markers that are hidden/unidden by editing or\n  // undoing\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\n    { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n  if (display.wrapper.offsetHeight)\n    { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n  // Fire change events, and delayed event handlers\n  if (op.changeObjs)\n    { signal(cm, \"changes\", cm, op.changeObjs); }\n  if (op.update)\n    { op.update.finish(); }\n}\n\n// Run the given function in an operation\nfunction runInOp(cm, f) {\n  if (cm.curOp) { return f() }\n  startOperation(cm);\n  try { return f() }\n  finally { endOperation(cm); }\n}\n// Wraps a function in an operation. Returns the wrapped function.\nfunction operation(cm, f) {\n  return function() {\n    if (cm.curOp) { return f.apply(cm, arguments) }\n    startOperation(cm);\n    try { return f.apply(cm, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n// Used to add methods to editor and doc instances, wrapping them in\n// operations.\nfunction methodOp(f) {\n  return function() {\n    if (this.curOp) { return f.apply(this, arguments) }\n    startOperation(this);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(this); }\n  }\n}\nfunction docMethodOp(f) {\n  return function() {\n    var cm = this.cm;\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\n    startOperation(cm);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n\n// Updates the display.view data structure for a given change to the\n// document. From and to are in pre-change coordinates. Lendiff is\n// the amount of lines added or subtracted by the change. This is\n// used for changes that span multiple lines, or change the way\n// lines are divided into visual lines. regLineChange (below)\n// registers single-line changes.\nfunction regChange(cm, from, to, lendiff) {\n  if (from == null) { from = cm.doc.first; }\n  if (to == null) { to = cm.doc.first + cm.doc.size; }\n  if (!lendiff) { lendiff = 0; }\n\n  var display = cm.display;\n  if (lendiff && to < display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\n    { display.updateLineNumbers = from; }\n\n  cm.curOp.viewChanged = true;\n\n  if (from >= display.viewTo) { // Change after\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n      { resetView(cm); }\n  } else if (to <= display.viewFrom) { // Change before\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n      resetView(cm);\n    } else {\n      display.viewFrom += lendiff;\n      display.viewTo += lendiff;\n    }\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n    resetView(cm);\n  } else if (from <= display.viewFrom) { // Top overlap\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cut) {\n      display.view = display.view.slice(cut.index);\n      display.viewFrom = cut.lineN;\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  } else if (to >= display.viewTo) { // Bottom overlap\n    var cut$1 = viewCuttingPoint(cm, from, from, -1);\n    if (cut$1) {\n      display.view = display.view.slice(0, cut$1.index);\n      display.viewTo = cut$1.lineN;\n    } else {\n      resetView(cm);\n    }\n  } else { // Gap in the middle\n    var cutTop = viewCuttingPoint(cm, from, from, -1);\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cutTop && cutBot) {\n      display.view = display.view.slice(0, cutTop.index)\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n        .concat(display.view.slice(cutBot.index));\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  }\n\n  var ext = display.externalMeasured;\n  if (ext) {\n    if (to < ext.lineN)\n      { ext.lineN += lendiff; }\n    else if (from < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n  }\n}\n\n// Register a change to a single line. Type must be one of \"text\",\n// \"gutter\", \"class\", \"widget\"\nfunction regLineChange(cm, line, type) {\n  cm.curOp.viewChanged = true;\n  var display = cm.display, ext = cm.display.externalMeasured;\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n    { display.externalMeasured = null; }\n\n  if (line < display.viewFrom || line >= display.viewTo) { return }\n  var lineView = display.view[findViewIndex(cm, line)];\n  if (lineView.node == null) { return }\n  var arr = lineView.changes || (lineView.changes = []);\n  if (indexOf(arr, type) == -1) { arr.push(type); }\n}\n\n// Clear the view.\nfunction resetView(cm) {\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n  cm.display.view = [];\n  cm.display.viewOffset = 0;\n}\n\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n    { return {index: index, lineN: newN} }\n  var n = cm.display.viewFrom;\n  for (var i = 0; i < index; i++)\n    { n += view[i].size; }\n  if (n != oldN) {\n    if (dir > 0) {\n      if (index == view.length - 1) { return null }\n      diff = (n + view[index].size) - oldN;\n      index++;\n    } else {\n      diff = n - oldN;\n    }\n    oldN += diff; newN += diff;\n  }\n  while (visualLineNo(cm.doc, newN) != newN) {\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n    index += dir;\n  }\n  return {index: index, lineN: newN}\n}\n\n// Force the view to cover a given range, adding empty view element\n// or clipping off existing ones as needed.\nfunction adjustView(cm, from, to) {\n  var display = cm.display, view = display.view;\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n    display.view = buildViewArray(cm, from, to);\n    display.viewFrom = from;\n  } else {\n    if (display.viewFrom > from)\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n    else if (display.viewFrom < from)\n      { display.view = display.view.slice(findViewIndex(cm, from)); }\n    display.viewFrom = from;\n    if (display.viewTo < to)\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n    else if (display.viewTo > to)\n      { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n  }\n  display.viewTo = to;\n}\n\n// Count the number of lines in the view whose DOM representation is\n// out of date (or nonexistent).\nfunction countDirtyView(cm) {\n  var view = cm.display.view, dirty = 0;\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n  }\n  return dirty\n}\n\n// HIGHLIGHT WORKER\n\nfunction startWorker(cm, time) {\n  if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n}\n\nfunction highlightWorker(cm) {\n  var doc = cm.doc;\n  if (doc.frontier < doc.first) { doc.frontier = doc.first; }\n  if (doc.frontier >= cm.display.viewTo) { return }\n  var end = +new Date + cm.options.workTime;\n  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n  var changedLines = [];\n\n  doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n    if (doc.frontier >= cm.display.viewFrom) { // Visible\n      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n      line.styles = highlighted.styles;\n      var oldCls = line.styleClasses, newCls = highlighted.classes;\n      if (newCls) { line.styleClasses = newCls; }\n      else if (oldCls) { line.styleClasses = null; }\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n      if (ischange) { changedLines.push(doc.frontier); }\n      line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n    } else {\n      if (line.text.length <= cm.options.maxHighlightLength)\n        { processLine(cm, line.text, state); }\n      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n    }\n    ++doc.frontier;\n    if (+new Date > end) {\n      startWorker(cm, cm.options.workDelay);\n      return true\n    }\n  });\n  if (changedLines.length) { runInOp(cm, function () {\n    for (var i = 0; i < changedLines.length; i++)\n      { regLineChange(cm, changedLines[i], \"text\"); }\n  }); }\n}\n\n// DISPLAY DRAWING\n\nvar DisplayUpdate = function(cm, viewport, force) {\n  var display = cm.display;\n\n  this.viewport = viewport;\n  // Store some values that we'll need later (but don't want to force a relayout for)\n  this.visible = visibleLines(display, cm.doc, viewport);\n  this.editorIsHidden = !display.wrapper.offsetWidth;\n  this.wrapperHeight = display.wrapper.clientHeight;\n  this.wrapperWidth = display.wrapper.clientWidth;\n  this.oldDisplayWidth = displayWidth(cm);\n  this.force = force;\n  this.dims = getDimensions(cm);\n  this.events = [];\n};\n\nDisplayUpdate.prototype.signal = function (emitter, type) {\n  if (hasHandler(emitter, type))\n    { this.events.push(arguments); }\n};\nDisplayUpdate.prototype.finish = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.events.length; i++)\n    { signal.apply(null, this$1.events[i]); }\n};\n\nfunction maybeClipScrollbars(cm) {\n  var display = cm.display;\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n    display.heightForcer.style.height = scrollGap(cm) + \"px\";\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n    display.scrollbarsClipped = true;\n  }\n}\n\nfunction selectionSnapshot(cm) {\n  if (cm.hasFocus()) { return null }\n  var active = activeElt();\n  if (!active || !contains(cm.display.lineDiv, active)) { return null }\n  var result = {activeElt: active};\n  if (window.getSelection) {\n    var sel = window.getSelection();\n    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n      result.anchorNode = sel.anchorNode;\n      result.anchorOffset = sel.anchorOffset;\n      result.focusNode = sel.focusNode;\n      result.focusOffset = sel.focusOffset;\n    }\n  }\n  return result\n}\n\nfunction restoreSelection(snapshot) {\n  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n  snapshot.activeElt.focus();\n  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n    var sel = window.getSelection(), range$$1 = document.createRange();\n    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n    range$$1.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range$$1);\n    sel.extend(snapshot.focusNode, snapshot.focusOffset);\n  }\n}\n\n// Does the actual updating of the line display. Bails out\n// (returning false) when there is nothing to be done and forced is\n// false.\nfunction updateDisplayIfNeeded(cm, update) {\n  var display = cm.display, doc = cm.doc;\n\n  if (update.editorIsHidden) {\n    resetView(cm);\n    return false\n  }\n\n  // Bail out if the visible area is already rendered and nothing changed.\n  if (!update.force &&\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n      display.renderedView == display.view && countDirtyView(cm) == 0)\n    { return false }\n\n  if (maybeUpdateLineNumberWidth(cm)) {\n    resetView(cm);\n    update.dims = getDimensions(cm);\n  }\n\n  // Compute a suitable new viewport (from & to)\n  var end = doc.first + doc.size;\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n  if (sawCollapsedSpans) {\n    from = visualLineNo(cm.doc, from);\n    to = visualLineEndNo(cm.doc, to);\n  }\n\n  var different = from != display.viewFrom || to != display.viewTo ||\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n  adjustView(cm, from, to);\n\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n  // Position the mover div to align with the current scroll position\n  cm.display.mover.style.top = display.viewOffset + \"px\";\n\n  var toUpdate = countDirtyView(cm);\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n    { return false }\n\n  // For big changes, we hide the enclosing element during the\n  // update, since that speeds up the operations on most browsers.\n  var selSnapshot = selectionSnapshot(cm);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n  patchDisplay(cm, display.updateLineNumbers, update.dims);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n  display.renderedView = display.view;\n  // There might have been a widget with a focused element that got\n  // hidden or updated, if so re-focus it.\n  restoreSelection(selSnapshot);\n\n  // Prevent selection and cursors from interfering with the scroll\n  // width and height.\n  removeChildren(display.cursorDiv);\n  removeChildren(display.selectionDiv);\n  display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n  if (different) {\n    display.lastWrapHeight = update.wrapperHeight;\n    display.lastWrapWidth = update.wrapperWidth;\n    startWorker(cm, 400);\n  }\n\n  display.updateLineNumbers = null;\n\n  return true\n}\n\nfunction postUpdateDisplay(cm, update) {\n  var viewport = update.viewport;\n\n  for (var first = true;; first = false) {\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n      // Clip forced viewport to actual scrollable area.\n      if (viewport && viewport.top != null)\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n      // Updated line heights might result in the drawn area not\n      // actually covering the viewport. Keep looping until it does.\n      update.visible = visibleLines(cm.display, cm.doc, viewport);\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n        { break }\n    }\n    if (!updateDisplayIfNeeded(cm, update)) { break }\n    updateHeightsInViewport(cm);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n  }\n\n  update.signal(cm, \"update\", cm);\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n    update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n  }\n}\n\nfunction updateDisplaySimple(cm, viewport) {\n  var update = new DisplayUpdate(cm, viewport);\n  if (updateDisplayIfNeeded(cm, update)) {\n    updateHeightsInViewport(cm);\n    postUpdateDisplay(cm, update);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.finish();\n  }\n}\n\n// Sync the actual display DOM structure with display.view, removing\n// nodes for lines that are no longer in view, and creating the ones\n// that are not there yet, and updating the ones that are out of\n// date.\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\n  var display = cm.display, lineNumbers = cm.options.lineNumbers;\n  var container = display.lineDiv, cur = container.firstChild;\n\n  function rm(node) {\n    var next = node.nextSibling;\n    // Works around a throw-scroll bug in OS X Webkit\n    if (webkit && mac && cm.display.currentWheelTarget == node)\n      { node.style.display = \"none\"; }\n    else\n      { node.parentNode.removeChild(node); }\n    return next\n  }\n\n  var view = display.view, lineN = display.viewFrom;\n  // Loop over the elements in the view, syncing cur (the DOM nodes\n  // in display.lineDiv) with the view as we go.\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (lineView.hidden) {\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n      var node = buildLineElement(cm, lineView, lineN, dims);\n      container.insertBefore(node, cur);\n    } else { // Already drawn\n      while (cur != lineView.node) { cur = rm(cur); }\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\n        updateNumbersFrom <= lineN && lineView.lineNumber;\n      if (lineView.changes) {\n        if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n        updateLineForChanges(cm, lineView, lineN, dims);\n      }\n      if (updateNumber) {\n        removeChildren(lineView.lineNumber);\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n      }\n      cur = lineView.node.nextSibling;\n    }\n    lineN += lineView.size;\n  }\n  while (cur) { cur = rm(cur); }\n}\n\nfunction updateGutterSpace(cm) {\n  var width = cm.display.gutters.offsetWidth;\n  cm.display.sizer.style.marginLeft = width + \"px\";\n}\n\nfunction setDocumentHeight(cm, measure) {\n  cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n  cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n}\n\n// Rebuild the gutter elements, ensure the margin to the left of the\n// code matches their width.\nfunction updateGutters(cm) {\n  var gutters = cm.display.gutters, specs = cm.options.gutters;\n  removeChildren(gutters);\n  var i = 0;\n  for (; i < specs.length; ++i) {\n    var gutterClass = specs[i];\n    var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n    if (gutterClass == \"CodeMirror-linenumbers\") {\n      cm.display.lineGutter = gElt;\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n    }\n  }\n  gutters.style.display = i ? \"\" : \"none\";\n  updateGutterSpace(cm);\n}\n\n// Make sure the gutters options contains the element\n// \"CodeMirror-linenumbers\" when the lineNumbers option is true.\nfunction setGuttersForLineNumbers(options) {\n  var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n  if (found == -1 && options.lineNumbers) {\n    options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n  } else if (found > -1 && !options.lineNumbers) {\n    options.gutters = options.gutters.slice(0);\n    options.gutters.splice(found, 1);\n  }\n}\n\n// Since the delta values reported on mouse wheel events are\n// unstandardized between browsers and even browser versions, and\n// generally horribly unpredictable, this code starts by measuring\n// the scroll effect that the first few mouse wheel events have,\n// and, from that, detects the way it can convert deltas to pixel\n// offsets afterwards.\n//\n// The reason we want to know the amount a wheel event will scroll\n// is that it gives us a chance to update the display before the\n// actual scrolling happens, reducing flickering.\n\nvar wheelSamples = 0;\nvar wheelPixelsPerUnit = null;\n// Fill in a browser-detected starting value on browsers where we\n// know one. These don't have to be accurate -- the result of them\n// being wrong would just be a slight flicker on the first wheel\n// scroll (if it is large enough).\nif (ie) { wheelPixelsPerUnit = -.53; }\nelse if (gecko) { wheelPixelsPerUnit = 15; }\nelse if (chrome) { wheelPixelsPerUnit = -.7; }\nelse if (safari) { wheelPixelsPerUnit = -1/3; }\n\nfunction wheelEventDelta(e) {\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n  else if (dy == null) { dy = e.wheelDelta; }\n  return {x: dx, y: dy}\n}\nfunction wheelEventPixels(e) {\n  var delta = wheelEventDelta(e);\n  delta.x *= wheelPixelsPerUnit;\n  delta.y *= wheelPixelsPerUnit;\n  return delta\n}\n\nfunction onScrollWheel(cm, e) {\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n  var display = cm.display, scroll = display.scroller;\n  // Quit if there's nothing to scroll here\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n  // Webkit browsers on OS X abort momentum scrolls when the target\n  // of the scroll event is removed from the scrollable element.\n  // This hack (see related code in patchDisplay) makes sure the\n  // element is kept around.\n  if (dy && mac && webkit) {\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n      for (var i = 0; i < view.length; i++) {\n        if (view[i].node == cur) {\n          cm.display.currentWheelTarget = cur;\n          break outer\n        }\n      }\n    }\n  }\n\n  // On some browsers, horizontal scrolling will cause redraws to\n  // happen before the gutter has been realigned, causing it to\n  // wriggle around in a most unseemly way. When we have an\n  // estimated pixels/delta value, we just handle horizontal\n  // scrolling entirely here. It'll be slightly off from native, but\n  // better than glitching out.\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n    if (dy && canScrollY)\n      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n    // Only prevent default scrolling if vertical scrolling is\n    // actually possible. Otherwise, it causes vertical scroll\n    // jitter on OSX trackpads when deltaX is small and deltaY\n    // is large (issue #3579)\n    if (!dy || (dy && canScrollY))\n      { e_preventDefault(e); }\n    display.wheelStartX = null; // Abort measurement, if in progress\n    return\n  }\n\n  // 'Project' the visible viewport to cover the area that is being\n  // scrolled into view (if we know enough to estimate it).\n  if (dy && wheelPixelsPerUnit != null) {\n    var pixels = dy * wheelPixelsPerUnit;\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n    updateDisplaySimple(cm, {top: top, bottom: bot});\n  }\n\n  if (wheelSamples < 20) {\n    if (display.wheelStartX == null) {\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n      display.wheelDX = dx; display.wheelDY = dy;\n      setTimeout(function () {\n        if (display.wheelStartX == null) { return }\n        var movedX = scroll.scrollLeft - display.wheelStartX;\n        var movedY = scroll.scrollTop - display.wheelStartY;\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n          (movedX && display.wheelDX && movedX / display.wheelDX);\n        display.wheelStartX = display.wheelStartY = null;\n        if (!sample) { return }\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n        ++wheelSamples;\n      }, 200);\n    } else {\n      display.wheelDX += dx; display.wheelDY += dy;\n    }\n  }\n}\n\n// Selection objects are immutable. A new one is created every time\n// the selection changes. A selection is one or more non-overlapping\n// (and non-touching) ranges, sorted, and an integer that indicates\n// which one is the primary selection (the one that's scrolled into\n// view, that getCursor returns, etc).\nvar Selection = function(ranges, primIndex) {\n  this.ranges = ranges;\n  this.primIndex = primIndex;\n};\n\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\nSelection.prototype.equals = function (other) {\n    var this$1 = this;\n\n  if (other == this) { return true }\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var here = this$1.ranges[i], there = other.ranges[i];\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n  }\n  return true\n};\n\nSelection.prototype.deepCopy = function () {\n    var this$1 = this;\n\n  var out = [];\n  for (var i = 0; i < this.ranges.length; i++)\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n  return new Selection(out, this.primIndex)\n};\n\nSelection.prototype.somethingSelected = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.ranges.length; i++)\n    { if (!this$1.ranges[i].empty()) { return true } }\n  return false\n};\n\nSelection.prototype.contains = function (pos, end) {\n    var this$1 = this;\n\n  if (!end) { end = pos; }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var range = this$1.ranges[i];\n    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n      { return i }\n  }\n  return -1\n};\n\nvar Range = function(anchor, head) {\n  this.anchor = anchor; this.head = head;\n};\n\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n// Take an unsorted, potentially overlapping set of ranges, and\n// build a selection out of it. 'Consumes' ranges array (modifying\n// it).\nfunction normalizeSelection(ranges, primIndex) {\n  var prim = ranges[primIndex];\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n  primIndex = indexOf(ranges, prim);\n  for (var i = 1; i < ranges.length; i++) {\n    var cur = ranges[i], prev = ranges[i - 1];\n    if (cmp(prev.to(), cur.from()) >= 0) {\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n      if (i <= primIndex) { --primIndex; }\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n    }\n  }\n  return new Selection(ranges, primIndex)\n}\n\nfunction simpleSelection(anchor, head) {\n  return new Selection([new Range(anchor, head || anchor)], 0)\n}\n\n// Compute the position of the end of a change (its 'to' property\n// refers to the pre-change end).\nfunction changeEnd(change) {\n  if (!change.text) { return change.to }\n  return Pos(change.from.line + change.text.length - 1,\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n}\n\n// Adjust a position to refer to the post-change position of the\n// same text, or the end of the change if the change covers it.\nfunction adjustForChange(pos, change) {\n  if (cmp(pos, change.from) < 0) { return pos }\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n  return Pos(line, ch)\n}\n\nfunction computeSelAfterChange(doc, change) {\n  var out = [];\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    var range = doc.sel.ranges[i];\n    out.push(new Range(adjustForChange(range.anchor, change),\n                       adjustForChange(range.head, change)));\n  }\n  return normalizeSelection(out, doc.sel.primIndex)\n}\n\nfunction offsetPos(pos, old, nw) {\n  if (pos.line == old.line)\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n  else\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n}\n\n// Used by replaceSelections to allow moving the selection to the\n// start or around the replaced test. Hint may be \"start\" or \"around\".\nfunction computeReplacedSel(doc, changes, hint) {\n  var out = [];\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    var from = offsetPos(change.from, oldPrev, newPrev);\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n    oldPrev = change.to;\n    newPrev = to;\n    if (hint == \"around\") {\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n      out[i] = new Range(inv ? to : from, inv ? from : to);\n    } else {\n      out[i] = new Range(from, from);\n    }\n  }\n  return new Selection(out, doc.sel.primIndex)\n}\n\n// Used to get the editor into a consistent state again when options change.\n\nfunction loadMode(cm) {\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n  resetModeState(cm);\n}\n\nfunction resetModeState(cm) {\n  cm.doc.iter(function (line) {\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n  });\n  cm.doc.frontier = cm.doc.first;\n  startWorker(cm, 100);\n  cm.state.modeGen++;\n  if (cm.curOp) { regChange(cm); }\n}\n\n// DOCUMENT DATA STRUCTURE\n\n// By default, updates that start and end at the beginning of a line\n// are treated specially, in order to make the association of line\n// widgets and marker elements with the text behave more intuitive.\nfunction isWholeLineUpdate(doc, change) {\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n}\n\n// Perform a change on the document data structure.\nfunction updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n  function update(line, text, spans) {\n    updateLine(line, text, spans, estimateHeight$$1);\n    signalLater(line, \"change\", line, change);\n  }\n  function linesFor(start, end) {\n    var result = [];\n    for (var i = start; i < end; ++i)\n      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n    return result\n  }\n\n  var from = change.from, to = change.to, text = change.text;\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n  // Adjust the line structure\n  if (change.full) {\n    doc.insert(0, linesFor(0, text.length));\n    doc.remove(text.length, doc.size - text.length);\n  } else if (isWholeLineUpdate(doc, change)) {\n    // This is a whole-line replace. Treated specially to make\n    // sure line objects move the way they are supposed to.\n    var added = linesFor(0, text.length - 1);\n    update(lastLine, lastLine.text, lastSpans);\n    if (nlines) { doc.remove(from.line, nlines); }\n    if (added.length) { doc.insert(from.line, added); }\n  } else if (firstLine == lastLine) {\n    if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n    } else {\n      var added$1 = linesFor(1, text.length - 1);\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      doc.insert(from.line + 1, added$1);\n    }\n  } else if (text.length == 1) {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n    doc.remove(from.line + 1, nlines);\n  } else {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n    var added$2 = linesFor(1, text.length - 1);\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n    doc.insert(from.line + 1, added$2);\n  }\n\n  signalLater(doc, \"change\", doc, change);\n}\n\n// Call f for all linked documents.\nfunction linkedDocs(doc, f, sharedHistOnly) {\n  function propagate(doc, skip, sharedHist) {\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n      var rel = doc.linked[i];\n      if (rel.doc == skip) { continue }\n      var shared = sharedHist && rel.sharedHist;\n      if (sharedHistOnly && !shared) { continue }\n      f(rel.doc, shared);\n      propagate(rel.doc, doc, shared);\n    } }\n  }\n  propagate(doc, null, true);\n}\n\n// Attach a document to an editor.\nfunction attachDoc(cm, doc) {\n  if (doc.cm) { throw new Error(\"This document is already in use.\") }\n  cm.doc = doc;\n  doc.cm = cm;\n  estimateLineHeights(cm);\n  loadMode(cm);\n  setDirectionClass(cm);\n  if (!cm.options.lineWrapping) { findMaxLine(cm); }\n  cm.options.mode = doc.modeOption;\n  regChange(cm);\n}\n\nfunction setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n}\n\nfunction directionChanged(cm) {\n  runInOp(cm, function () {\n    setDirectionClass(cm);\n    regChange(cm);\n  });\n}\n\nfunction History(startGen) {\n  // Arrays of change events and selections. Doing something adds an\n  // event to done and clears undo. Undoing moves events from done\n  // to undone, redoing moves them in the other direction.\n  this.done = []; this.undone = [];\n  this.undoDepth = Infinity;\n  // Used to track when changes can be merged into a single undo\n  // event\n  this.lastModTime = this.lastSelTime = 0;\n  this.lastOp = this.lastSelOp = null;\n  this.lastOrigin = this.lastSelOrigin = null;\n  // Used by the isClean() method\n  this.generation = this.maxGeneration = startGen || 1;\n}\n\n// Create a history change event from an updateDoc-style change\n// object.\nfunction historyChangeFromChange(doc, change) {\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n  return histChange\n}\n\n// Pop all selection events off the end of a history array. Stop at\n// a change event.\nfunction clearSelectionEvents(array) {\n  while (array.length) {\n    var last = lst(array);\n    if (last.ranges) { array.pop(); }\n    else { break }\n  }\n}\n\n// Find the top change event in the history. Pop off selection\n// events that are in the way.\nfunction lastChangeEvent(hist, force) {\n  if (force) {\n    clearSelectionEvents(hist.done);\n    return lst(hist.done)\n  } else if (hist.done.length && !lst(hist.done).ranges) {\n    return lst(hist.done)\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n    hist.done.pop();\n    return lst(hist.done)\n  }\n}\n\n// Register a change in the history. Merges changes that are within\n// a single operation, or are close together with an origin that\n// allows merging (starting with \"+\") into a single event.\nfunction addChangeToHistory(doc, change, selAfter, opId) {\n  var hist = doc.history;\n  hist.undone.length = 0;\n  var time = +new Date, cur;\n  var last;\n\n  if ((hist.lastOp == opId ||\n       hist.lastOrigin == change.origin && change.origin &&\n       ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n        change.origin.charAt(0) == \"*\")) &&\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n    // Merge this change into the last event\n    last = lst(cur.changes);\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n      // Optimized case for simple insertion -- don't want to add\n      // new changesets for every character typed\n      last.to = changeEnd(change);\n    } else {\n      // Add new sub-event\n      cur.changes.push(historyChangeFromChange(doc, change));\n    }\n  } else {\n    // Can not be merged, start a new event.\n    var before = lst(hist.done);\n    if (!before || !before.ranges)\n      { pushSelectionToHistory(doc.sel, hist.done); }\n    cur = {changes: [historyChangeFromChange(doc, change)],\n           generation: hist.generation};\n    hist.done.push(cur);\n    while (hist.done.length > hist.undoDepth) {\n      hist.done.shift();\n      if (!hist.done[0].ranges) { hist.done.shift(); }\n    }\n  }\n  hist.done.push(selAfter);\n  hist.generation = ++hist.maxGeneration;\n  hist.lastModTime = hist.lastSelTime = time;\n  hist.lastOp = hist.lastSelOp = opId;\n  hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n  if (!last) { signal(doc, \"historyAdded\"); }\n}\n\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\n  var ch = origin.charAt(0);\n  return ch == \"*\" ||\n    ch == \"+\" &&\n    prev.ranges.length == sel.ranges.length &&\n    prev.somethingSelected() == sel.somethingSelected() &&\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n}\n\n// Called whenever the selection changes, sets the new selection as\n// the pending selection in the history, and pushes the old pending\n// selection into the 'done' array when it was significantly\n// different (in number of selected ranges, emptiness, or time).\nfunction addSelectionToHistory(doc, sel, opId, options) {\n  var hist = doc.history, origin = options && options.origin;\n\n  // A new event is started when the previous origin does not match\n  // the current, or the origins don't allow matching. Origins\n  // starting with * are always merged, those starting with + are\n  // merged when similar and close together in time.\n  if (opId == hist.lastSelOp ||\n      (origin && hist.lastSelOrigin == origin &&\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n    { hist.done[hist.done.length - 1] = sel; }\n  else\n    { pushSelectionToHistory(sel, hist.done); }\n\n  hist.lastSelTime = +new Date;\n  hist.lastSelOrigin = origin;\n  hist.lastSelOp = opId;\n  if (options && options.clearRedo !== false)\n    { clearSelectionEvents(hist.undone); }\n}\n\nfunction pushSelectionToHistory(sel, dest) {\n  var top = lst(dest);\n  if (!(top && top.ranges && top.equals(sel)))\n    { dest.push(sel); }\n}\n\n// Used to store marked span information in the history.\nfunction attachLocalSpans(doc, change, from, to) {\n  var existing = change[\"spans_\" + doc.id], n = 0;\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n    if (line.markedSpans)\n      { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n    ++n;\n  });\n}\n\n// When un/re-doing restores text containing marked spans, those\n// that have been explicitly cleared should not be restored.\nfunction removeClearedSpans(spans) {\n  if (!spans) { return null }\n  var out;\n  for (var i = 0; i < spans.length; ++i) {\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n    else if (out) { out.push(spans[i]); }\n  }\n  return !out ? spans : out.length ? out : null\n}\n\n// Retrieve and filter the old marked spans stored in a change event.\nfunction getOldSpans(doc, change) {\n  var found = change[\"spans_\" + doc.id];\n  if (!found) { return null }\n  var nw = [];\n  for (var i = 0; i < change.text.length; ++i)\n    { nw.push(removeClearedSpans(found[i])); }\n  return nw\n}\n\n// Used for un/re-doing changes from the history. Combines the\n// result of computing the existing spans with the set of spans that\n// existed in the history (so that deleting around a span and then\n// undoing brings back the span).\nfunction mergeOldSpans(doc, change) {\n  var old = getOldSpans(doc, change);\n  var stretched = stretchSpansOverChange(doc, change);\n  if (!old) { return stretched }\n  if (!stretched) { return old }\n\n  for (var i = 0; i < old.length; ++i) {\n    var oldCur = old[i], stretchCur = stretched[i];\n    if (oldCur && stretchCur) {\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\n        var span = stretchCur[j];\n        for (var k = 0; k < oldCur.length; ++k)\n          { if (oldCur[k].marker == span.marker) { continue spans } }\n        oldCur.push(span);\n      }\n    } else if (stretchCur) {\n      old[i] = stretchCur;\n    }\n  }\n  return old\n}\n\n// Used both to provide a JSON-safe object in .getHistory, and, when\n// detaching a document, to split the history in two\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\n  var copy = [];\n  for (var i = 0; i < events.length; ++i) {\n    var event = events[i];\n    if (event.ranges) {\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n      continue\n    }\n    var changes = event.changes, newChanges = [];\n    copy.push({changes: newChanges});\n    for (var j = 0; j < changes.length; ++j) {\n      var change = changes[j], m = (void 0);\n      newChanges.push({from: change.from, to: change.to, text: change.text});\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n        if (indexOf(newGroup, Number(m[1])) > -1) {\n          lst(newChanges)[prop] = change[prop];\n          delete change[prop];\n        }\n      } } }\n    }\n  }\n  return copy\n}\n\n// The 'scroll' parameter given to many of these indicated whether\n// the new cursor position should be scrolled into view after\n// modifying the selection.\n\n// If shift is held or the extend flag is set, extends a range to\n// include a given position (and optionally a second position).\n// Otherwise, simply returns the range between the given positions.\n// Used for cursor motion and such.\nfunction extendRange(doc, range, head, other) {\n  if (doc.cm && doc.cm.display.shift || doc.extend) {\n    var anchor = range.anchor;\n    if (other) {\n      var posBefore = cmp(head, anchor) < 0;\n      if (posBefore != (cmp(other, anchor) < 0)) {\n        anchor = head;\n        head = other;\n      } else if (posBefore != (cmp(head, other) < 0)) {\n        head = other;\n      }\n    }\n    return new Range(anchor, head)\n  } else {\n    return new Range(other || head, head)\n  }\n}\n\n// Extend the primary selection range, discard the rest.\nfunction extendSelection(doc, head, other, options) {\n  setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n}\n\n// Extend all selections (pos is an array of selections with length\n// equal the number of selections)\nfunction extendSelections(doc, heads, options) {\n  var out = [];\n  for (var i = 0; i < doc.sel.ranges.length; i++)\n    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null); }\n  var newSel = normalizeSelection(out, doc.sel.primIndex);\n  setSelection(doc, newSel, options);\n}\n\n// Updates a single range in the selection.\nfunction replaceOneSelection(doc, i, range, options) {\n  var ranges = doc.sel.ranges.slice(0);\n  ranges[i] = range;\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n}\n\n// Reset the selection to a single range.\nfunction setSimpleSelection(doc, anchor, head, options) {\n  setSelection(doc, simpleSelection(anchor, head), options);\n}\n\n// Give beforeSelectionChange handlers a change to influence a\n// selection update.\nfunction filterSelectionChange(doc, sel, options) {\n  var obj = {\n    ranges: sel.ranges,\n    update: function(ranges) {\n      var this$1 = this;\n\n      this.ranges = [];\n      for (var i = 0; i < ranges.length; i++)\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                   clipPos(doc, ranges[i].head)); }\n    },\n    origin: options && options.origin\n  };\n  signal(doc, \"beforeSelectionChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\n  else { return sel }\n}\n\nfunction setSelectionReplaceHistory(doc, sel, options) {\n  var done = doc.history.done, last = lst(done);\n  if (last && last.ranges) {\n    done[done.length - 1] = sel;\n    setSelectionNoUndo(doc, sel, options);\n  } else {\n    setSelection(doc, sel, options);\n  }\n}\n\n// Set a new selection.\nfunction setSelection(doc, sel, options) {\n  setSelectionNoUndo(doc, sel, options);\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n}\n\nfunction setSelectionNoUndo(doc, sel, options) {\n  if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n    { sel = filterSelectionChange(doc, sel, options); }\n\n  var bias = options && options.bias ||\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n  if (!(options && options.scroll === false) && doc.cm)\n    { ensureCursorVisible(doc.cm); }\n}\n\nfunction setSelectionInner(doc, sel) {\n  if (sel.equals(doc.sel)) { return }\n\n  doc.sel = sel;\n\n  if (doc.cm) {\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n    signalCursorActivity(doc.cm);\n  }\n  signalLater(doc, \"cursorActivity\", doc);\n}\n\n// Verify that the selection does not partially select any atomic\n// marked ranges.\nfunction reCheckSelection(doc) {\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n}\n\n// Return a selection that does not partially select any atomic\n// ranges.\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\n  var out;\n  for (var i = 0; i < sel.ranges.length; i++) {\n    var range = sel.ranges[i];\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n    if (out || newAnchor != range.anchor || newHead != range.head) {\n      if (!out) { out = sel.ranges.slice(0, i); }\n      out[i] = new Range(newAnchor, newHead);\n    }\n  }\n  return out ? normalizeSelection(out, sel.primIndex) : sel\n}\n\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n  var line = getLine(doc, pos.line);\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n    var sp = line.markedSpans[i], m = sp.marker;\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n      if (mayClear) {\n        signal(m, \"beforeCursorEnter\");\n        if (m.explicitlyCleared) {\n          if (!line.markedSpans) { break }\n          else {--i; continue}\n        }\n      }\n      if (!m.atomic) { continue }\n\n      if (oldPos) {\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n      }\n\n      var far = m.find(dir < 0 ? -1 : 1);\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n    }\n  } }\n  return pos\n}\n\n// Ensure a given position is not inside an atomic range.\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\n  var dir = bias || 1;\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n  if (!found) {\n    doc.cantEdit = true;\n    return Pos(doc.first, 0)\n  }\n  return found\n}\n\nfunction movePos(doc, pos, dir, line) {\n  if (dir < 0 && pos.ch == 0) {\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n    else { return null }\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n    else { return null }\n  } else {\n    return new Pos(pos.line, pos.ch + dir)\n  }\n}\n\nfunction selectAll(cm) {\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n}\n\n// UPDATING\n\n// Allow \"beforeChange\" event handlers to influence a change\nfunction filterChange(doc, change, update) {\n  var obj = {\n    canceled: false,\n    from: change.from,\n    to: change.to,\n    text: change.text,\n    origin: change.origin,\n    cancel: function () { return obj.canceled = true; }\n  };\n  if (update) { obj.update = function (from, to, text, origin) {\n    if (from) { obj.from = clipPos(doc, from); }\n    if (to) { obj.to = clipPos(doc, to); }\n    if (text) { obj.text = text; }\n    if (origin !== undefined) { obj.origin = origin; }\n  }; }\n  signal(doc, \"beforeChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n  if (obj.canceled) { return null }\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n}\n\n// Apply a change to a document, and add it to the document's\n// history, and propagating it to all linked documents.\nfunction makeChange(doc, change, ignoreReadOnly) {\n  if (doc.cm) {\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n    if (doc.cm.state.suppressEdits) { return }\n  }\n\n  if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n    change = filterChange(doc, change, true);\n    if (!change) { return }\n  }\n\n  // Possibly split or suppress the update based on the presence\n  // of read-only spans in its range.\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n  if (split) {\n    for (var i = split.length - 1; i >= 0; --i)\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text}); }\n  } else {\n    makeChangeInner(doc, change);\n  }\n}\n\nfunction makeChangeInner(doc, change) {\n  if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n  var selAfter = computeSelAfterChange(doc, change);\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n  var rebased = [];\n\n  linkedDocs(doc, function (doc, sharedHist) {\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n      rebaseHist(doc.history, change);\n      rebased.push(doc.history);\n    }\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n  });\n}\n\n// Revert a change stored in a document's history.\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\n\n  var hist = doc.history, event, selAfter = doc.sel;\n  var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n  // Verify that there is a useable event (so that ctrl-z won't\n  // needlessly clear selection events)\n  var i = 0;\n  for (; i < source.length; i++) {\n    event = source[i];\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n      { break }\n  }\n  if (i == source.length) { return }\n  hist.lastOrigin = hist.lastSelOrigin = null;\n\n  for (;;) {\n    event = source.pop();\n    if (event.ranges) {\n      pushSelectionToHistory(event, dest);\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\n        setSelection(doc, event, {clearRedo: false});\n        return\n      }\n      selAfter = event;\n    }\n    else { break }\n  }\n\n  // Build up a reverse change object to add to the opposite history\n  // stack (redo when undoing, and vice versa).\n  var antiChanges = [];\n  pushSelectionToHistory(selAfter, dest);\n  dest.push({changes: antiChanges, generation: hist.generation});\n  hist.generation = event.generation || ++hist.maxGeneration;\n\n  var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n  var loop = function ( i ) {\n    var change = event.changes[i];\n    change.origin = type;\n    if (filter && !filterChange(doc, change, false)) {\n      source.length = 0;\n      return {}\n    }\n\n    antiChanges.push(historyChangeFromChange(doc, change));\n\n    var after = i ? computeSelAfterChange(doc, change) : lst(source);\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n    var rebased = [];\n\n    // Propagate to the linked documents\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n    });\n  };\n\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n    var returned = loop( i$1 );\n\n    if ( returned ) return returned.v;\n  }\n}\n\n// Sub-views need their line numbers shifted when text is added\n// above or below them in the parent document.\nfunction shiftDoc(doc, distance) {\n  if (distance == 0) { return }\n  doc.first += distance;\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n    Pos(range.anchor.line + distance, range.anchor.ch),\n    Pos(range.head.line + distance, range.head.ch)\n  ); }), doc.sel.primIndex);\n  if (doc.cm) {\n    regChange(doc.cm, doc.first, doc.first - distance, distance);\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n      { regLineChange(doc.cm, l, \"gutter\"); }\n  }\n}\n\n// More lower-level change function, handling only a single document\n// (not linked ones).\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\n  if (doc.cm && !doc.cm.curOp)\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n  if (change.to.line < doc.first) {\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n    return\n  }\n  if (change.from.line > doc.lastLine()) { return }\n\n  // Clip the change to the size of this doc\n  if (change.from.line < doc.first) {\n    var shift = change.text.length - 1 - (doc.first - change.from.line);\n    shiftDoc(doc, shift);\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n              text: [lst(change.text)], origin: change.origin};\n  }\n  var last = doc.lastLine();\n  if (change.to.line > last) {\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n              text: [change.text[0]], origin: change.origin};\n  }\n\n  change.removed = getBetween(doc, change.from, change.to);\n\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n  else { updateDoc(doc, change, spans); }\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n}\n\n// Handle the interaction of a change to a document with the editor\n// that this document is part of.\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n  var recomputeMaxLength = false, checkWidthStart = from.line;\n  if (!cm.options.lineWrapping) {\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\n      if (line == display.maxLine) {\n        recomputeMaxLength = true;\n        return true\n      }\n    });\n  }\n\n  if (doc.sel.contains(change.from, change.to) > -1)\n    { signalCursorActivity(cm); }\n\n  updateDoc(doc, change, spans, estimateHeight(cm));\n\n  if (!cm.options.lineWrapping) {\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n      var len = lineLength(line);\n      if (len > display.maxLineLength) {\n        display.maxLine = line;\n        display.maxLineLength = len;\n        display.maxLineChanged = true;\n        recomputeMaxLength = false;\n      }\n    });\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n  }\n\n  // Adjust frontier, schedule worker\n  doc.frontier = Math.min(doc.frontier, from.line);\n  startWorker(cm, 400);\n\n  var lendiff = change.text.length - (to.line - from.line) - 1;\n  // Remember that these lines changed, for updating the display\n  if (change.full)\n    { regChange(cm); }\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n    { regLineChange(cm, from.line, \"text\"); }\n  else\n    { regChange(cm, from.line, to.line + 1, lendiff); }\n\n  var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n  if (changeHandler || changesHandler) {\n    var obj = {\n      from: from, to: to,\n      text: change.text,\n      removed: change.removed,\n      origin: change.origin\n    };\n    if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n  }\n  cm.display.selForContextMenu = null;\n}\n\nfunction replaceRange(doc, code, from, to, origin) {\n  if (!to) { to = from; }\n  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n  if (typeof code == \"string\") { code = doc.splitLines(code); }\n  makeChange(doc, {from: from, to: to, text: code, origin: origin});\n}\n\n// Rebasing/resetting history to deal with externally-sourced changes\n\nfunction rebaseHistSelSingle(pos, from, to, diff) {\n  if (to < pos.line) {\n    pos.line += diff;\n  } else if (from < pos.line) {\n    pos.line = from;\n    pos.ch = 0;\n  }\n}\n\n// Tries to rebase an array of history events given a change in the\n// document. If the change touches the same lines as the event, the\n// event, and everything 'behind' it, is discarded. If the change is\n// before the event, the event's positions are updated. Uses a\n// copy-on-write scheme for the positions, to avoid having to\n// reallocate them all on every rebase, but also avoid problems with\n// shared position objects being unsafely updated.\nfunction rebaseHistArray(array, from, to, diff) {\n  for (var i = 0; i < array.length; ++i) {\n    var sub = array[i], ok = true;\n    if (sub.ranges) {\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n      for (var j = 0; j < sub.ranges.length; j++) {\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n      }\n      continue\n    }\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n      var cur = sub.changes[j$1];\n      if (to < cur.from.line) {\n        cur.from = Pos(cur.from.line + diff, cur.from.ch);\n        cur.to = Pos(cur.to.line + diff, cur.to.ch);\n      } else if (from <= cur.to.line) {\n        ok = false;\n        break\n      }\n    }\n    if (!ok) {\n      array.splice(0, i + 1);\n      i = 0;\n    }\n  }\n}\n\nfunction rebaseHist(hist, change) {\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n  rebaseHistArray(hist.done, from, to, diff);\n  rebaseHistArray(hist.undone, from, to, diff);\n}\n\n// Utility for applying a change to a line by handle or number,\n// returning the number and optionally registering the line as\n// changed.\nfunction changeLine(doc, handle, changeType, op) {\n  var no = handle, line = handle;\n  if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n  else { no = lineNo(handle); }\n  if (no == null) { return null }\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n  return line\n}\n\n// The document is represented as a BTree consisting of leaves, with\n// chunk of lines in them, and branches, with up to ten leaves or\n// other branch nodes below them. The top node is always a branch\n// node, and is the document object itself (meaning it has\n// additional methods and properties).\n//\n// All nodes have parent links. The tree is used both to go from\n// line numbers to line objects, and to go from objects to numbers.\n// It also indexes by height, and is used to convert between height\n// and line object, and to find the total height of the document.\n//\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\nvar LeafChunk = function(lines) {\n  var this$1 = this;\n\n  this.lines = lines;\n  this.parent = null;\n  var height = 0;\n  for (var i = 0; i < lines.length; ++i) {\n    lines[i].parent = this$1;\n    height += lines[i].height;\n  }\n  this.height = height;\n};\n\nLeafChunk.prototype.chunkSize = function () { return this.lines.length };\n\n// Remove the n lines at offset 'at'.\nLeafChunk.prototype.removeInner = function (at, n) {\n    var this$1 = this;\n\n  for (var i = at, e = at + n; i < e; ++i) {\n    var line = this$1.lines[i];\n    this$1.height -= line.height;\n    cleanUpLine(line);\n    signalLater(line, \"delete\");\n  }\n  this.lines.splice(at, n);\n};\n\n// Helper used to collapse a small branch into a single leaf.\nLeafChunk.prototype.collapse = function (lines) {\n  lines.push.apply(lines, this.lines);\n};\n\n// Insert the given array of lines at offset 'at', count them as\n// having the given height.\nLeafChunk.prototype.insertInner = function (at, lines, height) {\n    var this$1 = this;\n\n  this.height += height;\n  this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n  for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\n};\n\n// Used to iterate over a part of the tree.\nLeafChunk.prototype.iterN = function (at, n, op) {\n    var this$1 = this;\n\n  for (var e = at + n; at < e; ++at)\n    { if (op(this$1.lines[at])) { return true } }\n};\n\nvar BranchChunk = function(children) {\n  var this$1 = this;\n\n  this.children = children;\n  var size = 0, height = 0;\n  for (var i = 0; i < children.length; ++i) {\n    var ch = children[i];\n    size += ch.chunkSize(); height += ch.height;\n    ch.parent = this$1;\n  }\n  this.size = size;\n  this.height = height;\n  this.parent = null;\n};\n\nBranchChunk.prototype.chunkSize = function () { return this.size };\n\nBranchChunk.prototype.removeInner = function (at, n) {\n    var this$1 = this;\n\n  this.size -= n;\n  for (var i = 0; i < this.children.length; ++i) {\n    var child = this$1.children[i], sz = child.chunkSize();\n    if (at < sz) {\n      var rm = Math.min(n, sz - at), oldHeight = child.height;\n      child.removeInner(at, rm);\n      this$1.height -= oldHeight - child.height;\n      if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n      if ((n -= rm) == 0) { break }\n      at = 0;\n    } else { at -= sz; }\n  }\n  // If the result is smaller than 25 lines, ensure that it is a\n  // single leaf node.\n  if (this.size - n < 25 &&\n      (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n    var lines = [];\n    this.collapse(lines);\n    this.children = [new LeafChunk(lines)];\n    this.children[0].parent = this;\n  }\n};\n\nBranchChunk.prototype.collapse = function (lines) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\n};\n\nBranchChunk.prototype.insertInner = function (at, lines, height) {\n    var this$1 = this;\n\n  this.size += lines.length;\n  this.height += height;\n  for (var i = 0; i < this.children.length; ++i) {\n    var child = this$1.children[i], sz = child.chunkSize();\n    if (at <= sz) {\n      child.insertInner(at, lines, height);\n      if (child.lines && child.lines.length > 50) {\n        // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n        // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n        var remaining = child.lines.length % 25 + 25;\n        for (var pos = remaining; pos < child.lines.length;) {\n          var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n          child.height -= leaf.height;\n          this$1.children.splice(++i, 0, leaf);\n          leaf.parent = this$1;\n        }\n        child.lines = child.lines.slice(0, remaining);\n        this$1.maybeSpill();\n      }\n      break\n    }\n    at -= sz;\n  }\n};\n\n// When a node has grown, check whether it should be split.\nBranchChunk.prototype.maybeSpill = function () {\n  if (this.children.length <= 10) { return }\n  var me = this;\n  do {\n    var spilled = me.children.splice(me.children.length - 5, 5);\n    var sibling = new BranchChunk(spilled);\n    if (!me.parent) { // Become the parent node\n      var copy = new BranchChunk(me.children);\n      copy.parent = me;\n      me.children = [copy, sibling];\n      me = copy;\n   } else {\n      me.size -= sibling.size;\n      me.height -= sibling.height;\n      var myIndex = indexOf(me.parent.children, me);\n      me.parent.children.splice(myIndex + 1, 0, sibling);\n    }\n    sibling.parent = me.parent;\n  } while (me.children.length > 10)\n  me.parent.maybeSpill();\n};\n\nBranchChunk.prototype.iterN = function (at, n, op) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.children.length; ++i) {\n    var child = this$1.children[i], sz = child.chunkSize();\n    if (at < sz) {\n      var used = Math.min(n, sz - at);\n      if (child.iterN(at, used, op)) { return true }\n      if ((n -= used) == 0) { break }\n      at = 0;\n    } else { at -= sz; }\n  }\n};\n\n// Line widgets are block elements displayed above or below a line.\n\nvar LineWidget = function(doc, node, options) {\n  var this$1 = this;\n\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n    { this$1[opt] = options[opt]; } } }\n  this.doc = doc;\n  this.node = node;\n};\n\nLineWidget.prototype.clear = function () {\n    var this$1 = this;\n\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n  if (no == null || !ws) { return }\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n  if (!ws.length) { line.widgets = null; }\n  var height = widgetHeight(this);\n  updateLineHeight(line, Math.max(0, line.height - height));\n  if (cm) {\n    runInOp(cm, function () {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n    signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n  }\n};\n\nLineWidget.prototype.changed = function () {\n    var this$1 = this;\n\n  var oldH = this.height, cm = this.doc.cm, line = this.line;\n  this.height = null;\n  var diff = widgetHeight(this) - oldH;\n  if (!diff) { return }\n  updateLineHeight(line, line.height + diff);\n  if (cm) {\n    runInOp(cm, function () {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n      signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n    });\n  }\n};\neventMixin(LineWidget);\n\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n    { addToScrollTop(cm, diff); }\n}\n\nfunction addLineWidget(doc, handle, node, options) {\n  var widget = new LineWidget(doc, node, options);\n  var cm = doc.cm;\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n  changeLine(doc, handle, \"widget\", function (line) {\n    var widgets = line.widgets || (line.widgets = []);\n    if (widget.insertAt == null) { widgets.push(widget); }\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n    widget.line = line;\n    if (cm && !lineIsHidden(doc, line)) {\n      var aboveVisible = heightAtLine(line) < doc.scrollTop;\n      updateLineHeight(line, line.height + widgetHeight(widget));\n      if (aboveVisible) { addToScrollTop(cm, widget.height); }\n      cm.curOp.forceUpdate = true;\n    }\n    return true\n  });\n  signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n  return widget\n}\n\n// TEXTMARKERS\n\n// Created with markText and setBookmark methods. A TextMarker is a\n// handle that can be used to clear or find a marked position in the\n// document. Line objects hold arrays (markedSpans) containing\n// {from, to, marker} object pointing to such marker objects, and\n// indicating that such a marker is present on that line. Multiple\n// lines may point to the same marker when it spans across lines.\n// The spans will have null for their from/to properties when the\n// marker continues beyond the start/end of the line. Markers have\n// links back to the lines they currently touch.\n\n// Collapsed markers have unique ids, in order to be able to order\n// them, which is needed for uniquely determining an outer marker\n// when they overlap (they may nest, but not partially overlap).\nvar nextMarkerId = 0;\n\nvar TextMarker = function(doc, type) {\n  this.lines = [];\n  this.type = type;\n  this.doc = doc;\n  this.id = ++nextMarkerId;\n};\n\n// Clear the marker.\nTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  var cm = this.doc.cm, withOp = cm && !cm.curOp;\n  if (withOp) { startOperation(cm); }\n  if (hasHandler(this, \"clear\")) {\n    var found = this.find();\n    if (found) { signalLater(this, \"clear\", found.from, found.to); }\n  }\n  var min = null, max = null;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n    else if (cm) {\n      if (span.to != null) { max = lineNo(line); }\n      if (span.from != null) { min = lineNo(line); }\n    }\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\n      { updateLineHeight(line, textHeight(cm.display)); }\n  }\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n    if (len > cm.display.maxLineLength) {\n      cm.display.maxLine = visual;\n      cm.display.maxLineLength = len;\n      cm.display.maxLineChanged = true;\n    }\n  } }\n\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n  this.lines.length = 0;\n  this.explicitlyCleared = true;\n  if (this.atomic && this.doc.cantEdit) {\n    this.doc.cantEdit = false;\n    if (cm) { reCheckSelection(cm.doc); }\n  }\n  if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n  if (withOp) { endOperation(cm); }\n  if (this.parent) { this.parent.clear(); }\n};\n\n// Find the position of the marker in the document. Returns a {from,\n// to} object by default. Side can be passed to get a specific side\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n// Pos objects returned contain a line object, rather than a line\n// number (used to prevent looking up the same line twice).\nTextMarker.prototype.find = function (side, lineObj) {\n    var this$1 = this;\n\n  if (side == null && this.type == \"bookmark\") { side = 1; }\n  var from, to;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (span.from != null) {\n      from = Pos(lineObj ? line : lineNo(line), span.from);\n      if (side == -1) { return from }\n    }\n    if (span.to != null) {\n      to = Pos(lineObj ? line : lineNo(line), span.to);\n      if (side == 1) { return to }\n    }\n  }\n  return from && {from: from, to: to}\n};\n\n// Signals that the marker's widget changed, and surrounding layout\n// should be recomputed.\nTextMarker.prototype.changed = function () {\n    var this$1 = this;\n\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n  if (!pos || !cm) { return }\n  runInOp(cm, function () {\n    var line = pos.line, lineN = lineNo(pos.line);\n    var view = findViewForLine(cm, lineN);\n    if (view) {\n      clearLineMeasurementCacheFor(view);\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n    }\n    cm.curOp.updateMaxLine = true;\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n      var oldHeight = widget.height;\n      widget.height = null;\n      var dHeight = widgetHeight(widget) - oldHeight;\n      if (dHeight)\n        { updateLineHeight(line, line.height + dHeight); }\n    }\n    signalLater(cm, \"markerChanged\", cm, this$1);\n  });\n};\n\nTextMarker.prototype.attachLine = function (line) {\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n  }\n  this.lines.push(line);\n};\n\nTextMarker.prototype.detachLine = function (line) {\n  this.lines.splice(indexOf(this.lines, line), 1);\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n  }\n};\neventMixin(TextMarker);\n\n// Create a marker, wire it up to the right lines, and\nfunction markText(doc, from, to, options, type) {\n  // Shared markers (across linked documents) are handled separately\n  // (markTextShared will call out to this again, once per\n  // document).\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n  // Ensure we are in an operation.\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n  var marker = new TextMarker(doc, type), diff = cmp(from, to);\n  if (options) { copyObj(options, marker, false); }\n  // Don't connect empty markers unless clearWhenEmpty is false\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n    { return marker }\n  if (marker.replacedWith) {\n    // Showing up as a widget implies collapsed (widget replaces text)\n    marker.collapsed = true;\n    marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n  }\n  if (marker.collapsed) {\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n      { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n    seeCollapsedSpans();\n  }\n\n  if (marker.addToHistory)\n    { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n  var curLine = from.line, cm = doc.cm, updateMaxLine;\n  doc.iter(curLine, to.line + 1, function (line) {\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n      { updateMaxLine = true; }\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n    addMarkedSpan(line, new MarkedSpan(marker,\n                                       curLine == from.line ? from.ch : null,\n                                       curLine == to.line ? to.ch : null));\n    ++curLine;\n  });\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n  }); }\n\n  if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n  if (marker.readOnly) {\n    seeReadOnlySpans();\n    if (doc.history.done.length || doc.history.undone.length)\n      { doc.clearHistory(); }\n  }\n  if (marker.collapsed) {\n    marker.id = ++nextMarkerId;\n    marker.atomic = true;\n  }\n  if (cm) {\n    // Sync editor state\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n    if (marker.collapsed)\n      { regChange(cm, from.line, to.line + 1); }\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n    if (marker.atomic) { reCheckSelection(cm.doc); }\n    signalLater(cm, \"markerAdded\", cm, marker);\n  }\n  return marker\n}\n\n// SHARED TEXTMARKERS\n\n// A shared marker spans multiple linked documents. It is\n// implemented as a meta-marker-object controlling multiple normal\n// markers.\nvar SharedTextMarker = function(markers, primary) {\n  var this$1 = this;\n\n  this.markers = markers;\n  this.primary = primary;\n  for (var i = 0; i < markers.length; ++i)\n    { markers[i].parent = this$1; }\n};\n\nSharedTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  this.explicitlyCleared = true;\n  for (var i = 0; i < this.markers.length; ++i)\n    { this$1.markers[i].clear(); }\n  signalLater(this, \"clear\");\n};\n\nSharedTextMarker.prototype.find = function (side, lineObj) {\n  return this.primary.find(side, lineObj)\n};\neventMixin(SharedTextMarker);\n\nfunction markTextShared(doc, from, to, options, type) {\n  options = copyObj(options);\n  options.shared = false;\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n  var widget = options.widgetNode;\n  linkedDocs(doc, function (doc) {\n    if (widget) { options.widgetNode = widget.cloneNode(true); }\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n    for (var i = 0; i < doc.linked.length; ++i)\n      { if (doc.linked[i].isParent) { return } }\n    primary = lst(markers);\n  });\n  return new SharedTextMarker(markers, primary)\n}\n\nfunction findSharedMarkers(doc) {\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n}\n\nfunction copySharedMarkers(doc, markers) {\n  for (var i = 0; i < markers.length; i++) {\n    var marker = markers[i], pos = marker.find();\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n    if (cmp(mFrom, mTo)) {\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n      marker.markers.push(subMark);\n      subMark.parent = marker;\n    }\n  }\n}\n\nfunction detachSharedMarkers(markers) {\n  var loop = function ( i ) {\n    var marker = markers[i], linked = [marker.primary.doc];\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n    for (var j = 0; j < marker.markers.length; j++) {\n      var subMarker = marker.markers[j];\n      if (indexOf(linked, subMarker.doc) == -1) {\n        subMarker.parent = null;\n        marker.markers.splice(j--, 1);\n      }\n    }\n  };\n\n  for (var i = 0; i < markers.length; i++) loop( i );\n}\n\nvar nextDocId = 0;\nvar Doc = function(text, mode, firstLine, lineSep, direction) {\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n  if (firstLine == null) { firstLine = 0; }\n\n  BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n  this.first = firstLine;\n  this.scrollTop = this.scrollLeft = 0;\n  this.cantEdit = false;\n  this.cleanGeneration = 1;\n  this.frontier = firstLine;\n  var start = Pos(firstLine, 0);\n  this.sel = simpleSelection(start);\n  this.history = new History(null);\n  this.id = ++nextDocId;\n  this.modeOption = mode;\n  this.lineSep = lineSep;\n  this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n  this.extend = false;\n\n  if (typeof text == \"string\") { text = this.splitLines(text); }\n  updateDoc(this, {from: start, to: start, text: text});\n  setSelection(this, simpleSelection(start), sel_dontScroll);\n};\n\nDoc.prototype = createObj(BranchChunk.prototype, {\n  constructor: Doc,\n  // Iterate over the document. Supports two forms -- with only one\n  // argument, it calls that for each line in the document. With\n  // three, it iterates over the range given by the first two (with\n  // the second being non-inclusive).\n  iter: function(from, to, op) {\n    if (op) { this.iterN(from - this.first, to - from, op); }\n    else { this.iterN(this.first, this.first + this.size, from); }\n  },\n\n  // Non-public interface for adding and removing lines.\n  insert: function(at, lines) {\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n    this.insertInner(at - this.first, lines, height);\n  },\n  remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n  // From here, the methods are part of the public interface. Most\n  // are also available from CodeMirror (editor) instances.\n\n  getValue: function(lineSep) {\n    var lines = getLines(this, this.first, this.first + this.size);\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n  setValue: docMethodOp(function(code) {\n    var top = Pos(this.first, 0), last = this.first + this.size - 1;\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                      text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n    if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n    setSelection(this, simpleSelection(top), sel_dontScroll);\n  }),\n  replaceRange: function(code, from, to, origin) {\n    from = clipPos(this, from);\n    to = to ? clipPos(this, to) : from;\n    replaceRange(this, code, from, to, origin);\n  },\n  getRange: function(from, to, lineSep) {\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n  getLineNumber: function(line) {return lineNo(line)},\n\n  getLineHandleVisualStart: function(line) {\n    if (typeof line == \"number\") { line = getLine(this, line); }\n    return visualLine(line)\n  },\n\n  lineCount: function() {return this.size},\n  firstLine: function() {return this.first},\n  lastLine: function() {return this.first + this.size - 1},\n\n  clipPos: function(pos) {return clipPos(this, pos)},\n\n  getCursor: function(start) {\n    var range$$1 = this.sel.primary(), pos;\n    if (start == null || start == \"head\") { pos = range$$1.head; }\n    else if (start == \"anchor\") { pos = range$$1.anchor; }\n    else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n    else { pos = range$$1.from(); }\n    return pos\n  },\n  listSelections: function() { return this.sel.ranges },\n  somethingSelected: function() {return this.sel.somethingSelected()},\n\n  setCursor: docMethodOp(function(line, ch, options) {\n    setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n  }),\n  setSelection: docMethodOp(function(anchor, head, options) {\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n  }),\n  extendSelection: docMethodOp(function(head, other, options) {\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n  }),\n  extendSelections: docMethodOp(function(heads, options) {\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  extendSelectionsBy: docMethodOp(function(f, options) {\n    var heads = map(this.sel.ranges, f);\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  setSelections: docMethodOp(function(ranges, primary, options) {\n    var this$1 = this;\n\n    if (!ranges.length) { return }\n    var out = [];\n    for (var i = 0; i < ranges.length; i++)\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                         clipPos(this$1, ranges[i].head)); }\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n    setSelection(this, normalizeSelection(out, primary), options);\n  }),\n  addSelection: docMethodOp(function(anchor, head, options) {\n    var ranges = this.sel.ranges.slice(0);\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n  }),\n\n  getSelection: function(lineSep) {\n    var this$1 = this;\n\n    var ranges = this.sel.ranges, lines;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      lines = lines ? lines.concat(sel) : sel;\n    }\n    if (lineSep === false) { return lines }\n    else { return lines.join(lineSep || this.lineSeparator()) }\n  },\n  getSelections: function(lineSep) {\n    var this$1 = this;\n\n    var parts = [], ranges = this.sel.ranges;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n      parts[i] = sel;\n    }\n    return parts\n  },\n  replaceSelection: function(code, collapse, origin) {\n    var dup = [];\n    for (var i = 0; i < this.sel.ranges.length; i++)\n      { dup[i] = code; }\n    this.replaceSelections(dup, collapse, origin || \"+input\");\n  },\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\n    var this$1 = this;\n\n    var changes = [], sel = this.sel;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range$$1 = sel.ranges[i];\n      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n    }\n    var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n      { makeChange(this$1, changes[i$1]); }\n    if (newSel) { setSelectionReplaceHistory(this, newSel); }\n    else if (this.cm) { ensureCursorVisible(this.cm); }\n  }),\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n  setExtending: function(val) {this.extend = val;},\n  getExtending: function() {return this.extend},\n\n  historySize: function() {\n    var hist = this.history, done = 0, undone = 0;\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n    return {undo: done, redo: undone}\n  },\n  clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n  markClean: function() {\n    this.cleanGeneration = this.changeGeneration(true);\n  },\n  changeGeneration: function(forceSplit) {\n    if (forceSplit)\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n    return this.history.generation\n  },\n  isClean: function (gen) {\n    return this.history.generation == (gen || this.cleanGeneration)\n  },\n\n  getHistory: function() {\n    return {done: copyHistoryArray(this.history.done),\n            undone: copyHistoryArray(this.history.undone)}\n  },\n  setHistory: function(histData) {\n    var hist = this.history = new History(this.history.maxGeneration);\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n  },\n\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\n    return changeLine(this, line, \"gutter\", function (line) {\n      var markers = line.gutterMarkers || (line.gutterMarkers = {});\n      markers[gutterID] = value;\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n      return true\n    })\n  }),\n\n  clearGutter: docMethodOp(function(gutterID) {\n    var this$1 = this;\n\n    this.iter(function (line) {\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n        changeLine(this$1, line, \"gutter\", function () {\n          line.gutterMarkers[gutterID] = null;\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n          return true\n        });\n      }\n    });\n  }),\n\n  lineInfo: function(line) {\n    var n;\n    if (typeof line == \"number\") {\n      if (!isLine(this, line)) { return null }\n      n = line;\n      line = getLine(this, line);\n      if (!line) { return null }\n    } else {\n      n = lineNo(line);\n      if (n == null) { return null }\n    }\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n            widgets: line.widgets}\n  },\n\n  addLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      if (!line[prop]) { line[prop] = cls; }\n      else if (classTest(cls).test(line[prop])) { return false }\n      else { line[prop] += \" \" + cls; }\n      return true\n    })\n  }),\n  removeLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      var cur = line[prop];\n      if (!cur) { return false }\n      else if (cls == null) { line[prop] = null; }\n      else {\n        var found = cur.match(classTest(cls));\n        if (!found) { return false }\n        var end = found.index + found[0].length;\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n      }\n      return true\n    })\n  }),\n\n  addLineWidget: docMethodOp(function(handle, node, options) {\n    return addLineWidget(this, handle, node, options)\n  }),\n  removeLineWidget: function(widget) { widget.clear(); },\n\n  markText: function(from, to, options) {\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n  },\n  setBookmark: function(pos, options) {\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                    insertLeft: options && options.insertLeft,\n                    clearWhenEmpty: false, shared: options && options.shared,\n                    handleMouseEvents: options && options.handleMouseEvents};\n    pos = clipPos(this, pos);\n    return markText(this, pos, pos, realOpts, \"bookmark\")\n  },\n  findMarksAt: function(pos) {\n    pos = clipPos(this, pos);\n    var markers = [], spans = getLine(this, pos.line).markedSpans;\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if ((span.from == null || span.from <= pos.ch) &&\n          (span.to == null || span.to >= pos.ch))\n        { markers.push(span.marker.parent || span.marker); }\n    } }\n    return markers\n  },\n  findMarks: function(from, to, filter) {\n    from = clipPos(this, from); to = clipPos(this, to);\n    var found = [], lineNo$$1 = from.line;\n    this.iter(from.line, to.line + 1, function (line) {\n      var spans = line.markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; i++) {\n        var span = spans[i];\n        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\n              span.from == null && lineNo$$1 != from.line ||\n              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\n            (!filter || filter(span.marker)))\n          { found.push(span.marker.parent || span.marker); }\n      } }\n      ++lineNo$$1;\n    });\n    return found\n  },\n  getAllMarks: function() {\n    var markers = [];\n    this.iter(function (line) {\n      var sps = line.markedSpans;\n      if (sps) { for (var i = 0; i < sps.length; ++i)\n        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n    });\n    return markers\n  },\n\n  posFromIndex: function(off) {\n    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n    this.iter(function (line) {\n      var sz = line.text.length + sepSize;\n      if (sz > off) { ch = off; return true }\n      off -= sz;\n      ++lineNo$$1;\n    });\n    return clipPos(this, Pos(lineNo$$1, ch))\n  },\n  indexFromPos: function (coords) {\n    coords = clipPos(this, coords);\n    var index = coords.ch;\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\n    var sepSize = this.lineSeparator().length;\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n      index += line.text.length + sepSize;\n    });\n    return index\n  },\n\n  copy: function(copyHistory) {\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                      this.modeOption, this.first, this.lineSep, this.direction);\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n    doc.sel = this.sel;\n    doc.extend = false;\n    if (copyHistory) {\n      doc.history.undoDepth = this.history.undoDepth;\n      doc.setHistory(this.getHistory());\n    }\n    return doc\n  },\n\n  linkedDoc: function(options) {\n    if (!options) { options = {}; }\n    var from = this.first, to = this.first + this.size;\n    if (options.from != null && options.from > from) { from = options.from; }\n    if (options.to != null && options.to < to) { to = options.to; }\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n    if (options.sharedHist) { copy.history = this.history\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n    copySharedMarkers(copy, findSharedMarkers(this));\n    return copy\n  },\n  unlinkDoc: function(other) {\n    var this$1 = this;\n\n    if (other instanceof CodeMirror$1) { other = other.doc; }\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n      var link = this$1.linked[i];\n      if (link.doc != other) { continue }\n      this$1.linked.splice(i, 1);\n      other.unlinkDoc(this$1);\n      detachSharedMarkers(findSharedMarkers(this$1));\n      break\n    } }\n    // If the histories were shared, split them again\n    if (other.history == this.history) {\n      var splitIds = [other.id];\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n      other.history = new History(null);\n      other.history.done = copyHistoryArray(this.history.done, splitIds);\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n    }\n  },\n  iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n  getMode: function() {return this.mode},\n  getEditor: function() {return this.cm},\n\n  splitLines: function(str) {\n    if (this.lineSep) { return str.split(this.lineSep) }\n    return splitLinesAuto(str)\n  },\n  lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n  setDirection: docMethodOp(function (dir) {\n    if (dir != \"rtl\") { dir = \"ltr\"; }\n    if (dir == this.direction) { return }\n    this.direction = dir;\n    this.iter(function (line) { return line.order = null; });\n    if (this.cm) { directionChanged(this.cm); }\n  })\n});\n\n// Public alias.\nDoc.prototype.eachLine = Doc.prototype.iter;\n\n// Kludge to work around strange IE behavior where it'll sometimes\n// re-fire a series of drag-related events right after the drop (#1551)\nvar lastDrop = 0;\n\nfunction onDrop(e) {\n  var cm = this;\n  clearDragCursor(cm);\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n    { return }\n  e_preventDefault(e);\n  if (ie) { lastDrop = +new Date; }\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n  if (!pos || cm.isReadOnly()) { return }\n  // Might be a file drop, in which case we simply extract the text\n  // and insert it.\n  if (files && files.length && window.FileReader && window.File) {\n    var n = files.length, text = Array(n), read = 0;\n    var loadFile = function (file, i) {\n      if (cm.options.allowDropFileTypes &&\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n        { return }\n\n      var reader = new FileReader;\n      reader.onload = operation(cm, function () {\n        var content = reader.result;\n        if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n        text[i] = content;\n        if (++read == n) {\n          pos = clipPos(cm.doc, pos);\n          var change = {from: pos, to: pos,\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                        origin: \"paste\"};\n          makeChange(cm.doc, change);\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n        }\n      });\n      reader.readAsText(file);\n    };\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\n  } else { // Normal drop\n    // Don't do a replace if the drop happened inside of the selected text.\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n      cm.state.draggingText(e);\n      // Ensure the editor is re-focused\n      setTimeout(function () { return cm.display.input.focus(); }, 20);\n      return\n    }\n    try {\n      var text$1 = e.dataTransfer.getData(\"Text\");\n      if (text$1) {\n        var selected;\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\n          { selected = cm.listSelections(); }\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n          { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n        cm.replaceSelection(text$1, \"around\", \"paste\");\n        cm.display.input.focus();\n      }\n    }\n    catch(e){}\n  }\n}\n\nfunction onDragStart(cm, e) {\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n  e.dataTransfer.setData(\"Text\", cm.getSelection());\n  e.dataTransfer.effectAllowed = \"copyMove\";\n\n  // Use dummy image instead of default browsers image.\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n  if (e.dataTransfer.setDragImage && !safari) {\n    var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n    img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    if (presto) {\n      img.width = img.height = 1;\n      cm.display.wrapper.appendChild(img);\n      // Force a relayout, or Opera won't use our image for some obscure reason\n      img._top = img.offsetTop;\n    }\n    e.dataTransfer.setDragImage(img, 0, 0);\n    if (presto) { img.parentNode.removeChild(img); }\n  }\n}\n\nfunction onDragOver(cm, e) {\n  var pos = posFromMouse(cm, e);\n  if (!pos) { return }\n  var frag = document.createDocumentFragment();\n  drawSelectionCursor(cm, pos, frag);\n  if (!cm.display.dragCursor) {\n    cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n  }\n  removeChildrenAndAdd(cm.display.dragCursor, frag);\n}\n\nfunction clearDragCursor(cm) {\n  if (cm.display.dragCursor) {\n    cm.display.lineSpace.removeChild(cm.display.dragCursor);\n    cm.display.dragCursor = null;\n  }\n}\n\n// These must be handled carefully, because naively registering a\n// handler for each editor will cause the editors to never be\n// garbage collected.\n\nfunction forEachCodeMirror(f) {\n  if (!document.body.getElementsByClassName) { return }\n  var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n  for (var i = 0; i < byClass.length; i++) {\n    var cm = byClass[i].CodeMirror;\n    if (cm) { f(cm); }\n  }\n}\n\nvar globalsRegistered = false;\nfunction ensureGlobalHandlers() {\n  if (globalsRegistered) { return }\n  registerGlobalHandlers();\n  globalsRegistered = true;\n}\nfunction registerGlobalHandlers() {\n  // When the window resizes, we need to refresh active editors.\n  var resizeTimer;\n  on(window, \"resize\", function () {\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n      resizeTimer = null;\n      forEachCodeMirror(onResize);\n    }, 100); }\n  });\n  // When the window loses focus, we want to show the editor as blurred\n  on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n}\n// Called when the window resizes\nfunction onResize(cm) {\n  var d = cm.display;\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n    { return }\n  // Might be a text scaling operation, clear size caches.\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n  d.scrollbarsClipped = false;\n  cm.setSize();\n}\n\nvar keyNames = {\n  3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n  106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n};\n\n// Number keys\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n// Alphabetic keys\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n// Function keys\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\nvar keyMap = {};\n\nkeyMap.basic = {\n  \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n  \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n  \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n  \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n  \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n  \"Esc\": \"singleSelection\"\n};\n// Note that the save and find-related commands aren't defined by\n// default. User code or addons can define them. Unknown commands\n// are simply ignored.\nkeyMap.pcDefault = {\n  \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n  \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n  \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n  \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n  \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n  \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n  \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n  fallthrough: \"basic\"\n};\n// Very basic readline/emacs-style bindings, which are standard on Mac.\nkeyMap.emacsy = {\n  \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n  \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n  \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n  \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n  \"Ctrl-O\": \"openLine\"\n};\nkeyMap.macDefault = {\n  \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n  \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n  \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n  \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n  \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n  \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n  \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n  fallthrough: [\"basic\", \"emacsy\"]\n};\nkeyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n// KEYMAP DISPATCH\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/);\n  name = parts[parts.length - 1];\n  var alt, ctrl, shift, cmd;\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n  }\n  if (alt) { name = \"Alt-\" + name; }\n  if (ctrl) { name = \"Ctrl-\" + name; }\n  if (cmd) { name = \"Cmd-\" + name; }\n  if (shift) { name = \"Shift-\" + name; }\n  return name\n}\n\n// This is a kludge to keep keymaps mostly working as raw objects\n// (backwards compatibility) while at the same time support features\n// like normalization and multi-stroke key bindings. It compiles a\n// new normalized keymap, and then updates the old object to reflect\n// this.\nfunction normalizeKeyMap(keymap) {\n  var copy = {};\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n    var value = keymap[keyname];\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n    if (value == \"...\") { delete keymap[keyname]; continue }\n\n    var keys = map(keyname.split(\" \"), normalizeKeyName);\n    for (var i = 0; i < keys.length; i++) {\n      var val = (void 0), name = (void 0);\n      if (i == keys.length - 1) {\n        name = keys.join(\" \");\n        val = value;\n      } else {\n        name = keys.slice(0, i + 1).join(\" \");\n        val = \"...\";\n      }\n      var prev = copy[name];\n      if (!prev) { copy[name] = val; }\n      else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n    }\n    delete keymap[keyname];\n  } }\n  for (var prop in copy) { keymap[prop] = copy[prop]; }\n  return keymap\n}\n\nfunction lookupKey(key, map$$1, handle, context) {\n  map$$1 = getKeyMap(map$$1);\n  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n  if (found === false) { return \"nothing\" }\n  if (found === \"...\") { return \"multi\" }\n  if (found != null && handle(found)) { return \"handled\" }\n\n  if (map$$1.fallthrough) {\n    if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n      { return lookupKey(key, map$$1.fallthrough, handle, context) }\n    for (var i = 0; i < map$$1.fallthrough.length; i++) {\n      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n      if (result) { return result }\n    }\n  }\n}\n\n// Modifier key presses don't count as 'real' key presses for the\n// purpose of keymap fallthrough.\nfunction isModifierKey(value) {\n  var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n  return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n}\n\n// Look up the name of a key as indicated by an event object.\nfunction keyName(event, noShift) {\n  if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n  var base = keyNames[event.keyCode], name = base;\n  if (name == null || event.altGraphKey) { return false }\n  if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\n  if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n  return name\n}\n\nfunction getKeyMap(val) {\n  return typeof val == \"string\" ? keyMap[val] : val\n}\n\n// Helper for deleting text near the selection(s), used to implement\n// backspace, delete, and similar functionality.\nfunction deleteNearSelection(cm, compute) {\n  var ranges = cm.doc.sel.ranges, kill = [];\n  // Build up a set of ranges to kill first, merging overlapping\n  // ranges.\n  for (var i = 0; i < ranges.length; i++) {\n    var toKill = compute(ranges[i]);\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n      var replaced = kill.pop();\n      if (cmp(replaced.from, toKill.from) < 0) {\n        toKill.from = replaced.from;\n        break\n      }\n    }\n    kill.push(toKill);\n  }\n  // Next, remove those actual ranges.\n  runInOp(cm, function () {\n    for (var i = kill.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n    ensureCursorVisible(cm);\n  });\n}\n\n// Commands are parameter-less actions that can be performed on an\n// editor, mostly used for keybindings.\nvar commands = {\n  selectAll: selectAll,\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n    if (range.empty()) {\n      var len = getLine(cm.doc, range.head.line).text.length;\n      if (range.head.ch == len && range.head.line < cm.lastLine())\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n      else\n        { return {from: range.head, to: Pos(range.head.line, len)} }\n    } else {\n      return {from: range.from(), to: range.to()}\n    }\n  }); },\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0),\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n  }); }); },\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0), to: range.from()\n  }); }); },\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n    return {from: leftPos, to: range.from()}\n  }); },\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n    return {from: range.from(), to: rightPos }\n  }); },\n  undo: function (cm) { return cm.undo(); },\n  redo: function (cm) { return cm.redo(); },\n  undoSelection: function (cm) { return cm.undoSelection(); },\n  redoSelection: function (cm) { return cm.redoSelection(); },\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n    {origin: \"+move\", bias: -1}\n  ); },\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: 0, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n    if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n    return pos\n  }, sel_move); },\n  goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n  goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n  goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n  goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n  goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n  goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n  goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n  goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n  goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n  goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n  goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n  goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n  delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n  delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n  delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n  delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n  delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n  indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n  indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n  indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n  insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n  insertSoftTab: function (cm) {\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n    for (var i = 0; i < ranges.length; i++) {\n      var pos = ranges[i].from();\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n      spaces.push(spaceStr(tabSize - col % tabSize));\n    }\n    cm.replaceSelections(spaces);\n  },\n  defaultTab: function (cm) {\n    if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n    else { cm.execCommand(\"insertTab\"); }\n  },\n  // Swap the two chars left and right of each selection's head.\n  // Move cursor behind the two swapped characters afterwards.\n  //\n  // Doesn't consider line feeds a character.\n  // Doesn't scan more than one line above to find a character.\n  // Doesn't do anything on an empty line.\n  // Doesn't do anything with non-empty selections.\n  transposeChars: function (cm) { return runInOp(cm, function () {\n    var ranges = cm.listSelections(), newSel = [];\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) { continue }\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n      if (line) {\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n        if (cur.ch > 0) {\n          cur = new Pos(cur.line, cur.ch + 1);\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                          Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n        } else if (cur.line > cm.doc.first) {\n          var prev = getLine(cm.doc, cur.line - 1).text;\n          if (prev) {\n            cur = new Pos(cur.line, 1);\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                            prev.charAt(prev.length - 1),\n                            Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n          }\n        }\n      }\n      newSel.push(new Range(cur, cur));\n    }\n    cm.setSelections(newSel);\n  }); },\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\n    var sels = cm.listSelections();\n    for (var i = sels.length - 1; i >= 0; i--)\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n    sels = cm.listSelections();\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\n      { cm.indentLine(sels[i$1].from().line, null, true); }\n    ensureCursorVisible(cm);\n  }); },\n  openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n};\n\n\nfunction lineStart(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLine(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, visual, lineN, 1)\n}\nfunction lineEnd(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLineEnd(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, line, lineN, -1)\n}\nfunction lineStartSmart(cm, pos) {\n  var start = lineStart(cm, pos.line);\n  var line = getLine(cm.doc, start.line);\n  var order = getOrder(line, cm.doc.direction);\n  if (!order || order[0].level == 0) {\n    var firstNonWS = Math.max(0, line.text.search(/\\S/));\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n  }\n  return start\n}\n\n// Run a handler that was bound to a key.\nfunction doHandleBinding(cm, bound, dropShift) {\n  if (typeof bound == \"string\") {\n    bound = commands[bound];\n    if (!bound) { return false }\n  }\n  // Ensure previous input has been read, so that the handler sees a\n  // consistent view of the document\n  cm.display.input.ensurePolled();\n  var prevShift = cm.display.shift, done = false;\n  try {\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n    if (dropShift) { cm.display.shift = false; }\n    done = bound(cm) != Pass;\n  } finally {\n    cm.display.shift = prevShift;\n    cm.state.suppressEdits = false;\n  }\n  return done\n}\n\nfunction lookupKeyForEditor(cm, name, handle) {\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n    if (result) { return result }\n  }\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n    || lookupKey(name, cm.options.keyMap, handle, cm)\n}\n\nvar stopSeq = new Delayed;\nfunction dispatchKey(cm, name, e, handle) {\n  var seq = cm.state.keySeq;\n  if (seq) {\n    if (isModifierKey(name)) { return \"handled\" }\n    stopSeq.set(50, function () {\n      if (cm.state.keySeq == seq) {\n        cm.state.keySeq = null;\n        cm.display.input.reset();\n      }\n    });\n    name = seq + \" \" + name;\n  }\n  var result = lookupKeyForEditor(cm, name, handle);\n\n  if (result == \"multi\")\n    { cm.state.keySeq = name; }\n  if (result == \"handled\")\n    { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n  if (result == \"handled\" || result == \"multi\") {\n    e_preventDefault(e);\n    restartBlink(cm);\n  }\n\n  if (seq && !result && /\\'$/.test(name)) {\n    e_preventDefault(e);\n    return true\n  }\n  return !!result\n}\n\n// Handle a key from the keydown event.\nfunction handleKeyBinding(cm, e) {\n  var name = keyName(e, true);\n  if (!name) { return false }\n\n  if (e.shiftKey && !cm.state.keySeq) {\n    // First try to resolve full name (including 'Shift-'). Failing\n    // that, see if there is a cursor-motion command (starting with\n    // 'go') bound to the keyname without 'Shift-'.\n    return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n        || dispatchKey(cm, name, e, function (b) {\n             if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n               { return doHandleBinding(cm, b) }\n           })\n  } else {\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n  }\n}\n\n// Handle a key from the keypress event\nfunction handleCharBinding(cm, e, ch) {\n  return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n}\n\nvar lastStoppedKey = null;\nfunction onKeyDown(e) {\n  var cm = this;\n  cm.curOp.focus = activeElt();\n  if (signalDOMEvent(cm, e)) { return }\n  // IE does strange things with escape.\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n  var code = e.keyCode;\n  cm.display.shift = code == 16 || e.shiftKey;\n  var handled = handleKeyBinding(cm, e);\n  if (presto) {\n    lastStoppedKey = handled ? code : null;\n    // Opera has no cut event... we try to at least catch the key combo\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n      { cm.replaceSelection(\"\", null, \"cut\"); }\n  }\n\n  // Turn mouse into crosshair when Alt is held on Mac.\n  if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n    { showCrossHair(cm); }\n}\n\nfunction showCrossHair(cm) {\n  var lineDiv = cm.display.lineDiv;\n  addClass(lineDiv, \"CodeMirror-crosshair\");\n\n  function up(e) {\n    if (e.keyCode == 18 || !e.altKey) {\n      rmClass(lineDiv, \"CodeMirror-crosshair\");\n      off(document, \"keyup\", up);\n      off(document, \"mouseover\", up);\n    }\n  }\n  on(document, \"keyup\", up);\n  on(document, \"mouseover\", up);\n}\n\nfunction onKeyUp(e) {\n  if (e.keyCode == 16) { this.doc.sel.shift = false; }\n  signalDOMEvent(this, e);\n}\n\nfunction onKeyPress(e) {\n  var cm = this;\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n  var keyCode = e.keyCode, charCode = e.charCode;\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n  // Some browsers fire keypress events for backspace\n  if (ch == \"\\x08\") { return }\n  if (handleCharBinding(cm, e, ch)) { return }\n  cm.display.input.onKeyPress(e);\n}\n\n// A mouse down can be a single click, double click, triple click,\n// start of selection drag, start of text drag, new cursor\n// (ctrl-click), rectangle drag (alt-drag), or xwin\n// middle-click-paste. Or it might be a click on something we should\n// not interfere with, such as a scrollbar or widget.\nfunction onMouseDown(e) {\n  var cm = this, display = cm.display;\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n  display.input.ensurePolled();\n  display.shift = e.shiftKey;\n\n  if (eventInWidget(display, e)) {\n    if (!webkit) {\n      // Briefly turn off draggability, to allow widgets to do\n      // normal dragging things.\n      display.scroller.draggable = false;\n      setTimeout(function () { return display.scroller.draggable = true; }, 100);\n    }\n    return\n  }\n  if (clickInGutter(cm, e)) { return }\n  var start = posFromMouse(cm, e);\n  window.focus();\n\n  switch (e_button(e)) {\n  case 1:\n    // #3261: make sure, that we're not starting a second selection\n    if (cm.state.selectingText)\n      { cm.state.selectingText(e); }\n    else if (start)\n      { leftButtonDown(cm, e, start); }\n    else if (e_target(e) == display.scroller)\n      { e_preventDefault(e); }\n    break\n  case 2:\n    if (webkit) { cm.state.lastMiddleDown = +new Date; }\n    if (start) { extendSelection(cm.doc, start); }\n    setTimeout(function () { return display.input.focus(); }, 20);\n    e_preventDefault(e);\n    break\n  case 3:\n    if (captureRightClick) { onContextMenu(cm, e); }\n    else { delayBlurEvent(cm); }\n    break\n  }\n}\n\nvar lastClick;\nvar lastDoubleClick;\nfunction leftButtonDown(cm, e, start) {\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n  else { cm.curOp.focus = activeElt(); }\n\n  var now = +new Date, type;\n  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n    type = \"triple\";\n  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n    type = \"double\";\n    lastDoubleClick = {time: now, pos: start};\n  } else {\n    type = \"single\";\n    lastClick = {time: now, pos: start};\n  }\n\n  var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n      type == \"single\" && (contained = sel.contains(start)) > -1 &&\n      (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n      (cmp(contained.to(), start) > 0 || start.xRel < 0))\n    { leftButtonStartDrag(cm, e, start, modifier); }\n  else\n    { leftButtonSelect(cm, e, start, type, modifier); }\n}\n\n// Start a text drag. When it ends, see if any dragging actually\n// happen, and treat as a click if it didn't.\nfunction leftButtonStartDrag(cm, e, start, modifier) {\n  var display = cm.display, moved = false;\n  var dragEnd = operation(cm, function (e) {\n    if (webkit) { display.scroller.draggable = false; }\n    cm.state.draggingText = false;\n    off(document, \"mouseup\", dragEnd);\n    off(document, \"mousemove\", mouseMove);\n    off(display.scroller, \"dragstart\", dragStart);\n    off(display.scroller, \"drop\", dragEnd);\n    if (!moved) {\n      e_preventDefault(e);\n      if (!modifier)\n        { extendSelection(cm.doc, start); }\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n      if (webkit || ie && ie_version == 9)\n        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }\n      else\n        { display.input.focus(); }\n    }\n  });\n  var mouseMove = function(e2) {\n    moved = moved || Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) >= 10;\n  };\n  var dragStart = function () { return moved = true; };\n  // Let the drag handler handle this.\n  if (webkit) { display.scroller.draggable = true; }\n  cm.state.draggingText = dragEnd;\n  dragEnd.copy = mac ? e.altKey : e.ctrlKey;\n  // IE's approach to draggable\n  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  on(document, \"mouseup\", dragEnd);\n  on(document, \"mousemove\", mouseMove);\n  on(display.scroller, \"dragstart\", dragStart);\n  on(display.scroller, \"drop\", dragEnd);\n\n  delayBlurEvent(cm);\n  setTimeout(function () { return display.input.focus(); }, 20);\n}\n\n// Normal selection, as opposed to text dragging.\nfunction leftButtonSelect(cm, e, start, type, addNew) {\n  var display = cm.display, doc = cm.doc;\n  e_preventDefault(e);\n\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n  if (addNew && !e.shiftKey) {\n    ourIndex = doc.sel.contains(start);\n    if (ourIndex > -1)\n      { ourRange = ranges[ourIndex]; }\n    else\n      { ourRange = new Range(start, start); }\n  } else {\n    ourRange = doc.sel.primary();\n    ourIndex = doc.sel.primIndex;\n  }\n\n  if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\n    type = \"rect\";\n    if (!addNew) { ourRange = new Range(start, start); }\n    start = posFromMouse(cm, e, true, true);\n    ourIndex = -1;\n  } else if (type == \"double\") {\n    var word = cm.findWordAt(start);\n    if (cm.display.shift || doc.extend)\n      { ourRange = extendRange(doc, ourRange, word.anchor, word.head); }\n    else\n      { ourRange = word; }\n  } else if (type == \"triple\") {\n    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n    if (cm.display.shift || doc.extend)\n      { ourRange = extendRange(doc, ourRange, line.anchor, line.head); }\n    else\n      { ourRange = line; }\n  } else {\n    ourRange = extendRange(doc, ourRange, start);\n  }\n\n  if (!addNew) {\n    ourIndex = 0;\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n    startSel = doc.sel;\n  } else if (ourIndex == -1) {\n    ourIndex = ranges.length;\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                 {scroll: false, origin: \"*mouse\"});\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                 {scroll: false, origin: \"*mouse\"});\n    startSel = doc.sel;\n  } else {\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n  }\n\n  var lastPos = start;\n  function extendTo(pos) {\n    if (cmp(lastPos, pos) == 0) { return }\n    lastPos = pos;\n\n    if (type == \"rect\") {\n      var ranges = [], tabSize = cm.options.tabSize;\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n           line <= end; line++) {\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n        if (left == right)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n        else if (text.length > leftPos)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n      }\n      if (!ranges.length) { ranges.push(new Range(start, start)); }\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                   {origin: \"*mouse\", scroll: false});\n      cm.scrollIntoView(pos);\n    } else {\n      var oldRange = ourRange;\n      var anchor = oldRange.anchor, head = pos;\n      if (type != \"single\") {\n        var range$$1;\n        if (type == \"double\")\n          { range$$1 = cm.findWordAt(pos); }\n        else\n          { range$$1 = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))); }\n        if (cmp(range$$1.anchor, anchor) > 0) {\n          head = range$$1.head;\n          anchor = minPos(oldRange.from(), range$$1.anchor);\n        } else {\n          head = range$$1.anchor;\n          anchor = maxPos(oldRange.to(), range$$1.head);\n        }\n      }\n      var ranges$1 = startSel.ranges.slice(0);\n      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head);\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);\n    }\n  }\n\n  var editorSize = display.wrapper.getBoundingClientRect();\n  // Used to ensure timeout re-tries don't fire when another extend\n  // happened in the meantime (clearTimeout isn't reliable -- at\n  // least on Chrome, the timeouts still happen even when cleared,\n  // if the clear happens after their scheduled firing time).\n  var counter = 0;\n\n  function extend(e) {\n    var curCount = ++counter;\n    var cur = posFromMouse(cm, e, true, type == \"rect\");\n    if (!cur) { return }\n    if (cmp(cur, lastPos) != 0) {\n      cm.curOp.focus = activeElt();\n      extendTo(cur);\n      var visible = visibleLines(display, doc);\n      if (cur.line >= visible.to || cur.line < visible.from)\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n    } else {\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n      if (outside) { setTimeout(operation(cm, function () {\n        if (counter != curCount) { return }\n        display.scroller.scrollTop += outside;\n        extend(e);\n      }), 50); }\n    }\n  }\n\n  function done(e) {\n    cm.state.selectingText = false;\n    counter = Infinity;\n    e_preventDefault(e);\n    display.input.focus();\n    off(document, \"mousemove\", move);\n    off(document, \"mouseup\", up);\n    doc.history.lastSelOrigin = null;\n  }\n\n  var move = operation(cm, function (e) {\n    if (!e_button(e)) { done(e); }\n    else { extend(e); }\n  });\n  var up = operation(cm, done);\n  cm.state.selectingText = up;\n  on(document, \"mousemove\", move);\n  on(document, \"mouseup\", up);\n}\n\n\n// Determines whether an event happened in the gutter, and fires the\n// handlers for the corresponding event.\nfunction gutterEvent(cm, e, type, prevent) {\n  var mX, mY;\n  try { mX = e.clientX; mY = e.clientY; }\n  catch(e) { return false }\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n  if (prevent) { e_preventDefault(e); }\n\n  var display = cm.display;\n  var lineBox = display.lineDiv.getBoundingClientRect();\n\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n  mY -= lineBox.top - display.viewOffset;\n\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\n    var g = display.gutters.childNodes[i];\n    if (g && g.getBoundingClientRect().right >= mX) {\n      var line = lineAtHeight(cm.doc, mY);\n      var gutter = cm.options.gutters[i];\n      signal(cm, type, cm, line, gutter, e);\n      return e_defaultPrevented(e)\n    }\n  }\n}\n\nfunction clickInGutter(cm, e) {\n  return gutterEvent(cm, e, \"gutterClick\", true)\n}\n\n// CONTEXT MENU HANDLING\n\n// To make the context menu work, we need to briefly unhide the\n// textarea (making it as unobtrusive as possible) to let the\n// right-click take effect on it.\nfunction onContextMenu(cm, e) {\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n  if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n  cm.display.input.onContextMenu(e);\n}\n\nfunction contextMenuInGutter(cm, e) {\n  if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n  return gutterEvent(cm, e, \"gutterContextMenu\", false)\n}\n\nfunction themeChanged(cm) {\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n    cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n  clearCaches(cm);\n}\n\nvar Init = {toString: function(){return \"CodeMirror.Init\"}};\n\nvar defaults = {};\nvar optionHandlers = {};\n\nfunction defineOptions(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) { optionHandlers[name] =\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n  }\n\n  CodeMirror.defineOption = option;\n\n  // Passed to option handlers when there is no old value.\n  CodeMirror.Init = Init;\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n  option(\"mode\", null, function (cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function (cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function (cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) { return }\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function (line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) { break }\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n  });\n  option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != Init) { cm.refresh(); }\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n  }, true);\n  option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function (cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function (cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != Init && getKeyMap(old);\n    if (prev && prev.detach) { prev.detach(cm, next); }\n    if (next.attach) { next.attach(cm, prev || null); }\n  });\n  option(\"extraKeys\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function (cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n  option(\"scrollbarStyle\", \"native\", function (cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n\n  option(\"readOnly\", false, function (cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n    }\n    cm.display.input.readOnlyChanged(val);\n  });\n  option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function (cm, val) {\n    if (!val) { cm.display.input.resetPosition(); }\n  });\n\n  option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n  option(\"autofocus\", null);\n  option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n}\n\nfunction guttersChanged(cm) {\n  updateGutters(cm);\n  regChange(cm);\n  alignHorizontally(cm);\n}\n\nfunction dragDropChanged(cm, value, old) {\n  var wasOn = old && old != Init;\n  if (!value != !wasOn) {\n    var funcs = cm.display.dragFunctions;\n    var toggle = value ? on : off;\n    toggle(cm.display.scroller, \"dragstart\", funcs.start);\n    toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n    toggle(cm.display.scroller, \"dragover\", funcs.over);\n    toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n    toggle(cm.display.scroller, \"drop\", funcs.drop);\n  }\n}\n\nfunction wrappingChanged(cm) {\n  if (cm.options.lineWrapping) {\n    addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    cm.display.sizer.style.minWidth = \"\";\n    cm.display.sizerWidth = null;\n  } else {\n    rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    findMaxLine(cm);\n  }\n  estimateLineHeights(cm);\n  regChange(cm);\n  clearCaches(cm);\n  setTimeout(function () { return updateScrollbars(cm); }, 100);\n}\n\n// A CodeMirror instance represents an editor. This is the object\n// that user code is usually dealing with.\n\nfunction CodeMirror$1(place, options) {\n  var this$1 = this;\n\n  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }\n\n  this.options = options = options ? copyObj(options) : {};\n  // Determine effective options based on given values and defaults.\n  copyObj(defaults, options, false);\n  setGuttersForLineNumbers(options);\n\n  var doc = options.value;\n  if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n  this.doc = doc;\n\n  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);\n  var display = this.display = new Display(place, doc, input);\n  display.wrapper.CodeMirror = this;\n  updateGutters(this);\n  themeChanged(this);\n  if (options.lineWrapping)\n    { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n  initScrollbars(this);\n\n  this.state = {\n    keyMaps: [],  // stores maps added by addKeyMap\n    overlays: [], // highlighting overlays, as added by addOverlay\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n    overwrite: false,\n    delayingBlurEvent: false,\n    focused: false,\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n    selectingText: false,\n    draggingText: false,\n    highlight: new Delayed(), // stores highlight worker timeout\n    keySeq: null,  // Unfinished key sequence\n    specialChars: null\n  };\n\n  if (options.autofocus && !mobile) { display.input.focus(); }\n\n  // Override magic textarea content restore that IE sometimes does\n  // on our hidden textarea on reload\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n  registerEventHandlers(this);\n  ensureGlobalHandlers();\n\n  startOperation(this);\n  this.curOp.forceUpdate = true;\n  attachDoc(this, doc);\n\n  if ((options.autofocus && !mobile) || this.hasFocus())\n    { setTimeout(bind(onFocus, this), 20); }\n  else\n    { onBlur(this); }\n\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n    { optionHandlers[opt](this$1, options[opt], Init); } }\n  maybeUpdateLineNumberWidth(this);\n  if (options.finishInit) { options.finishInit(this); }\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\n  endOperation(this);\n  // Suppress optimizelegibility in Webkit, since it breaks text\n  // measuring on line wrapping boundaries.\n  if (webkit && options.lineWrapping &&\n      getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n    { display.lineDiv.style.textRendering = \"auto\"; }\n}\n\n// The default configuration options.\nCodeMirror$1.defaults = defaults;\n// Functions to run when options are changed.\nCodeMirror$1.optionHandlers = optionHandlers;\n\n// Attach the necessary event handlers when initializing the editor\nfunction registerEventHandlers(cm) {\n  var d = cm.display;\n  on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n  // Older IE's will not fire a second mousedown for a double click\n  if (ie && ie_version < 11)\n    { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n      if (signalDOMEvent(cm, e)) { return }\n      var pos = posFromMouse(cm, e);\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n      e_preventDefault(e);\n      var word = cm.findWordAt(pos);\n      extendSelection(cm.doc, word.anchor, word.head);\n    })); }\n  else\n    { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n  // Some browsers fire contextmenu *after* opening the menu, at\n  // which point we can't mess with it anymore. Context menu is\n  // handled in onMouseDown for these browsers.\n  if (!captureRightClick) { on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); }); }\n\n  // Used to suppress mouse event handling when a touch happens\n  var touchFinished, prevTouch = {end: 0};\n  function finishTouch() {\n    if (d.activeTouch) {\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n      prevTouch = d.activeTouch;\n      prevTouch.end = +new Date;\n    }\n  }\n  function isMouseLikeTouchEvent(e) {\n    if (e.touches.length != 1) { return false }\n    var touch = e.touches[0];\n    return touch.radiusX <= 1 && touch.radiusY <= 1\n  }\n  function farAway(touch, other) {\n    if (other.left == null) { return true }\n    var dx = other.left - touch.left, dy = other.top - touch.top;\n    return dx * dx + dy * dy > 20 * 20\n  }\n  on(d.scroller, \"touchstart\", function (e) {\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\n      d.input.ensurePolled();\n      clearTimeout(touchFinished);\n      var now = +new Date;\n      d.activeTouch = {start: now, moved: false,\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null};\n      if (e.touches.length == 1) {\n        d.activeTouch.left = e.touches[0].pageX;\n        d.activeTouch.top = e.touches[0].pageY;\n      }\n    }\n  });\n  on(d.scroller, \"touchmove\", function () {\n    if (d.activeTouch) { d.activeTouch.moved = true; }\n  });\n  on(d.scroller, \"touchend\", function (e) {\n    var touch = d.activeTouch;\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\n        !touch.moved && new Date - touch.start < 300) {\n      var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n        { range = new Range(pos, pos); }\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n        { range = cm.findWordAt(pos); }\n      else // Triple tap\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n      cm.setSelection(range.anchor, range.head);\n      cm.focus();\n      e_preventDefault(e);\n    }\n    finishTouch();\n  });\n  on(d.scroller, \"touchcancel\", finishTouch);\n\n  // Sync scrolling between fake scrollbars and real scrollable\n  // area, ensure viewport is updated when scrolling.\n  on(d.scroller, \"scroll\", function () {\n    if (d.scroller.clientHeight) {\n      updateScrollTop(cm, d.scroller.scrollTop);\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\n      signal(cm, \"scroll\", cm);\n    }\n  });\n\n  // Listen to wheel events in order to try and update the viewport on time.\n  on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n  on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n  // Prevent wrapper from ever scrolling\n  on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n  d.dragFunctions = {\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n    start: function (e) { return onDragStart(cm, e); },\n    drop: operation(cm, onDrop),\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n  };\n\n  var inp = d.input.getField();\n  on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n  on(inp, \"keydown\", operation(cm, onKeyDown));\n  on(inp, \"keypress\", operation(cm, onKeyPress));\n  on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n  on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n}\n\nvar initHooks = [];\nCodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };\n\n// Indent the given line. The how parameter can be \"smart\",\n// \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n// (typically set to true for forced single-line indents), empty\n// lines are not indented, and places where the mode returns Pass\n// are left alone.\nfunction indentLine(cm, n, how, aggressive) {\n  var doc = cm.doc, state;\n  if (how == null) { how = \"add\"; }\n  if (how == \"smart\") {\n    // Fall back to \"prev\" when the mode doesn't have an indentation\n    // method.\n    if (!doc.mode.indent) { how = \"prev\"; }\n    else { state = getStateBefore(cm, n); }\n  }\n\n  var tabSize = cm.options.tabSize;\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n  if (line.stateAfter) { line.stateAfter = null; }\n  var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n  if (!aggressive && !/\\S/.test(line.text)) {\n    indentation = 0;\n    how = \"not\";\n  } else if (how == \"smart\") {\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n    if (indentation == Pass || indentation > 150) {\n      if (!aggressive) { return }\n      how = \"prev\";\n    }\n  }\n  if (how == \"prev\") {\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n    else { indentation = 0; }\n  } else if (how == \"add\") {\n    indentation = curSpace + cm.options.indentUnit;\n  } else if (how == \"subtract\") {\n    indentation = curSpace - cm.options.indentUnit;\n  } else if (typeof how == \"number\") {\n    indentation = curSpace + how;\n  }\n  indentation = Math.max(0, indentation);\n\n  var indentString = \"\", pos = 0;\n  if (cm.options.indentWithTabs)\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n  if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n  if (indentString != curSpaceString) {\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    line.stateAfter = null;\n    return true\n  } else {\n    // Ensure that, if the cursor was in the whitespace at the start\n    // of the line, it is moved to the end of that space.\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n      var range = doc.sel.ranges[i$1];\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\n        var pos$1 = Pos(n, curSpaceString.length);\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n        break\n      }\n    }\n  }\n}\n\n// This will be set to a {lineWise: bool, text: [string]} object, so\n// that, when pasting, we know what kind of selections the copied\n// text was made out of.\nvar lastCopied = null;\n\nfunction setLastCopied(newLastCopied) {\n  lastCopied = newLastCopied;\n}\n\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\n  var doc = cm.doc;\n  cm.display.shift = false;\n  if (!sel) { sel = doc.sel; }\n\n  var paste = cm.state.pasteIncoming || origin == \"paste\";\n  var textLines = splitLinesAuto(inserted), multiPaste = null;\n  // When pasing N lines into N selections, insert one line per selection\n  if (paste && sel.ranges.length > 1) {\n    if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n      if (sel.ranges.length % lastCopied.text.length == 0) {\n        multiPaste = [];\n        for (var i = 0; i < lastCopied.text.length; i++)\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n      }\n    } else if (textLines.length == sel.ranges.length) {\n      multiPaste = map(textLines, function (l) { return [l]; });\n    }\n  }\n\n  var updateInput;\n  // Normal behavior is to insert the new text into every selection\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n    var range$$1 = sel.ranges[i$1];\n    var from = range$$1.from(), to = range$$1.to();\n    if (range$$1.empty()) {\n      if (deleted && deleted > 0) // Handle deletion\n        { from = Pos(from.line, from.ch - deleted); }\n      else if (cm.state.overwrite && !paste) // Handle overwrite\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n        { from = to = Pos(from.line, 0); }\n    }\n    updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                       origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n    makeChange(cm.doc, changeEvent);\n    signalLater(cm, \"inputRead\", cm, changeEvent);\n  }\n  if (inserted && !paste)\n    { triggerElectric(cm, inserted); }\n\n  ensureCursorVisible(cm);\n  cm.curOp.updateInput = updateInput;\n  cm.curOp.typing = true;\n  cm.state.pasteIncoming = cm.state.cutIncoming = false;\n}\n\nfunction handlePaste(e, cm) {\n  var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n  if (pasted) {\n    e.preventDefault();\n    if (!cm.isReadOnly() && !cm.options.disableInput)\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n    return true\n  }\n}\n\nfunction triggerElectric(cm, inserted) {\n  // When an 'electric' character is inserted, immediately trigger a reindent\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n  var sel = cm.doc.sel;\n\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\n    var range$$1 = sel.ranges[i];\n    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n    var mode = cm.getModeAt(range$$1.head);\n    var indented = false;\n    if (mode.electricChars) {\n      for (var j = 0; j < mode.electricChars.length; j++)\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n          indented = indentLine(cm, range$$1.head.line, \"smart\");\n          break\n        } }\n    } else if (mode.electricInput) {\n      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n        { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n    }\n    if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n  }\n}\n\nfunction copyableRanges(cm) {\n  var text = [], ranges = [];\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n    var line = cm.doc.sel.ranges[i].head.line;\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n    ranges.push(lineRange);\n    text.push(cm.getRange(lineRange.anchor, lineRange.head));\n  }\n  return {text: text, ranges: ranges}\n}\n\nfunction disableBrowserMagic(field, spellcheck) {\n  field.setAttribute(\"autocorrect\", \"off\");\n  field.setAttribute(\"autocapitalize\", \"off\");\n  field.setAttribute(\"spellcheck\", !!spellcheck);\n}\n\nfunction hiddenTextarea() {\n  var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n  var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n  // The textarea is kept positioned near the cursor to prevent the\n  // fact that it'll be scrolled into view on input from scrolling\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\n  // very slow. So make the area wide instead.\n  if (webkit) { te.style.width = \"1000px\"; }\n  else { te.setAttribute(\"wrap\", \"off\"); }\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\n  if (ios) { te.style.border = \"1px solid black\"; }\n  disableBrowserMagic(te);\n  return div\n}\n\n// The publicly visible API. Note that methodOp(f) means\n// 'wrap f in an operation, performed on its `this` parameter'.\n\n// This is not the complete set of editor methods. Most of the\n// methods defined on the Doc type are also injected into\n// CodeMirror.prototype, for backwards compatibility and\n// convenience.\n\nvar addEditorMethods = function(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  var helpers = CodeMirror.helpers = {};\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") { return }\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        { operation(this, optionHandlers[option])(this, value, old); }\n      signal(this, \"optionChange\", this, option);\n    },\n\n    getOption: function(option) {return this.options[option]},\n    getDoc: function() {return this.doc},\n\n    addKeyMap: function(map$$1, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n    },\n    removeKeyMap: function(map$$1) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n          maps.splice(i, 1);\n          return true\n        } }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n      insertSorted(this.state.overlays,\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                    priority: (options && options.priority) || 0},\n                   function (overlay) { return overlay.priority; });\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var this$1 = this;\n\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this$1.state.modeGen++;\n          regChange(this$1);\n          return\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n        else { dir = dir ? \"add\" : \"subtract\"; }\n      }\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n    }),\n    indentSelection: methodOp(function(how) {\n      var this$1 = this;\n\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range$$1 = ranges[i];\n        if (!range$$1.empty()) {\n          var from = range$$1.from(), to = range$$1.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            { indentLine(this$1, j, how); }\n          var newRanges = this$1.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n        } else if (range$$1.head.line > end) {\n          indentLine(this$1, range$$1.head.line, how, true);\n          end = range$$1.head.line;\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise)\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true)\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) { type = styles[2]; }\n      else { for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n        else { type = styles[mid * 2 + 2]; break }\n      } }\n      var cut = type ? type.indexOf(\"overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) { return mode }\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0]\n    },\n\n    getHelpers: function(pos, type) {\n      var this$1 = this;\n\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) { return found }\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) { found.push(help[mode[type]]); }\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) { found.push(val); }\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n        var cur = help._global[i$1];\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\n          { found.push(cur.val); }\n      }\n      return found\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise)\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range$$1 = this.doc.sel.primary();\n      if (start == null) { pos = range$$1.head; }\n      else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n      else { pos = start ? range$$1.from() : range$$1.to(); }\n      return cursorCoords(this, pos, mode || \"page\")\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top)\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\n    },\n    heightAtLine: function(line, mode, includeWidgets) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) { line = this.doc.first; }\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display) },\n    defaultCharWidth: function() { return charWidth(this.display) },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          { top = pos.top - node.offsetHeight; }\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          { top = pos.bottom; }\n        if (left + node.offsetWidth > hspace)\n          { left = hspace - node.offsetWidth; }\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") { left = 0; }\n        else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        { return commands[cmd].call(null, this) }\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var this$1 = this;\n\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        cur = findPosH(this$1.doc, cur, dir, unit, visually);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      this.extendSelectionsBy(function (range$$1) {\n        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n        else\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        { doc.replaceSelection(\"\", null, \"+delete\"); }\n      else\n        { deleteNearSelection(this, function (range$$1) {\n          var other = findPosH(doc, range$$1.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n        }); }\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var this$1 = this;\n\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        var coords = cursorCoords(this$1, cur, \"div\");\n        if (x == null) { x = coords.left; }\n        else { coords.left = x; }\n        cur = findPosV(this$1, coords, dir, unit);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      var doc = this.doc, goals = [];\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function (range$$1) {\n        if (collapse)\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n        var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n        goals.push(headPos.left);\n        var pos = findPosV(this$1, headPos, dir, unit);\n        if (unit == \"page\" && range$$1 == doc.sel.primary())\n          { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n        return pos\n      }, sel_move);\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n        { doc.sel.ranges[i].goalColumn = goals[i]; } }\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function (ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n          : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n        while (start > 0 && check(line.charAt(start - 1))) { --start; }\n        while (end < line.length && check(line.charAt(end))) { ++end; }\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) { return }\n      if (this.state.overwrite = !this.state.overwrite)\n        { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n      else\n        { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n    },\n\n    scrollIntoView: methodOp(function(range$$1, margin) {\n      if (range$$1 == null) {\n        range$$1 = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) { margin = this.options.cursorScrollMargin; }\n      } else if (typeof range$$1 == \"number\") {\n        range$$1 = {from: Pos(range$$1, 0), to: null};\n      } else if (range$$1.from == null) {\n        range$$1 = {from: range$$1, to: null};\n      }\n      if (!range$$1.to) { range$$1.to = range$$1.from; }\n      range$$1.margin = margin || 0;\n\n      if (range$$1.from.line != null) {\n        scrollToRange(this, range$$1);\n      } else {\n        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var this$1 = this;\n\n      var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n      if (width != null) { this.display.wrapper.style.width = interpret(width); }\n      if (height != null) { this.display.wrapper.style.height = interpret(height); }\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n      var lineNo$$1 = this.display.viewFrom;\n      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n        ++lineNo$$1;\n      });\n      this.curOp.forceUpdate = true;\n      signal(this, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f)},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        { estimateLineHeights(this); }\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old\n    }),\n\n    getInputField: function(){return this.display.input.getField()},\n    getWrapperElement: function(){return this.display.wrapper},\n    getScrollerElement: function(){return this.display.scroller},\n    getGutterElement: function(){return this.display.gutters}\n  };\n  eventMixin(CodeMirror);\n\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n};\n\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\n// right), unit can be \"char\", \"column\" (like char, but doesn't\n// cross line boundaries), \"word\" (across next word), or \"group\" (to\n// the start of next group of word or non-word-non-whitespace\n// chars). The visually param controls whether, in right-to-left\n// text, direction 1 means to move towards the next index in the\n// string, or towards the character to the right of the current\n// position. The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosH(doc, pos, dir, unit, visually) {\n  var oldPos = pos;\n  var origDir = dir;\n  var lineObj = getLine(doc, pos.line);\n  function findNextLine() {\n    var l = pos.line + dir;\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\n    pos = new Pos(l, pos.ch, pos.sticky);\n    return lineObj = getLine(doc, l)\n  }\n  function moveOnce(boundToLine) {\n    var next;\n    if (visually) {\n      next = moveVisually(doc.cm, lineObj, pos, dir);\n    } else {\n      next = moveLogically(lineObj, pos, dir);\n    }\n    if (next == null) {\n      if (!boundToLine && findNextLine())\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n      else\n        { return false }\n    } else {\n      pos = next;\n    }\n    return true\n  }\n\n  if (unit == \"char\") {\n    moveOnce();\n  } else if (unit == \"column\") {\n    moveOnce(true);\n  } else if (unit == \"word\" || unit == \"group\") {\n    var sawType = null, group = unit == \"group\";\n    var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n    for (var first = true;; first = false) {\n      if (dir < 0 && !moveOnce(!first)) { break }\n      var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n      var type = isWordChar(cur, helper) ? \"w\"\n        : group && cur == \"\\n\" ? \"n\"\n        : !group || /\\s/.test(cur) ? null\n        : \"p\";\n      if (group && !first && !type) { type = \"s\"; }\n      if (sawType && sawType != type) {\n        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n        break\n      }\n\n      if (type) { sawType = type; }\n      if (dir > 0 && !moveOnce(!first)) { break }\n    }\n  }\n  var result = skipAtomic(doc, pos, oldPos, origDir, true);\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n  return result\n}\n\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\n// \"page\" or \"line\". The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosV(cm, pos, dir, unit) {\n  var doc = cm.doc, x = pos.left, y;\n  if (unit == \"page\") {\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n  } else if (unit == \"line\") {\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n  }\n  var target;\n  for (;;) {\n    target = coordsChar(cm, x, y);\n    if (!target.outside) { break }\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n    y += dir * 5;\n  }\n  return target\n}\n\n// CONTENTEDITABLE INPUT STYLE\n\nvar ContentEditableInput = function(cm) {\n  this.cm = cm;\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n  this.polling = new Delayed();\n  this.composing = null;\n  this.gracePeriod = false;\n  this.readDOMTimeout = null;\n};\n\nContentEditableInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = input.cm;\n  var div = input.div = display.lineDiv;\n  disableBrowserMagic(div, cm.options.spellcheck);\n\n  on(div, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n  });\n\n  on(div, \"compositionstart\", function (e) {\n    this$1.composing = {data: e.data, done: false};\n  });\n  on(div, \"compositionupdate\", function (e) {\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n  });\n  on(div, \"compositionend\", function (e) {\n    if (this$1.composing) {\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n      this$1.composing.done = true;\n    }\n  });\n\n  on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n  on(div, \"input\", function () {\n    if (!this$1.composing) { this$1.readFromDOMSoon(); }\n  });\n\n  function onCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n      if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.operation(function () {\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n          cm.replaceSelection(\"\", null, \"cut\");\n        });\n      }\n    }\n    if (e.clipboardData) {\n      e.clipboardData.clearData();\n      var content = lastCopied.text.join(\"\\n\");\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\n      e.clipboardData.setData(\"Text\", content);\n      if (e.clipboardData.getData(\"Text\") == content) {\n        e.preventDefault();\n        return\n      }\n    }\n    // Old-fashioned briefly-focus-a-textarea hack\n    var kludge = hiddenTextarea(), te = kludge.firstChild;\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n    te.value = lastCopied.text.join(\"\\n\");\n    var hadFocus = document.activeElement;\n    selectInput(te);\n    setTimeout(function () {\n      cm.display.lineSpace.removeChild(kludge);\n      hadFocus.focus();\n      if (hadFocus == div) { input.showPrimarySelection(); }\n    }, 50);\n  }\n  on(div, \"copy\", onCopyCut);\n  on(div, \"cut\", onCopyCut);\n};\n\nContentEditableInput.prototype.prepareSelection = function () {\n  var result = prepareSelection(this.cm, false);\n  result.focus = this.cm.state.focused;\n  return result\n};\n\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n  if (!info || !this.cm.display.view.length) { return }\n  if (info.focus || takeFocus) { this.showPrimarySelection(); }\n  this.showMultipleSelections(info);\n};\n\nContentEditableInput.prototype.showPrimarySelection = function () {\n  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n  var from = prim.from(), to = prim.to();\n\n  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n      cmp(minPos(curAnchor, curFocus), from) == 0 &&\n      cmp(maxPos(curAnchor, curFocus), to) == 0)\n    { return }\n\n  var view = cm.display.view;\n  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n      {node: view[0].measure.map[2], offset: 0};\n  var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n  if (!end) {\n    var measure = view[view.length - 1].measure;\n    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n  }\n\n  if (!start || !end) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var old = sel.rangeCount && sel.getRangeAt(0), rng;\n  try { rng = range(start.node, start.offset, end.offset, end.node); }\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n  if (rng) {\n    if (!gecko && cm.state.focused) {\n      sel.collapse(start.node, start.offset);\n      if (!rng.collapsed) {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n    } else {\n      sel.removeAllRanges();\n      sel.addRange(rng);\n    }\n    if (old && sel.anchorNode == null) { sel.addRange(old); }\n    else if (gecko) { this.startGracePeriod(); }\n  }\n  this.rememberSelection();\n};\n\nContentEditableInput.prototype.startGracePeriod = function () {\n    var this$1 = this;\n\n  clearTimeout(this.gracePeriod);\n  this.gracePeriod = setTimeout(function () {\n    this$1.gracePeriod = false;\n    if (this$1.selectionChanged())\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n  }, 20);\n};\n\nContentEditableInput.prototype.showMultipleSelections = function (info) {\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n};\n\nContentEditableInput.prototype.rememberSelection = function () {\n  var sel = window.getSelection();\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n};\n\nContentEditableInput.prototype.selectionInEditor = function () {\n  var sel = window.getSelection();\n  if (!sel.rangeCount) { return false }\n  var node = sel.getRangeAt(0).commonAncestorContainer;\n  return contains(this.div, node)\n};\n\nContentEditableInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\") {\n    if (!this.selectionInEditor())\n      { this.showSelection(this.prepareSelection(), true); }\n    this.div.focus();\n  }\n};\nContentEditableInput.prototype.blur = function () { this.div.blur(); };\nContentEditableInput.prototype.getField = function () { return this.div };\n\nContentEditableInput.prototype.supportsTouch = function () { return true };\n\nContentEditableInput.prototype.receivedFocus = function () {\n  var input = this;\n  if (this.selectionInEditor())\n    { this.pollSelection(); }\n  else\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n  function poll() {\n    if (input.cm.state.focused) {\n      input.pollSelection();\n      input.polling.set(input.cm.options.pollInterval, poll);\n    }\n  }\n  this.polling.set(this.cm.options.pollInterval, poll);\n};\n\nContentEditableInput.prototype.selectionChanged = function () {\n  var sel = window.getSelection();\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n};\n\nContentEditableInput.prototype.pollSelection = function () {\n  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n  var sel = window.getSelection(), cm = this.cm;\n  // On Android Chrome (version 56, at least), backspacing into an\n  // uneditable block element will put the cursor in that element,\n  // and then, because it's not editable, hide the virtual keyboard.\n  // Because Android doesn't allow us to actually detect backspace\n  // presses in a sane way, this code checks for when that happens\n  // and simulates a backspace press in this case.\n  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n    this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n    this.blur();\n    this.focus();\n    return\n  }\n  if (this.composing) { return }\n  this.rememberSelection();\n  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (anchor && head) { runInOp(cm, function () {\n    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n  }); }\n};\n\nContentEditableInput.prototype.pollContent = function () {\n  if (this.readDOMTimeout != null) {\n    clearTimeout(this.readDOMTimeout);\n    this.readDOMTimeout = null;\n  }\n\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n  var from = sel.from(), to = sel.to();\n  if (from.ch == 0 && from.line > cm.firstLine())\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n    { to = Pos(to.line + 1, 0); }\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n  var fromIndex, fromLine, fromNode;\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n    fromLine = lineNo(display.view[0].line);\n    fromNode = display.view[0].node;\n  } else {\n    fromLine = lineNo(display.view[fromIndex].line);\n    fromNode = display.view[fromIndex - 1].node.nextSibling;\n  }\n  var toIndex = findViewIndex(cm, to.line);\n  var toLine, toNode;\n  if (toIndex == display.view.length - 1) {\n    toLine = display.viewTo - 1;\n    toNode = display.lineDiv.lastChild;\n  } else {\n    toLine = lineNo(display.view[toIndex + 1].line) - 1;\n    toNode = display.view[toIndex + 1].node.previousSibling;\n  }\n\n  if (!fromNode) { return false }\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n  while (newText.length > 1 && oldText.length > 1) {\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n    else { break }\n  }\n\n  var cutFront = 0, cutEnd = 0;\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n    { ++cutFront; }\n  var newBot = lst(newText), oldBot = lst(oldText);\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0));\n  while (cutEnd < maxCutEnd &&\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n    { ++cutEnd; }\n  // Try to move start of change to start of selection if ambiguous\n  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n    while (cutFront && cutFront > from.ch &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n      cutFront--;\n      cutEnd++;\n    }\n  }\n\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n  newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n  var chFrom = Pos(fromLine, cutFront);\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n    replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n    return true\n  }\n};\n\nContentEditableInput.prototype.ensurePolled = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.reset = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.forceCompositionEnd = function () {\n  if (!this.composing) { return }\n  clearTimeout(this.readDOMTimeout);\n  this.composing = null;\n  this.updateFromDOM();\n  this.div.blur();\n  this.div.focus();\n};\nContentEditableInput.prototype.readFromDOMSoon = function () {\n    var this$1 = this;\n\n  if (this.readDOMTimeout != null) { return }\n  this.readDOMTimeout = setTimeout(function () {\n    this$1.readDOMTimeout = null;\n    if (this$1.composing) {\n      if (this$1.composing.done) { this$1.composing = null; }\n      else { return }\n    }\n    this$1.updateFromDOM();\n  }, 80);\n};\n\nContentEditableInput.prototype.updateFromDOM = function () {\n    var this$1 = this;\n\n  if (this.cm.isReadOnly() || !this.pollContent())\n    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n};\n\nContentEditableInput.prototype.setUneditable = function (node) {\n  node.contentEditable = \"false\";\n};\n\nContentEditableInput.prototype.onKeyPress = function (e) {\n  if (e.charCode == 0) { return }\n  e.preventDefault();\n  if (!this.cm.isReadOnly())\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n};\n\nContentEditableInput.prototype.readOnlyChanged = function (val) {\n  this.div.contentEditable = String(val != \"nocursor\");\n};\n\nContentEditableInput.prototype.onContextMenu = function () {};\nContentEditableInput.prototype.resetPosition = function () {};\n\nContentEditableInput.prototype.needsContentAttribute = true;\n\nfunction posToDOM(cm, pos) {\n  var view = findViewForLine(cm, pos.line);\n  if (!view || view.hidden) { return null }\n  var line = getLine(cm.doc, pos.line);\n  var info = mapFromLineView(view, line, pos.line);\n\n  var order = getOrder(line, cm.doc.direction), side = \"left\";\n  if (order) {\n    var partPos = getBidiPartAt(order, pos.ch);\n    side = partPos % 2 ? \"right\" : \"left\";\n  }\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n  result.offset = result.collapse == \"right\" ? result.end : result.start;\n  return result\n}\n\nfunction isInGutter(node) {\n  for (var scan = node; scan; scan = scan.parentNode)\n    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n  return false\n}\n\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\n  var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n  function close() {\n    if (closing) {\n      text += lineSep;\n      closing = false;\n    }\n  }\n  function addText(str) {\n    if (str) {\n      close();\n      text += str;\n    }\n  }\n  function walk(node) {\n    if (node.nodeType == 1) {\n      var cmText = node.getAttribute(\"cm-text\");\n      if (cmText != null) {\n        addText(cmText || node.textContent.replace(/\\u200b/g, \"\"));\n        return\n      }\n      var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n      if (markerID) {\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n        if (found.length && (range$$1 = found[0].find()))\n          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n        return\n      }\n      if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);\n      if (isBlock) { close(); }\n      for (var i = 0; i < node.childNodes.length; i++)\n        { walk(node.childNodes[i]); }\n      if (isBlock) { closing = true; }\n    } else if (node.nodeType == 3) {\n      addText(node.nodeValue);\n    }\n  }\n  for (;;) {\n    walk(from);\n    if (from == to) { break }\n    from = from.nextSibling;\n  }\n  return text\n}\n\nfunction domToPos(cm, node, offset) {\n  var lineNode;\n  if (node == cm.display.lineDiv) {\n    lineNode = cm.display.lineDiv.childNodes[offset];\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n    node = null; offset = 0;\n  } else {\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n    }\n  }\n  for (var i = 0; i < cm.display.view.length; i++) {\n    var lineView = cm.display.view[i];\n    if (lineView.node == lineNode)\n      { return locateNodeInLineView(lineView, node, offset) }\n  }\n}\n\nfunction locateNodeInLineView(lineView, node, offset) {\n  var wrapper = lineView.text.firstChild, bad = false;\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n  if (node == wrapper) {\n    bad = true;\n    node = wrapper.childNodes[offset];\n    offset = 0;\n    if (!node) {\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n      return badPos(Pos(lineNo(line), line.text.length), bad)\n    }\n  }\n\n  var textNode = node.nodeType == 3 ? node : null, topNode = node;\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n    textNode = node.firstChild;\n    if (offset) { offset = textNode.nodeValue.length; }\n  }\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n  var measure = lineView.measure, maps = measure.maps;\n\n  function find(textNode, topNode, offset) {\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\n      var map$$1 = i < 0 ? measure.map : maps[i];\n      for (var j = 0; j < map$$1.length; j += 3) {\n        var curNode = map$$1[j + 2];\n        if (curNode == textNode || curNode == topNode) {\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n          var ch = map$$1[j] + offset;\n          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n          return Pos(line, ch)\n        }\n      }\n    }\n  }\n  var found = find(textNode, topNode, offset);\n  if (found) { return badPos(found, bad) }\n\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n    found = find(after, after.firstChild, 0);\n    if (found)\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\n    else\n      { dist += after.textContent.length; }\n  }\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n    found = find(before, before.firstChild, -1);\n    if (found)\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n    else\n      { dist$1 += before.textContent.length; }\n  }\n}\n\n// TEXTAREA INPUT STYLE\n\nvar TextareaInput = function(cm) {\n  this.cm = cm;\n  // See input.poll and input.reset\n  this.prevInput = \"\";\n\n  // Flag that indicates whether we expect input to appear real soon\n  // now (after some event like 'keypress' or 'input') and are\n  // polling intensively.\n  this.pollingFast = false;\n  // Self-resetting timeout for the poller\n  this.polling = new Delayed();\n  // Tracks when input.reset has punted to just putting a short\n  // string into the textarea instead of the full selection.\n  this.inaccurateSelection = false;\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n  this.hasSelection = false;\n  this.composing = null;\n};\n\nTextareaInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = this.cm;\n\n  // Wraps and hides input textarea\n  var div = this.wrapper = hiddenTextarea();\n  // The semihidden textarea that is focused when the editor is\n  // focused, and receives input.\n  var te = this.textarea = div.firstChild;\n  display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n  if (ios) { te.style.width = \"0px\"; }\n\n  on(te, \"input\", function () {\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n    input.poll();\n  });\n\n  on(te, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n    cm.state.pasteIncoming = true;\n    input.fastPoll();\n  });\n\n  function prepareCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n      if (input.inaccurateSelection) {\n        input.prevInput = \"\";\n        input.inaccurateSelection = false;\n        te.value = lastCopied.text.join(\"\\n\");\n        selectInput(te);\n      }\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.setSelections(ranges.ranges, null, sel_dontScroll);\n      } else {\n        input.prevInput = \"\";\n        te.value = ranges.text.join(\"\\n\");\n        selectInput(te);\n      }\n    }\n    if (e.type == \"cut\") { cm.state.cutIncoming = true; }\n  }\n  on(te, \"cut\", prepareCopyCut);\n  on(te, \"copy\", prepareCopyCut);\n\n  on(display.scroller, \"paste\", function (e) {\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n    cm.state.pasteIncoming = true;\n    input.focus();\n  });\n\n  // Prevent normal selection in the editor (we handle our own)\n  on(display.lineSpace, \"selectstart\", function (e) {\n    if (!eventInWidget(display, e)) { e_preventDefault(e); }\n  });\n\n  on(te, \"compositionstart\", function () {\n    var start = cm.getCursor(\"from\");\n    if (input.composing) { input.composing.range.clear(); }\n    input.composing = {\n      start: start,\n      range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n    };\n  });\n  on(te, \"compositionend\", function () {\n    if (input.composing) {\n      input.poll();\n      input.composing.range.clear();\n      input.composing = null;\n    }\n  });\n};\n\nTextareaInput.prototype.prepareSelection = function () {\n  // Redraw the selection and/or cursor\n  var cm = this.cm, display = cm.display, doc = cm.doc;\n  var result = prepareSelection(cm);\n\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\n  if (cm.options.moveInputWithCursor) {\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                        headPos.top + lineOff.top - wrapOff.top));\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                         headPos.left + lineOff.left - wrapOff.left));\n  }\n\n  return result\n};\n\nTextareaInput.prototype.showSelection = function (drawn) {\n  var cm = this.cm, display = cm.display;\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n  if (drawn.teTop != null) {\n    this.wrapper.style.top = drawn.teTop + \"px\";\n    this.wrapper.style.left = drawn.teLeft + \"px\";\n  }\n};\n\n// Reset the input to correspond to the selection (or to be empty,\n// when not typing and nothing is selected)\nTextareaInput.prototype.reset = function (typing) {\n  if (this.contextMenuPending || this.composing) { return }\n  var minimal, selected, cm = this.cm, doc = cm.doc;\n  if (cm.somethingSelected()) {\n    this.prevInput = \"\";\n    var range$$1 = doc.sel.primary();\n    minimal = hasCopyEvent &&\n      (range$$1.to().line - range$$1.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n    var content = minimal ? \"-\" : selected || cm.getSelection();\n    this.textarea.value = content;\n    if (cm.state.focused) { selectInput(this.textarea); }\n    if (ie && ie_version >= 9) { this.hasSelection = content; }\n  } else if (!typing) {\n    this.prevInput = this.textarea.value = \"\";\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n  }\n  this.inaccurateSelection = minimal;\n};\n\nTextareaInput.prototype.getField = function () { return this.textarea };\n\nTextareaInput.prototype.supportsTouch = function () { return false };\n\nTextareaInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n    try { this.textarea.focus(); }\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n  }\n};\n\nTextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\nTextareaInput.prototype.resetPosition = function () {\n  this.wrapper.style.top = this.wrapper.style.left = 0;\n};\n\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n// Poll for input changes, using the normal rate of polling. This\n// runs as long as the editor is focused.\nTextareaInput.prototype.slowPoll = function () {\n    var this$1 = this;\n\n  if (this.pollingFast) { return }\n  this.polling.set(this.cm.options.pollInterval, function () {\n    this$1.poll();\n    if (this$1.cm.state.focused) { this$1.slowPoll(); }\n  });\n};\n\n// When an event has just come in that is likely to add or change\n// something in the input textarea, we poll faster, to ensure that\n// the change appears on the screen quickly.\nTextareaInput.prototype.fastPoll = function () {\n  var missed = false, input = this;\n  input.pollingFast = true;\n  function p() {\n    var changed = input.poll();\n    if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n    else {input.pollingFast = false; input.slowPoll();}\n  }\n  input.polling.set(20, p);\n};\n\n// Read input from the textarea, and update the document to match.\n// When something is selected, it is present in the textarea, and\n// selected (unless it is huge, in which case a placeholder is\n// used). When nothing is selected, the cursor sits after previously\n// seen text (can be empty), which is stored in prevInput (we must\n// not reset the textarea when typing, because that breaks IME).\nTextareaInput.prototype.poll = function () {\n    var this$1 = this;\n\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n  // Since this is called a *lot*, try to bail out as cheaply as\n  // possible when it is clear that nothing happened. hasSelection\n  // will be the case when there is a lot of text in the textarea,\n  // in which case reading its value would be expensive.\n  if (this.contextMenuPending || !cm.state.focused ||\n      (hasSelection(input) && !prevInput && !this.composing) ||\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n    { return false }\n\n  var text = input.value;\n  // If nothing changed, bail.\n  if (text == prevInput && !cm.somethingSelected()) { return false }\n  // Work around nonsensical selection resetting in IE9/10, and\n  // inexplicable appearance of private area unicode characters on\n  // some key combos in Mac (#2689).\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\n      mac && /[\\uf700-\\uf7ff]/.test(text)) {\n    cm.display.input.reset();\n    return false\n  }\n\n  if (cm.doc.sel == cm.display.selForContextMenu) {\n    var first = text.charCodeAt(0);\n    if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n  }\n  // Find the part of the input that is actually new\n  var same = 0, l = Math.min(prevInput.length, text.length);\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n  runInOp(cm, function () {\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\n                   null, this$1.composing ? \"*compose\" : null);\n\n    // Don't leave long text in the textarea, since it makes further polling slow\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n    else { this$1.prevInput = text; }\n\n    if (this$1.composing) {\n      this$1.composing.range.clear();\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                         {className: \"CodeMirror-composing\"});\n    }\n  });\n  return true\n};\n\nTextareaInput.prototype.ensurePolled = function () {\n  if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n};\n\nTextareaInput.prototype.onKeyPress = function () {\n  if (ie && ie_version >= 9) { this.hasSelection = null; }\n  this.fastPoll();\n};\n\nTextareaInput.prototype.onContextMenu = function (e) {\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n  if (!pos || presto) { return } // Opera is difficult.\n\n  // Reset the current text selection only if the click is done outside of the selection\n  // and 'resetSelectionOnContextMenu' option is true.\n  var reset = cm.options.resetSelectionOnContextMenu;\n  if (reset && cm.doc.sel.contains(pos) == -1)\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n  input.wrapper.style.cssText = \"position: absolute\";\n  var wrapperBox = input.wrapper.getBoundingClientRect();\n  te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n  var oldScrollY;\n  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n  display.input.focus();\n  if (webkit) { window.scrollTo(null, oldScrollY); }\n  display.input.reset();\n  // Adds \"Select all\" to context menu in FF\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n  input.contextMenuPending = true;\n  display.selForContextMenu = cm.doc.sel;\n  clearTimeout(display.detectingSelectAll);\n\n  // Select-all will be greyed out if there's nothing to select, so\n  // this adds a zero-width space so that we can later check whether\n  // it got selected.\n  function prepareSelectAllHack() {\n    if (te.selectionStart != null) {\n      var selected = cm.somethingSelected();\n      var extval = \"\\u200b\" + (selected ? te.value : \"\");\n      te.value = \"\\u21da\"; // Used to catch context-menu undo\n      te.value = extval;\n      input.prevInput = selected ? \"\" : \"\\u200b\";\n      te.selectionStart = 1; te.selectionEnd = extval.length;\n      // Re-set this, in case some other handler touched the\n      // selection in the meantime.\n      display.selForContextMenu = cm.doc.sel;\n    }\n  }\n  function rehide() {\n    input.contextMenuPending = false;\n    input.wrapper.style.cssText = oldWrapperCSS;\n    te.style.cssText = oldCSS;\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n    // Try to detect the user choosing select-all\n    if (te.selectionStart != null) {\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n      var i = 0, poll = function () {\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n            te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n          operation(cm, selectAll)(cm);\n        } else if (i++ < 10) {\n          display.detectingSelectAll = setTimeout(poll, 500);\n        } else {\n          display.selForContextMenu = null;\n          display.input.reset();\n        }\n      };\n      display.detectingSelectAll = setTimeout(poll, 200);\n    }\n  }\n\n  if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n  if (captureRightClick) {\n    e_stop(e);\n    var mouseup = function () {\n      off(window, \"mouseup\", mouseup);\n      setTimeout(rehide, 20);\n    };\n    on(window, \"mouseup\", mouseup);\n  } else {\n    setTimeout(rehide, 50);\n  }\n};\n\nTextareaInput.prototype.readOnlyChanged = function (val) {\n  if (!val) { this.reset(); }\n};\n\nTextareaInput.prototype.setUneditable = function () {};\n\nTextareaInput.prototype.needsContentAttribute = false;\n\nfunction fromTextArea(textarea, options) {\n  options = options ? copyObj(options) : {};\n  options.value = textarea.value;\n  if (!options.tabindex && textarea.tabIndex)\n    { options.tabindex = textarea.tabIndex; }\n  if (!options.placeholder && textarea.placeholder)\n    { options.placeholder = textarea.placeholder; }\n  // Set autofocus to true if this textarea is focused, or if it has\n  // autofocus and no other element is focused.\n  if (options.autofocus == null) {\n    var hasFocus = activeElt();\n    options.autofocus = hasFocus == textarea ||\n      textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n  }\n\n  function save() {textarea.value = cm.getValue();}\n\n  var realSubmit;\n  if (textarea.form) {\n    on(textarea.form, \"submit\", save);\n    // Deplorable hack to make the submit method do the right thing.\n    if (!options.leaveSubmitMethodAlone) {\n      var form = textarea.form;\n      realSubmit = form.submit;\n      try {\n        var wrappedSubmit = form.submit = function () {\n          save();\n          form.submit = realSubmit;\n          form.submit();\n          form.submit = wrappedSubmit;\n        };\n      } catch(e) {}\n    }\n  }\n\n  options.finishInit = function (cm) {\n    cm.save = save;\n    cm.getTextArea = function () { return textarea; };\n    cm.toTextArea = function () {\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          { textarea.form.submit = realSubmit; }\n      }\n    };\n  };\n\n  textarea.style.display = \"none\";\n  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n    options);\n  return cm\n}\n\nfunction addLegacyProps(CodeMirror) {\n  CodeMirror.off = off;\n  CodeMirror.on = on;\n  CodeMirror.wheelEventPixels = wheelEventPixels;\n  CodeMirror.Doc = Doc;\n  CodeMirror.splitLines = splitLinesAuto;\n  CodeMirror.countColumn = countColumn;\n  CodeMirror.findColumn = findColumn;\n  CodeMirror.isWordChar = isWordCharBasic;\n  CodeMirror.Pass = Pass;\n  CodeMirror.signal = signal;\n  CodeMirror.Line = Line;\n  CodeMirror.changeEnd = changeEnd;\n  CodeMirror.scrollbarModel = scrollbarModel;\n  CodeMirror.Pos = Pos;\n  CodeMirror.cmpPos = cmp;\n  CodeMirror.modes = modes;\n  CodeMirror.mimeModes = mimeModes;\n  CodeMirror.resolveMode = resolveMode;\n  CodeMirror.getMode = getMode;\n  CodeMirror.modeExtensions = modeExtensions;\n  CodeMirror.extendMode = extendMode;\n  CodeMirror.copyState = copyState;\n  CodeMirror.startState = startState;\n  CodeMirror.innerMode = innerMode;\n  CodeMirror.commands = commands;\n  CodeMirror.keyMap = keyMap;\n  CodeMirror.keyName = keyName;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.normalizeKeyMap = normalizeKeyMap;\n  CodeMirror.StringStream = StringStream;\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  CodeMirror.TextMarker = TextMarker;\n  CodeMirror.LineWidget = LineWidget;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.addClass = addClass;\n  CodeMirror.contains = contains;\n  CodeMirror.rmClass = rmClass;\n  CodeMirror.keyNames = keyNames;\n}\n\n// EDITOR CONSTRUCTOR\n\ndefineOptions(CodeMirror$1);\n\naddEditorMethods(CodeMirror$1);\n\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\nvar dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n  { CodeMirror$1.prototype[prop] = (function(method) {\n    return function() {return method.apply(this.doc, arguments)}\n  })(Doc.prototype[prop]); } }\n\neventMixin(Doc);\n\n// INPUT HANDLING\n\nCodeMirror$1.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n// MODE DEFINITION AND QUERYING\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nCodeMirror$1.defineMode = function(name/*, mode, */) {\n  if (!CodeMirror$1.defaults.mode && name != \"null\") { CodeMirror$1.defaults.mode = name; }\n  defineMode.apply(this, arguments);\n};\n\nCodeMirror$1.defineMIME = defineMIME;\n\n// Minimal default mode.\nCodeMirror$1.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\nCodeMirror$1.defineMIME(\"text/plain\", \"null\");\n\n// EXTENSIONS\n\nCodeMirror$1.defineExtension = function (name, func) {\n  CodeMirror$1.prototype[name] = func;\n};\nCodeMirror$1.defineDocExtension = function (name, func) {\n  Doc.prototype[name] = func;\n};\n\nCodeMirror$1.fromTextArea = fromTextArea;\n\naddLegacyProps(CodeMirror$1);\n\nCodeMirror$1.version = \"5.26.0\";\n\nreturn CodeMirror$1;\n\n})));\n\n\n/***/ }),\n\n/***/ 151:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Super simple wysiwyg editor v0.8.1\n * http://summernote.org/\n *\n * summernote.js\n * Copyright 2013-2015 Alan Hong. and other contributors\n * summernote may be freely distributed under the MIT license./\n *\n * Date: 2016-05-26T08:13Z\n */\n(function (factory) {\n  /* global define */\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (typeof module === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = factory(require('jquery'));\n  } else {\n    // Browser globals\n    factory(window.jQuery);\n  }\n}(function ($) {\n  'use strict';\n\n  /**\n   * @class core.func\n   *\n   * func utils (for high-order func's arg)\n   *\n   * @singleton\n   * @alternateClassName func\n   */\n  var func = (function () {\n    var eq = function (itemA) {\n      return function (itemB) {\n        return itemA === itemB;\n      };\n    };\n\n    var eq2 = function (itemA, itemB) {\n      return itemA === itemB;\n    };\n\n    var peq2 = function (propName) {\n      return function (itemA, itemB) {\n        return itemA[propName] === itemB[propName];\n      };\n    };\n\n    var ok = function () {\n      return true;\n    };\n\n    var fail = function () {\n      return false;\n    };\n\n    var not = function (f) {\n      return function () {\n        return !f.apply(f, arguments);\n      };\n    };\n\n    var and = function (fA, fB) {\n      return function (item) {\n        return fA(item) && fB(item);\n      };\n    };\n\n    var self = function (a) {\n      return a;\n    };\n\n    var invoke = function (obj, method) {\n      return function () {\n        return obj[method].apply(obj, arguments);\n      };\n    };\n\n    var idCounter = 0;\n\n    /**\n     * generate a globally-unique id\n     *\n     * @param {String} [prefix]\n     */\n    var uniqueId = function (prefix) {\n      var id = ++idCounter + '';\n      return prefix ? prefix + id : id;\n    };\n\n    /**\n     * returns bnd (bounds) from rect\n     *\n     * - IE Compatibility Issue: http://goo.gl/sRLOAo\n     * - Scroll Issue: http://goo.gl/sNjUc\n     *\n     * @param {Rect} rect\n     * @return {Object} bounds\n     * @return {Number} bounds.top\n     * @return {Number} bounds.left\n     * @return {Number} bounds.width\n     * @return {Number} bounds.height\n     */\n    var rect2bnd = function (rect) {\n      var $document = $(document);\n      return {\n        top: rect.top + $document.scrollTop(),\n        left: rect.left + $document.scrollLeft(),\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n      };\n    };\n\n    /**\n     * returns a copy of the object where the keys have become the values and the values the keys.\n     * @param {Object} obj\n     * @return {Object}\n     */\n    var invertObject = function (obj) {\n      var inverted = {};\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          inverted[obj[key]] = key;\n        }\n      }\n      return inverted;\n    };\n\n    /**\n     * @param {String} namespace\n     * @param {String} [prefix]\n     * @return {String}\n     */\n    var namespaceToCamel = function (namespace, prefix) {\n      prefix = prefix || '';\n      return prefix + namespace.split('.').map(function (name) {\n        return name.substring(0, 1).toUpperCase() + name.substring(1);\n      }).join('');\n    };\n\n    return {\n      eq: eq,\n      eq2: eq2,\n      peq2: peq2,\n      ok: ok,\n      fail: fail,\n      self: self,\n      not: not,\n      and: and,\n      invoke: invoke,\n      uniqueId: uniqueId,\n      rect2bnd: rect2bnd,\n      invertObject: invertObject,\n      namespaceToCamel: namespaceToCamel\n    };\n  })();\n\n  /**\n   * @class core.list\n   *\n   * list utils\n   *\n   * @singleton\n   * @alternateClassName list\n   */\n  var list = (function () {\n    /**\n     * returns the first item of an array.\n     *\n     * @param {Array} array\n     */\n    var head = function (array) {\n      return array[0];\n    };\n\n    /**\n     * returns the last item of an array.\n     *\n     * @param {Array} array\n     */\n    var last = function (array) {\n      return array[array.length - 1];\n    };\n\n    /**\n     * returns everything but the last entry of the array.\n     *\n     * @param {Array} array\n     */\n    var initial = function (array) {\n      return array.slice(0, array.length - 1);\n    };\n\n    /**\n     * returns the rest of the items in an array.\n     *\n     * @param {Array} array\n     */\n    var tail = function (array) {\n      return array.slice(1);\n    };\n\n    /**\n     * returns item of array\n     */\n    var find = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        var item = array[idx];\n        if (pred(item)) {\n          return item;\n        }\n      }\n    };\n\n    /**\n     * returns true if all of the values in the array pass the predicate truth test.\n     */\n    var all = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!pred(array[idx])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    /**\n     * returns index of item\n     */\n    var indexOf = function (array, item) {\n      return $.inArray(item, array);\n    };\n\n    /**\n     * returns true if the value is present in the list.\n     */\n    var contains = function (array, item) {\n      return indexOf(array, item) !== -1;\n    };\n\n    /**\n     * get sum from a list\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - iterator\n     */\n    var sum = function (array, fn) {\n      fn = fn || func.self;\n      return array.reduce(function (memo, v) {\n        return memo + fn(v);\n      }, 0);\n    };\n  \n    /**\n     * returns a copy of the collection with array type.\n     * @param {Collection} collection - collection eg) node.childNodes, ...\n     */\n    var from = function (collection) {\n      var result = [], idx = -1, length = collection.length;\n      while (++idx < length) {\n        result[idx] = collection[idx];\n      }\n      return result;\n    };\n\n    /**\n     * returns whether list is empty or not\n     */\n    var isEmpty = function (array) {\n      return !array || !array.length;\n    };\n  \n    /**\n     * cluster elements by predicate function.\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     * @param {Array[]}\n     */\n    var clusterBy = function (array, fn) {\n      if (!array.length) { return []; }\n      var aTail = tail(array);\n      return aTail.reduce(function (memo, v) {\n        var aLast = last(memo);\n        if (fn(last(aLast), v)) {\n          aLast[aLast.length] = v;\n        } else {\n          memo[memo.length] = [v];\n        }\n        return memo;\n      }, [[head(array)]]);\n    };\n  \n    /**\n     * returns a copy of the array with all falsy values removed\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     */\n    var compact = function (array) {\n      var aResult = [];\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (array[idx]) { aResult.push(array[idx]); }\n      }\n      return aResult;\n    };\n\n    /**\n     * produces a duplicate-free version of the array\n     *\n     * @param {Array} array\n     */\n    var unique = function (array) {\n      var results = [];\n\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!contains(results, array[idx])) {\n          results.push(array[idx]);\n        }\n      }\n\n      return results;\n    };\n\n    /**\n     * returns next item.\n     * @param {Array} array\n     */\n    var next = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx + 1];\n    };\n\n    /**\n     * returns prev item.\n     * @param {Array} array\n     */\n    var prev = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx - 1];\n    };\n\n    return { head: head, last: last, initial: initial, tail: tail,\n             prev: prev, next: next, find: find, contains: contains,\n             all: all, sum: sum, from: from, isEmpty: isEmpty,\n             clusterBy: clusterBy, compact: compact, unique: unique };\n  })();\n\n  var isSupportAmd = \"function\" === 'function' && __webpack_require__(152);\n\n  /**\n   * returns whether font is installed or not.\n   *\n   * @param {String} fontName\n   * @return {Boolean}\n   */\n  var isFontInstalled = function (fontName) {\n    var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';\n    var $tester = $('<div>').css({\n      position: 'absolute',\n      left: '-9999px',\n      top: '-9999px',\n      fontSize: '200px'\n    }).text('mmmmmmmmmwwwwwww').appendTo(document.body);\n\n    var originalWidth = $tester.css('fontFamily', testFontName).width();\n    var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();\n\n    $tester.remove();\n\n    return originalWidth !== width;\n  };\n\n  var userAgent = navigator.userAgent;\n  var isMSIE = /MSIE|Trident/i.test(userAgent);\n  var browserVersion;\n  if (isMSIE) {\n    var matches = /MSIE (\\d+[.]\\d+)/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n    matches = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n  }\n\n  var isEdge = /Edge\\/\\d+/.test(userAgent);\n\n  var hasCodeMirror = !!window.CodeMirror;\n  if (!hasCodeMirror && isSupportAmd) {\n    try {\n      // If CodeMirror can't be resolved, `require.resolve` will throw an\n      // exception and `hasCodeMirror` won't be set to `true`.\n      /*require.resolve*/(149);\n      hasCodeMirror = true;\n    } catch (e) {\n      hasCodeMirror = false;\n    }\n  }\n\n  /**\n   * @class core.agent\n   *\n   * Object which check platform and agent\n   *\n   * @singleton\n   * @alternateClassName agent\n   */\n  var agent = {\n    isMac: navigator.appVersion.indexOf('Mac') > -1,\n    isMSIE: isMSIE,\n    isEdge: isEdge,\n    isFF: !isEdge && /firefox/i.test(userAgent),\n    isPhantom: /PhantomJS/i.test(userAgent),\n    isWebkit: !isEdge && /webkit/i.test(userAgent),\n    isChrome: !isEdge && /chrome/i.test(userAgent),\n    isSafari: !isEdge && /safari/i.test(userAgent),\n    browserVersion: browserVersion,\n    jqueryVersion: parseFloat($.fn.jquery),\n    isSupportAmd: isSupportAmd,\n    hasCodeMirror: hasCodeMirror,\n    isFontInstalled: isFontInstalled,\n    isW3CRangeSupport: !!document.createRange\n  };\n\n\n  var NBSP_CHAR = String.fromCharCode(160);\n  var ZERO_WIDTH_NBSP_CHAR = '\\ufeff';\n\n  /**\n   * @class core.dom\n   *\n   * Dom functions\n   *\n   * @singleton\n   * @alternateClassName dom\n   */\n  var dom = (function () {\n    /**\n     * @method isEditable\n     *\n     * returns whether node is `note-editable` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEditable = function (node) {\n      return node && $(node).hasClass('note-editable');\n    };\n\n    /**\n     * @method isControlSizing\n     *\n     * returns whether node is `note-control-sizing` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isControlSizing = function (node) {\n      return node && $(node).hasClass('note-control-sizing');\n    };\n\n    /**\n     * @method makePredByNodeName\n     *\n     * returns predicate which judge whether nodeName is same\n     *\n     * @param {String} nodeName\n     * @return {Function}\n     */\n    var makePredByNodeName = function (nodeName) {\n      nodeName = nodeName.toUpperCase();\n      return function (node) {\n        return node && node.nodeName.toUpperCase() === nodeName;\n      };\n    };\n\n    /**\n     * @method isText\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is text(3)\n     */\n    var isText = function (node) {\n      return node && node.nodeType === 3;\n    };\n\n    /**\n     * @method isElement\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is element(1)\n     */\n    var isElement = function (node) {\n      return node && node.nodeType === 1;\n    };\n\n    /**\n     * ex) br, col, embed, hr, img, input, ...\n     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n     */\n    var isVoid = function (node) {\n      return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPara = function (node) {\n      if (isEditable(node)) {\n        return false;\n      }\n\n      // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph\n      return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHeading = function (node) {\n      return node && /^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPre = makePredByNodeName('PRE');\n\n    var isLi = makePredByNodeName('LI');\n\n    var isPurePara = function (node) {\n      return isPara(node) && !isLi(node);\n    };\n\n    var isTable = makePredByNodeName('TABLE');\n\n    var isInline = function (node) {\n      return !isBodyContainer(node) &&\n             !isList(node) &&\n             !isHr(node) &&\n             !isPara(node) &&\n             !isTable(node) &&\n             !isBlockquote(node);\n    };\n\n    var isList = function (node) {\n      return node && /^UL|^OL/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHr = makePredByNodeName('HR');\n\n    var isCell = function (node) {\n      return node && /^TD|^TH/.test(node.nodeName.toUpperCase());\n    };\n\n    var isBlockquote = makePredByNodeName('BLOCKQUOTE');\n\n    var isBodyContainer = function (node) {\n      return isCell(node) || isBlockquote(node) || isEditable(node);\n    };\n\n    var isAnchor = makePredByNodeName('A');\n\n    var isParaInline = function (node) {\n      return isInline(node) && !!ancestor(node, isPara);\n    };\n\n    var isBodyInline = function (node) {\n      return isInline(node) && !ancestor(node, isPara);\n    };\n\n    var isBody = makePredByNodeName('BODY');\n\n    /**\n     * returns whether nodeB is closest sibling of nodeA\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     * @return {Boolean}\n     */\n    var isClosestSibling = function (nodeA, nodeB) {\n      return nodeA.nextSibling === nodeB ||\n             nodeA.previousSibling === nodeB;\n    };\n\n    /**\n     * returns array of closest siblings with node\n     *\n     * @param {Node} node\n     * @param {function} [pred] - predicate function\n     * @return {Node[]}\n     */\n    var withClosestSiblings = function (node, pred) {\n      pred = pred || func.ok;\n\n      var siblings = [];\n      if (node.previousSibling && pred(node.previousSibling)) {\n        siblings.push(node.previousSibling);\n      }\n      siblings.push(node);\n      if (node.nextSibling && pred(node.nextSibling)) {\n        siblings.push(node.nextSibling);\n      }\n      return siblings;\n    };\n\n    /**\n     * blank HTML for cursor position\n     * - [workaround] old IE only works with &nbsp;\n     * - [workaround] IE11 and other browser works with bogus br\n     */\n    var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';\n\n    /**\n     * @method nodeLength\n     *\n     * returns #text's text size or element's childNodes size\n     *\n     * @param {Node} node\n     */\n    var nodeLength = function (node) {\n      if (isText(node)) {\n        return node.nodeValue.length;\n      }\n\n      return node.childNodes.length;\n    };\n\n    /**\n     * returns whether node is empty or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEmpty = function (node) {\n      var len = nodeLength(node);\n\n      if (len === 0) {\n        return true;\n      } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {\n        // ex) <p><br></p>, <span><br></span>\n        return true;\n      } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {\n        // ex) <p></p>, <span></span>\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * padding blankHTML if node is empty (for cursor position)\n     */\n    var paddingBlankHTML = function (node) {\n      if (!isVoid(node) && !nodeLength(node)) {\n        node.innerHTML = blankHTML;\n      }\n    };\n\n    /**\n     * find nearest ancestor predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var ancestor = function (node, pred) {\n      while (node) {\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * find nearest ancestor only single child blood line and predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var singleChildAncestor = function (node, pred) {\n      node = node.parentNode;\n\n      while (node) {\n        if (nodeLength(node) !== 1) { break; }\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * returns new array of ancestor nodes (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listAncestor = function (node, pred) {\n      pred = pred || func.fail;\n\n      var ancestors = [];\n      ancestor(node, function (el) {\n        if (!isEditable(el)) {\n          ancestors.push(el);\n        }\n\n        return pred(el);\n      });\n      return ancestors;\n    };\n\n    /**\n     * find farthest ancestor predicate hit\n     */\n    var lastAncestor = function (node, pred) {\n      var ancestors = listAncestor(node);\n      return list.last(ancestors.filter(pred));\n    };\n\n    /**\n     * returns common ancestor node between two nodes.\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n    var commonAncestor = function (nodeA, nodeB) {\n      var ancestors = listAncestor(nodeA);\n      for (var n = nodeB; n; n = n.parentNode) {\n        if ($.inArray(n, ancestors) > -1) { return n; }\n      }\n      return null; // difference document area\n    };\n\n    /**\n     * listing all previous siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listPrev = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.previousSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing next siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listNext = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.nextSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing descendant nodes\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listDescendant = function (node, pred) {\n      var descendants = [];\n      pred = pred || func.ok;\n\n      // start DFS(depth first search) with node\n      (function fnWalk(current) {\n        if (node !== current && pred(current)) {\n          descendants.push(current);\n        }\n        for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {\n          fnWalk(current.childNodes[idx]);\n        }\n      })(node);\n\n      return descendants;\n    };\n\n    /**\n     * wrap node with new tag.\n     *\n     * @param {Node} node\n     * @param {Node} tagName of wrapper\n     * @return {Node} - wrapper\n     */\n    var wrap = function (node, wrapperName) {\n      var parent = node.parentNode;\n      var wrapper = $('<' + wrapperName + '>')[0];\n\n      parent.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n\n      return wrapper;\n    };\n\n    /**\n     * insert node after preceding\n     *\n     * @param {Node} node\n     * @param {Node} preceding - predicate function\n     */\n    var insertAfter = function (node, preceding) {\n      var next = preceding.nextSibling, parent = preceding.parentNode;\n      if (next) {\n        parent.insertBefore(node, next);\n      } else {\n        parent.appendChild(node);\n      }\n      return node;\n    };\n\n    /**\n     * append elements.\n     *\n     * @param {Node} node\n     * @param {Collection} aChild\n     */\n    var appendChildNodes = function (node, aChild) {\n      $.each(aChild, function (idx, child) {\n        node.appendChild(child);\n      });\n      return node;\n    };\n\n    /**\n     * returns whether boundaryPoint is left edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isLeftEdgePoint = function (point) {\n      return point.offset === 0;\n    };\n\n    /**\n     * returns whether boundaryPoint is right edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isRightEdgePoint = function (point) {\n      return point.offset === nodeLength(point.node);\n    };\n\n    /**\n     * returns whether boundaryPoint is edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isEdgePoint = function (point) {\n      return isLeftEdgePoint(point) || isRightEdgePoint(point);\n    };\n\n    /**\n     * returns whether node is left edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== 0) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether node is right edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== nodeLength(node.parentNode) - 1) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether point is left edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgePointOf = function (point, ancestor) {\n      return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns whether point is right edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgePointOf = function (point, ancestor) {\n      return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns offset from parent.\n     *\n     * @param {Node} node\n     */\n    var position = function (node) {\n      var offset = 0;\n      while ((node = node.previousSibling)) {\n        offset += 1;\n      }\n      return offset;\n    };\n\n    var hasChildren = function (node) {\n      return !!(node && node.childNodes && node.childNodes.length);\n    };\n\n    /**\n     * returns previous boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var prevPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (point.offset === 0) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node);\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset - 1];\n        offset = nodeLength(node);\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? 0 : point.offset - 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns next boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var nextPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (nodeLength(point.node) === point.offset) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node) + 1;\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset];\n        offset = 0;\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns whether pointA and pointB is same or not.\n     *\n     * @param {BoundaryPoint} pointA\n     * @param {BoundaryPoint} pointB\n     * @return {Boolean}\n     */\n    var isSamePoint = function (pointA, pointB) {\n      return pointA.node === pointB.node && pointA.offset === pointB.offset;\n    };\n\n    /**\n     * returns whether point is visible (can set cursor) or not.\n     * \n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isVisiblePoint = function (point) {\n      if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {\n        return true;\n      }\n\n      var leftNode = point.node.childNodes[point.offset - 1];\n      var rightNode = point.node.childNodes[point.offset];\n      if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * @method prevPointUtil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var prevPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = prevPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * @method nextPointUntil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var nextPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = nextPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * returns whether point has character or not.\n     *\n     * @param {Point} point\n     * @return {Boolean}\n     */\n    var isCharPoint = function (point) {\n      if (!isText(point.node)) {\n        return false;\n      }\n\n      var ch = point.node.nodeValue.charAt(point.offset - 1);\n      return ch && (ch !== ' ' && ch !== NBSP_CHAR);\n    };\n\n    /**\n     * @method walkPoint\n     *\n     * @param {BoundaryPoint} startPoint\n     * @param {BoundaryPoint} endPoint\n     * @param {Function} handler\n     * @param {Boolean} isSkipInnerOffset\n     */\n    var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {\n      var point = startPoint;\n\n      while (point) {\n        handler(point);\n\n        if (isSamePoint(point, endPoint)) {\n          break;\n        }\n\n        var isSkipOffset = isSkipInnerOffset &&\n                           startPoint.node !== point.node &&\n                           endPoint.node !== point.node;\n        point = nextPoint(point, isSkipOffset);\n      }\n    };\n\n    /**\n     * @method makeOffsetPath\n     *\n     * return offsetPath(array of offset) from ancestor\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {Node} node\n     */\n    var makeOffsetPath = function (ancestor, node) {\n      var ancestors = listAncestor(node, func.eq(ancestor));\n      return ancestors.map(position).reverse();\n    };\n\n    /**\n     * @method fromOffsetPath\n     *\n     * return element from offsetPath(array of offset)\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {array} offsets - offsetPath\n     */\n    var fromOffsetPath = function (ancestor, offsets) {\n      var current = ancestor;\n      for (var i = 0, len = offsets.length; i < len; i++) {\n        if (current.childNodes.length <= offsets[i]) {\n          current = current.childNodes[current.childNodes.length - 1];\n        } else {\n          current = current.childNodes[offsets[i]];\n        }\n      }\n      return current;\n    };\n\n    /**\n     * @method splitNode\n     *\n     * split element or #text\n     *\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitNode = function (point, options) {\n      var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;\n      var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;\n\n      // edge case\n      if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {\n        if (isLeftEdgePoint(point)) {\n          return point.node;\n        } else if (isRightEdgePoint(point)) {\n          return point.node.nextSibling;\n        }\n      }\n\n      // split #text\n      if (isText(point.node)) {\n        return point.node.splitText(point.offset);\n      } else {\n        var childNode = point.node.childNodes[point.offset];\n        var clone = insertAfter(point.node.cloneNode(false), point.node);\n        appendChildNodes(clone, listNext(childNode));\n\n        if (!isSkipPaddingBlankHTML) {\n          paddingBlankHTML(point.node);\n          paddingBlankHTML(clone);\n        }\n\n        return clone;\n      }\n    };\n\n    /**\n     * @method splitTree\n     *\n     * split tree by point\n     *\n     * @param {Node} root - split root\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitTree = function (root, point, options) {\n      // ex) [#text, <span>, <p>]\n      var ancestors = listAncestor(point.node, func.eq(root));\n\n      if (!ancestors.length) {\n        return null;\n      } else if (ancestors.length === 1) {\n        return splitNode(point, options);\n      }\n\n      return ancestors.reduce(function (node, parent) {\n        if (node === point.node) {\n          node = splitNode(point, options);\n        }\n\n        return splitNode({\n          node: parent,\n          offset: node ? dom.position(node) : nodeLength(parent)\n        }, options);\n      });\n    };\n\n    /**\n     * split point\n     *\n     * @param {Point} point\n     * @param {Boolean} isInline\n     * @return {Object}\n     */\n    var splitPoint = function (point, isInline) {\n      // find splitRoot, container\n      //  - inline: splitRoot is a child of paragraph\n      //  - block: splitRoot is a child of bodyContainer\n      var pred = isInline ? isPara : isBodyContainer;\n      var ancestors = listAncestor(point.node, pred);\n      var topAncestor = list.last(ancestors) || point.node;\n\n      var splitRoot, container;\n      if (pred(topAncestor)) {\n        splitRoot = ancestors[ancestors.length - 2];\n        container = topAncestor;\n      } else {\n        splitRoot = topAncestor;\n        container = splitRoot.parentNode;\n      }\n\n      // if splitRoot is exists, split with splitTree\n      var pivot = splitRoot && splitTree(splitRoot, point, {\n        isSkipPaddingBlankHTML: isInline,\n        isNotSplitEdgePoint: isInline\n      });\n\n      // if container is point.node, find pivot with point.offset\n      if (!pivot && container === point.node) {\n        pivot = point.node.childNodes[point.offset];\n      }\n\n      return {\n        rightNode: pivot,\n        container: container\n      };\n    };\n\n    var create = function (nodeName) {\n      return document.createElement(nodeName);\n    };\n\n    var createText = function (text) {\n      return document.createTextNode(text);\n    };\n\n    /**\n     * @method remove\n     *\n     * remove node, (isRemoveChild: remove child or not)\n     *\n     * @param {Node} node\n     * @param {Boolean} isRemoveChild\n     */\n    var remove = function (node, isRemoveChild) {\n      if (!node || !node.parentNode) { return; }\n      if (node.removeNode) { return node.removeNode(isRemoveChild); }\n\n      var parent = node.parentNode;\n      if (!isRemoveChild) {\n        var nodes = [];\n        var i, len;\n        for (i = 0, len = node.childNodes.length; i < len; i++) {\n          nodes.push(node.childNodes[i]);\n        }\n\n        for (i = 0, len = nodes.length; i < len; i++) {\n          parent.insertBefore(nodes[i], node);\n        }\n      }\n\n      parent.removeChild(node);\n    };\n\n    /**\n     * @method removeWhile\n     *\n     * @param {Node} node\n     * @param {Function} pred\n     */\n    var removeWhile = function (node, pred) {\n      while (node) {\n        if (isEditable(node) || !pred(node)) {\n          break;\n        }\n\n        var parent = node.parentNode;\n        remove(node);\n        node = parent;\n      }\n    };\n\n    /**\n     * @method replace\n     *\n     * replace node with provided nodeName\n     *\n     * @param {Node} node\n     * @param {String} nodeName\n     * @return {Node} - new node\n     */\n    var replace = function (node, nodeName) {\n      if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {\n        return node;\n      }\n\n      var newNode = create(nodeName);\n\n      if (node.style.cssText) {\n        newNode.style.cssText = node.style.cssText;\n      }\n\n      appendChildNodes(newNode, list.from(node.childNodes));\n      insertAfter(newNode, node);\n      remove(node);\n\n      return newNode;\n    };\n\n    var isTextarea = makePredByNodeName('TEXTAREA');\n\n    /**\n     * @param {jQuery} $node\n     * @param {Boolean} [stripLinebreaks] - default: false\n     */\n    var value = function ($node, stripLinebreaks) {\n      var val = isTextarea($node[0]) ? $node.val() : $node.html();\n      if (stripLinebreaks) {\n        return val.replace(/[\\n\\r]/g, '');\n      }\n      return val;\n    };\n\n    /**\n     * @method html\n     *\n     * get the HTML contents of node\n     *\n     * @param {jQuery} $node\n     * @param {Boolean} [isNewlineOnBlock]\n     */\n    var html = function ($node, isNewlineOnBlock) {\n      var markup = value($node);\n\n      if (isNewlineOnBlock) {\n        var regexTag = /<(\\/?)(\\b(?!!)[^>\\s]*)(.*?)(\\s*\\/?>)/g;\n        markup = markup.replace(regexTag, function (match, endSlash, name) {\n          name = name.toUpperCase();\n          var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&\n                                       !!endSlash;\n          var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);\n\n          return match + ((isEndOfInlineContainer || isBlockNode) ? '\\n' : '');\n        });\n        markup = $.trim(markup);\n      }\n\n      return markup;\n    };\n\n    var posFromPlaceholder = function (placeholder) {\n      var $placeholder = $(placeholder);\n      var pos = $placeholder.offset();\n      var height = $placeholder.outerHeight(true); // include margin\n\n      return {\n        left: pos.left,\n        top: pos.top + height\n      };\n    };\n\n    var attachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.on(key, events[key]);\n      });\n    };\n\n    var detachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.off(key, events[key]);\n      });\n    };\n\n    return {\n      /** @property {String} NBSP_CHAR */\n      NBSP_CHAR: NBSP_CHAR,\n      /** @property {String} ZERO_WIDTH_NBSP_CHAR */\n      ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,\n      /** @property {String} blank */\n      blank: blankHTML,\n      /** @property {String} emptyPara */\n      emptyPara: '<p>' + blankHTML + '</p>',\n      makePredByNodeName: makePredByNodeName,\n      isEditable: isEditable,\n      isControlSizing: isControlSizing,\n      isText: isText,\n      isElement: isElement,\n      isVoid: isVoid,\n      isPara: isPara,\n      isPurePara: isPurePara,\n      isHeading: isHeading,\n      isInline: isInline,\n      isBlock: func.not(isInline),\n      isBodyInline: isBodyInline,\n      isBody: isBody,\n      isParaInline: isParaInline,\n      isPre: isPre,\n      isList: isList,\n      isTable: isTable,\n      isCell: isCell,\n      isBlockquote: isBlockquote,\n      isBodyContainer: isBodyContainer,\n      isAnchor: isAnchor,\n      isDiv: makePredByNodeName('DIV'),\n      isLi: isLi,\n      isBR: makePredByNodeName('BR'),\n      isSpan: makePredByNodeName('SPAN'),\n      isB: makePredByNodeName('B'),\n      isU: makePredByNodeName('U'),\n      isS: makePredByNodeName('S'),\n      isI: makePredByNodeName('I'),\n      isImg: makePredByNodeName('IMG'),\n      isTextarea: isTextarea,\n      isEmpty: isEmpty,\n      isEmptyAnchor: func.and(isAnchor, isEmpty),\n      isClosestSibling: isClosestSibling,\n      withClosestSiblings: withClosestSiblings,\n      nodeLength: nodeLength,\n      isLeftEdgePoint: isLeftEdgePoint,\n      isRightEdgePoint: isRightEdgePoint,\n      isEdgePoint: isEdgePoint,\n      isLeftEdgeOf: isLeftEdgeOf,\n      isRightEdgeOf: isRightEdgeOf,\n      isLeftEdgePointOf: isLeftEdgePointOf,\n      isRightEdgePointOf: isRightEdgePointOf,\n      prevPoint: prevPoint,\n      nextPoint: nextPoint,\n      isSamePoint: isSamePoint,\n      isVisiblePoint: isVisiblePoint,\n      prevPointUntil: prevPointUntil,\n      nextPointUntil: nextPointUntil,\n      isCharPoint: isCharPoint,\n      walkPoint: walkPoint,\n      ancestor: ancestor,\n      singleChildAncestor: singleChildAncestor,\n      listAncestor: listAncestor,\n      lastAncestor: lastAncestor,\n      listNext: listNext,\n      listPrev: listPrev,\n      listDescendant: listDescendant,\n      commonAncestor: commonAncestor,\n      wrap: wrap,\n      insertAfter: insertAfter,\n      appendChildNodes: appendChildNodes,\n      position: position,\n      hasChildren: hasChildren,\n      makeOffsetPath: makeOffsetPath,\n      fromOffsetPath: fromOffsetPath,\n      splitTree: splitTree,\n      splitPoint: splitPoint,\n      create: create,\n      createText: createText,\n      remove: remove,\n      removeWhile: removeWhile,\n      replace: replace,\n      html: html,\n      value: value,\n      posFromPlaceholder: posFromPlaceholder,\n      attachEvents: attachEvents,\n      detachEvents: detachEvents\n    };\n  })();\n\n  /**\n   * @param {jQuery} $note\n   * @param {Object} options\n   * @return {Context}\n   */\n  var Context = function ($note, options) {\n    var self = this;\n\n    var ui = $.summernote.ui;\n    this.memos = {};\n    this.modules = {};\n    this.layoutInfo = {};\n    this.options = options;\n\n    /**\n     * create layout and initialize modules and other resources\n     */\n    this.initialize = function () {\n      this.layoutInfo = ui.createLayout($note, options);\n      this._initialize();\n      $note.hide();\n      return this;\n    };\n\n    /**\n     * destroy modules and other resources and remove layout\n     */\n    this.destroy = function () {\n      this._destroy();\n      $note.removeData('summernote');\n      ui.removeLayout($note, this.layoutInfo);\n    };\n\n    /**\n     * destory modules and other resources and initialize it again\n     */\n    this.reset = function () {\n      var disabled = self.isDisabled();\n      this.code(dom.emptyPara);\n      this._destroy();\n      this._initialize();\n\n      if (disabled) {\n        self.disable();\n      }\n    };\n\n    this._initialize = function () {\n      // add optional buttons\n      var buttons = $.extend({}, this.options.buttons);\n      Object.keys(buttons).forEach(function (key) {\n        self.memo('button.' + key, buttons[key]);\n      });\n\n      var modules = $.extend({}, this.options.modules, $.summernote.plugins || {});\n\n      // add and initialize modules\n      Object.keys(modules).forEach(function (key) {\n        self.module(key, modules[key], true);\n      });\n\n      Object.keys(this.modules).forEach(function (key) {\n        self.initializeModule(key);\n      });\n    };\n\n    this._destroy = function () {\n      // destroy modules with reversed order\n      Object.keys(this.modules).reverse().forEach(function (key) {\n        self.removeModule(key);\n      });\n\n      Object.keys(this.memos).forEach(function (key) {\n        self.removeMemo(key);\n      });\n    };\n\n    this.code = function (html) {\n      var isActivated = this.invoke('codeview.isActivated');\n\n      if (html === undefined) {\n        this.invoke('codeview.sync');\n        return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();\n      } else {\n        if (isActivated) {\n          this.layoutInfo.codable.val(html);\n        } else {\n          this.layoutInfo.editable.html(html);\n        }\n        $note.val(html);\n        this.triggerEvent('change', html);\n      }\n    };\n\n    this.isDisabled = function () {\n      return this.layoutInfo.editable.attr('contenteditable') === 'false';\n    };\n\n    this.enable = function () {\n      this.layoutInfo.editable.attr('contenteditable', true);\n      this.invoke('toolbar.activate', true);\n    };\n\n    this.disable = function () {\n      // close codeview if codeview is opend\n      if (this.invoke('codeview.isActivated')) {\n        this.invoke('codeview.deactivate');\n      }\n      this.layoutInfo.editable.attr('contenteditable', false);\n      this.invoke('toolbar.deactivate', true);\n    };\n\n    this.triggerEvent = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];\n      if (callback) {\n        callback.apply($note[0], args);\n      }\n      $note.trigger('summernote.' + namespace, args);\n    };\n\n    this.initializeModule = function (key) {\n      var module = this.modules[key];\n      module.shouldInitialize = module.shouldInitialize || func.ok;\n      if (!module.shouldInitialize()) {\n        return;\n      }\n\n      // initialize module\n      if (module.initialize) {\n        module.initialize();\n      }\n\n      // attach events\n      if (module.events) {\n        dom.attachEvents($note, module.events);\n      }\n    };\n\n    this.module = function (key, ModuleClass, withoutIntialize) {\n      if (arguments.length === 1) {\n        return this.modules[key];\n      }\n\n      this.modules[key] = new ModuleClass(this);\n\n      if (!withoutIntialize) {\n        this.initializeModule(key);\n      }\n    };\n\n    this.removeModule = function (key) {\n      var module = this.modules[key];\n      if (module.shouldInitialize()) {\n        if (module.events) {\n          dom.detachEvents($note, module.events);\n        }\n\n        if (module.destroy) {\n          module.destroy();\n        }\n      }\n\n      delete this.modules[key];\n    };\n\n    this.memo = function (key, obj) {\n      if (arguments.length === 1) {\n        return this.memos[key];\n      }\n      this.memos[key] = obj;\n    };\n\n    this.removeMemo = function (key) {\n      if (this.memos[key] && this.memos[key].destroy) {\n        this.memos[key].destroy();\n      }\n\n      delete this.memos[key];\n    };\n\n    this.createInvokeHandler = function (namespace, value) {\n      return function (event) {\n        event.preventDefault();\n        self.invoke(namespace, value || $(event.target).closest('[data-value]').data('value'));\n      };\n    };\n\n    this.invoke = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var splits = namespace.split('.');\n      var hasSeparator = splits.length > 1;\n      var moduleName = hasSeparator && list.head(splits);\n      var methodName = hasSeparator ? list.last(splits) : list.head(splits);\n\n      var module = this.modules[moduleName || 'editor'];\n      if (!moduleName && this[methodName]) {\n        return this[methodName].apply(this, args);\n      } else if (module && module[methodName] && module.shouldInitialize()) {\n        return module[methodName].apply(module, args);\n      }\n    };\n\n    return this.initialize();\n  };\n\n  $.fn.extend({\n    /**\n     * Summernote API\n     *\n     * @param {Object|String}\n     * @return {this}\n     */\n    summernote: function () {\n      var type = $.type(list.head(arguments));\n      var isExternalAPICalled = type === 'string';\n      var hasInitOptions = type === 'object';\n\n      var options = hasInitOptions ? list.head(arguments) : {};\n\n      options = $.extend({}, $.summernote.options, options);\n      options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);\n\n      this.each(function (idx, note) {\n        var $note = $(note);\n        if (!$note.data('summernote')) {\n          var context = new Context($note, options);\n          $note.data('summernote', context);\n          $note.data('summernote').triggerEvent('init', context.layoutInfo);\n        }\n      });\n\n      var $note = this.first();\n      if ($note.length) {\n        var context = $note.data('summernote');\n        if (isExternalAPICalled) {\n          return context.invoke.apply(context, list.from(arguments));\n        } else if (options.focus) {\n          context.invoke('editor.focus');\n        }\n      }\n\n      return this;\n    }\n  });\n\n\n  var Renderer = function (markup, children, options, callback) {\n    this.render = function ($parent) {\n      var $node = $(markup);\n\n      if (options && options.contents) {\n        $node.html(options.contents);\n      }\n\n      if (options && options.className) {\n        $node.addClass(options.className);\n      }\n\n      if (options && options.data) {\n        $.each(options.data, function (k, v) {\n          $node.attr('data-' + k, v);\n        });\n      }\n\n      if (options && options.click) {\n        $node.on('click', options.click);\n      }\n\n      if (children) {\n        var $container = $node.find('.note-children-container');\n        children.forEach(function (child) {\n          child.render($container.length ? $container : $node);\n        });\n      }\n\n      if (callback) {\n        callback($node, options);\n      }\n\n      if (options && options.callback) {\n        options.callback($node);\n      }\n\n      if ($parent) {\n        $parent.append($node);\n      }\n\n      return $node;\n    };\n  };\n\n  var renderer = {\n    create: function (markup, callback) {\n      return function () {\n        var children = $.isArray(arguments[0]) ? arguments[0] : [];\n        var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];\n        if (options && options.children) {\n          children = options.children;\n        }\n        return new Renderer(markup, children, options, callback);\n      };\n    }\n  };\n\n  var editor = renderer.create('<div class=\"note-editor note-frame panel panel-default\"/>');\n  var toolbar = renderer.create('<div class=\"note-toolbar panel-heading\"/>');\n  var editingArea = renderer.create('<div class=\"note-editing-area\"/>');\n  var codable = renderer.create('<textarea class=\"note-codable\"/>');\n  var editable = renderer.create('<div class=\"note-editable panel-body\" contentEditable=\"true\"/>');\n  var statusbar = renderer.create([\n    '<div class=\"note-statusbar\">',\n    '  <div class=\"note-resizebar\">',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '  </div>',\n    '</div>'\n  ].join(''));\n\n  var airEditor = renderer.create('<div class=\"note-editor\"/>');\n  var airEditable = renderer.create('<div class=\"note-editable\" contentEditable=\"true\"/>');\n\n  var buttonGroup = renderer.create('<div class=\"note-btn-group btn-group\">');\n  var button = renderer.create('<button type=\"button\" class=\"note-btn btn btn-default btn-sm\">', function ($node, options) {\n    if (options && options.tooltip) {\n      $node.attr({\n        title: options.tooltip\n      }).tooltip({\n        container: 'body',\n        trigger: 'hover',\n        placement: 'bottom'\n      });\n    }\n  });\n\n  var dropdown = renderer.create('<div class=\"dropdown-menu\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + content + '</a></li>';\n    }).join('') : options.items;\n\n    $node.html(markup);\n  });\n\n  var dropdownCheck = renderer.create('<div class=\"dropdown-menu note-check\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + icon(options.checkClassName) + ' ' + content + '</a></li>';\n    }).join('') : options.items;\n    $node.html(markup);\n  });\n\n  var palette = renderer.create('<div class=\"note-color-palette\"/>', function ($node, options) {\n    var contents = [];\n    for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {\n      var eventName = options.eventName;\n      var colors = options.colors[row];\n      var buttons = [];\n      for (var col = 0, colSize = colors.length; col < colSize; col++) {\n        var color = colors[col];\n        buttons.push([\n          '<button type=\"button\" class=\"note-color-btn\"',\n          'style=\"background-color:', color, '\" ',\n          'data-event=\"', eventName, '\" ',\n          'data-value=\"', color, '\" ',\n          'title=\"', color, '\" ',\n          'data-toggle=\"button\" tabindex=\"-1\"></button>'\n        ].join(''));\n      }\n      contents.push('<div class=\"note-color-row\">' + buttons.join('') + '</div>');\n    }\n    $node.html(contents.join(''));\n\n    $node.find('.note-color-btn').tooltip({\n      container: 'body',\n      trigger: 'hover',\n      placement: 'bottom'\n    });\n  });\n\n  var dialog = renderer.create('<div class=\"modal\" aria-hidden=\"false\" tabindex=\"-1\"/>', function ($node, options) {\n    if (options.fade) {\n      $node.addClass('fade');\n    }\n    $node.html([\n      '<div class=\"modal-dialog\">',\n      '  <div class=\"modal-content\">',\n      (options.title ?\n      '    <div class=\"modal-header\">' +\n      '      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>' +\n      '      <h4 class=\"modal-title\">' + options.title + '</h4>' +\n      '    </div>' : ''\n      ),\n      '    <div class=\"modal-body\">' + options.body + '</div>',\n      (options.footer ?\n      '    <div class=\"modal-footer\">' + options.footer + '</div>' : ''\n      ),\n      '  </div>',\n      '</div>'\n    ].join(''));\n  });\n\n  var popover = renderer.create([\n    '<div class=\"note-popover popover in\">',\n    '  <div class=\"arrow\"/>',\n    '  <div class=\"popover-content note-children-container\"/>',\n    '</div>'\n  ].join(''), function ($node, options) {\n    var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';\n\n    $node.addClass(direction);\n\n    if (options.hideArrow) {\n      $node.find('.arrow').hide();\n    }\n  });\n\n  var icon = function (iconClassName, tagName) {\n    tagName = tagName || 'i';\n    return '<' + tagName + ' class=\"' + iconClassName + '\"/>';\n  };\n\n  var ui = {\n    editor: editor,\n    toolbar: toolbar,\n    editingArea: editingArea,\n    codable: codable,\n    editable: editable,\n    statusbar: statusbar,\n    airEditor: airEditor,\n    airEditable: airEditable,\n    buttonGroup: buttonGroup,\n    button: button,\n    dropdown: dropdown,\n    dropdownCheck: dropdownCheck,\n    palette: palette,\n    dialog: dialog,\n    popover: popover,\n    icon: icon,\n\n    toggleBtn: function ($btn, isEnable) {\n      $btn.toggleClass('disabled', !isEnable);\n      $btn.attr('disabled', !isEnable);\n    },\n\n    toggleBtnActive: function ($btn, isActive) {\n      $btn.toggleClass('active', isActive);\n    },\n\n    onDialogShown: function ($dialog, handler) {\n      $dialog.one('shown.bs.modal', handler);\n    },\n\n    onDialogHidden: function ($dialog, handler) {\n      $dialog.one('hidden.bs.modal', handler);\n    },\n\n    showDialog: function ($dialog) {\n      $dialog.modal('show');\n    },\n\n    hideDialog: function ($dialog) {\n      $dialog.modal('hide');\n    },\n\n    createLayout: function ($note, options) {\n      var $editor = (options.airMode ? ui.airEditor([\n        ui.editingArea([\n          ui.airEditable()\n        ])\n      ]) : ui.editor([\n        ui.toolbar(),\n        ui.editingArea([\n          ui.codable(),\n          ui.editable()\n        ]),\n        ui.statusbar()\n      ])).render();\n\n      $editor.insertAfter($note);\n\n      return {\n        note: $note,\n        editor: $editor,\n        toolbar: $editor.find('.note-toolbar'),\n        editingArea: $editor.find('.note-editing-area'),\n        editable: $editor.find('.note-editable'),\n        codable: $editor.find('.note-codable'),\n        statusbar: $editor.find('.note-statusbar')\n      };\n    },\n\n    removeLayout: function ($note, layoutInfo) {\n      $note.html(layoutInfo.editable.html());\n      layoutInfo.editor.remove();\n      $note.show();\n    }\n  };\n\n  $.summernote = $.summernote || {\n    lang: {}\n  };\n\n  $.extend($.summernote.lang, {\n    'en-US': {\n      font: {\n        bold: 'Bold',\n        italic: 'Italic',\n        underline: 'Underline',\n        clear: 'Remove Font Style',\n        height: 'Line Height',\n        name: 'Font Family',\n        strikethrough: 'Strikethrough',\n        subscript: 'Subscript',\n        superscript: 'Superscript',\n        size: 'Font Size'\n      },\n      image: {\n        image: 'Picture',\n        insert: 'Insert Image',\n        resizeFull: 'Resize Full',\n        resizeHalf: 'Resize Half',\n        resizeQuarter: 'Resize Quarter',\n        floatLeft: 'Float Left',\n        floatRight: 'Float Right',\n        floatNone: 'Float None',\n        shapeRounded: 'Shape: Rounded',\n        shapeCircle: 'Shape: Circle',\n        shapeThumbnail: 'Shape: Thumbnail',\n        shapeNone: 'Shape: None',\n        dragImageHere: 'Drag image or text here',\n        dropImage: 'Drop image or Text',\n        selectFromFiles: 'Select from files',\n        maximumFileSize: 'Maximum file size',\n        maximumFileSizeError: 'Maximum file size exceeded.',\n        url: 'Image URL',\n        remove: 'Remove Image'\n      },\n      video: {\n        video: 'Video',\n        videoLink: 'Video Link',\n        insert: 'Insert Video',\n        url: 'Video URL?',\n        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'\n      },\n      link: {\n        link: 'Link',\n        insert: 'Insert Link',\n        unlink: 'Unlink',\n        edit: 'Edit',\n        textToDisplay: 'Text to display',\n        url: 'To what URL should this link go?',\n        openInNewWindow: 'Open in new window'\n      },\n      table: {\n        table: 'Table'\n      },\n      hr: {\n        insert: 'Insert Horizontal Rule'\n      },\n      style: {\n        style: 'Style',\n        normal: 'Normal',\n        blockquote: 'Quote',\n        pre: 'Code',\n        h1: 'Header 1',\n        h2: 'Header 2',\n        h3: 'Header 3',\n        h4: 'Header 4',\n        h5: 'Header 5',\n        h6: 'Header 6'\n      },\n      lists: {\n        unordered: 'Unordered list',\n        ordered: 'Ordered list'\n      },\n      options: {\n        help: 'Help',\n        fullscreen: 'Full Screen',\n        codeview: 'Code View'\n      },\n      paragraph: {\n        paragraph: 'Paragraph',\n        outdent: 'Outdent',\n        indent: 'Indent',\n        left: 'Align left',\n        center: 'Align center',\n        right: 'Align right',\n        justify: 'Justify full'\n      },\n      color: {\n        recent: 'Recent Color',\n        more: 'More Color',\n        background: 'Background Color',\n        foreground: 'Foreground Color',\n        transparent: 'Transparent',\n        setTransparent: 'Set transparent',\n        reset: 'Reset',\n        resetToDefault: 'Reset to default'\n      },\n      shortcut: {\n        shortcuts: 'Keyboard shortcuts',\n        close: 'Close',\n        textFormatting: 'Text formatting',\n        action: 'Action',\n        paragraphFormatting: 'Paragraph formatting',\n        documentStyle: 'Document Style',\n        extraKeys: 'Extra keys'\n      },\n      help: {\n        'insertParagraph': 'Insert Paragraph',\n        'undo': 'Undoes the last command',\n        'redo': 'Redoes the last command',\n        'tab': 'Tab',\n        'untab': 'Untab',\n        'bold': 'Set a bold style',\n        'italic': 'Set a italic style',\n        'underline': 'Set a underline style',\n        'strikethrough': 'Set a strikethrough style',\n        'removeFormat': 'Clean a style',\n        'justifyLeft': 'Set left align',\n        'justifyCenter': 'Set center align',\n        'justifyRight': 'Set right align',\n        'justifyFull': 'Set full align',\n        'insertUnorderedList': 'Toggle unordered list',\n        'insertOrderedList': 'Toggle ordered list',\n        'outdent': 'Outdent on current paragraph',\n        'indent': 'Indent on current paragraph',\n        'formatPara': 'Change current block\\'s format as a paragraph(P tag)',\n        'formatH1': 'Change current block\\'s format as H1',\n        'formatH2': 'Change current block\\'s format as H2',\n        'formatH3': 'Change current block\\'s format as H3',\n        'formatH4': 'Change current block\\'s format as H4',\n        'formatH5': 'Change current block\\'s format as H5',\n        'formatH6': 'Change current block\\'s format as H6',\n        'insertHorizontalRule': 'Insert horizontal rule',\n        'linkDialog.show': 'Show Link Dialog'\n      },\n      history: {\n        undo: 'Undo',\n        redo: 'Redo'\n      },\n      specialChar: {\n        specialChar: 'SPECIAL CHARACTERS',\n        select: 'Select Special characters'\n      }\n    }\n  });\n\n\n  /**\n   * @class core.key\n   *\n   * Object for keycodes.\n   *\n   * @singleton\n   * @alternateClassName key\n   */\n  var key = (function () {\n    var keyMap = {\n      'BACKSPACE': 8,\n      'TAB': 9,\n      'ENTER': 13,\n      'SPACE': 32,\n\n      // Arrow\n      'LEFT': 37,\n      'UP': 38,\n      'RIGHT': 39,\n      'DOWN': 40,\n\n      // Number: 0-9\n      'NUM0': 48,\n      'NUM1': 49,\n      'NUM2': 50,\n      'NUM3': 51,\n      'NUM4': 52,\n      'NUM5': 53,\n      'NUM6': 54,\n      'NUM7': 55,\n      'NUM8': 56,\n\n      // Alphabet: a-z\n      'B': 66,\n      'E': 69,\n      'I': 73,\n      'J': 74,\n      'K': 75,\n      'L': 76,\n      'R': 82,\n      'S': 83,\n      'U': 85,\n      'V': 86,\n      'Y': 89,\n      'Z': 90,\n\n      'SLASH': 191,\n      'LEFTBRACKET': 219,\n      'BACKSLASH': 220,\n      'RIGHTBRACKET': 221\n    };\n\n    return {\n      /**\n       * @method isEdit\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isEdit: function (keyCode) {\n        return list.contains([\n          keyMap.BACKSPACE,\n          keyMap.TAB,\n          keyMap.ENTER,\n          keyMap.SPACE\n        ], keyCode);\n      },\n      /**\n       * @method isMove\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isMove: function (keyCode) {\n        return list.contains([\n          keyMap.LEFT,\n          keyMap.UP,\n          keyMap.RIGHT,\n          keyMap.DOWN\n        ], keyCode);\n      },\n      /**\n       * @property {Object} nameFromCode\n       * @property {String} nameFromCode.8 \"BACKSPACE\"\n       */\n      nameFromCode: func.invertObject(keyMap),\n      code: keyMap\n    };\n  })();\n\n  var range = (function () {\n\n    /**\n     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js\n     *\n     * @param {TextRange} textRange\n     * @param {Boolean} isStart\n     * @return {BoundaryPoint}\n     *\n     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx\n     */\n    var textRangeToPoint = function (textRange, isStart) {\n      var container = textRange.parentElement(), offset;\n  \n      var tester = document.body.createTextRange(), prevContainer;\n      var childNodes = list.from(container.childNodes);\n      for (offset = 0; offset < childNodes.length; offset++) {\n        if (dom.isText(childNodes[offset])) {\n          continue;\n        }\n        tester.moveToElementText(childNodes[offset]);\n        if (tester.compareEndPoints('StartToStart', textRange) >= 0) {\n          break;\n        }\n        prevContainer = childNodes[offset];\n      }\n  \n      if (offset !== 0 && dom.isText(childNodes[offset - 1])) {\n        var textRangeStart = document.body.createTextRange(), curTextNode = null;\n        textRangeStart.moveToElementText(prevContainer || container);\n        textRangeStart.collapse(!prevContainer);\n        curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;\n  \n        var pointTester = textRange.duplicate();\n        pointTester.setEndPoint('StartToStart', textRangeStart);\n        var textCount = pointTester.text.replace(/[\\r\\n]/g, '').length;\n  \n        while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        /* jshint ignore:start */\n        var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack\n        /* jshint ignore:end */\n  \n        if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&\n            textCount === curTextNode.nodeValue.length) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        container = curTextNode;\n        offset = textCount;\n      }\n  \n      return {\n        cont: container,\n        offset: offset\n      };\n    };\n    \n    /**\n     * return TextRange from boundary point (inspired by google closure-library)\n     * @param {BoundaryPoint} point\n     * @return {TextRange}\n     */\n    var pointToTextRange = function (point) {\n      var textRangeInfo = function (container, offset) {\n        var node, isCollapseToStart;\n  \n        if (dom.isText(container)) {\n          var prevTextNodes = dom.listPrev(container, func.not(dom.isText));\n          var prevContainer = list.last(prevTextNodes).previousSibling;\n          node =  prevContainer || container.parentNode;\n          offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);\n          isCollapseToStart = !prevContainer;\n        } else {\n          node = container.childNodes[offset] || container;\n          if (dom.isText(node)) {\n            return textRangeInfo(node, 0);\n          }\n  \n          offset = 0;\n          isCollapseToStart = false;\n        }\n  \n        return {\n          node: node,\n          collapseToStart: isCollapseToStart,\n          offset: offset\n        };\n      };\n  \n      var textRange = document.body.createTextRange();\n      var info = textRangeInfo(point.node, point.offset);\n  \n      textRange.moveToElementText(info.node);\n      textRange.collapse(info.collapseToStart);\n      textRange.moveStart('character', info.offset);\n      return textRange;\n    };\n    \n    /**\n     * Wrapped Range\n     *\n     * @constructor\n     * @param {Node} sc - start container\n     * @param {Number} so - start offset\n     * @param {Node} ec - end container\n     * @param {Number} eo - end offset\n     */\n    var WrappedRange = function (sc, so, ec, eo) {\n      this.sc = sc;\n      this.so = so;\n      this.ec = ec;\n      this.eo = eo;\n  \n      // nativeRange: get nativeRange from sc, so, ec, eo\n      var nativeRange = function () {\n        if (agent.isW3CRangeSupport) {\n          var w3cRange = document.createRange();\n          w3cRange.setStart(sc, so);\n          w3cRange.setEnd(ec, eo);\n\n          return w3cRange;\n        } else {\n          var textRange = pointToTextRange({\n            node: sc,\n            offset: so\n          });\n\n          textRange.setEndPoint('EndToEnd', pointToTextRange({\n            node: ec,\n            offset: eo\n          }));\n\n          return textRange;\n        }\n      };\n\n      this.getPoints = function () {\n        return {\n          sc: sc,\n          so: so,\n          ec: ec,\n          eo: eo\n        };\n      };\n\n      this.getStartPoint = function () {\n        return {\n          node: sc,\n          offset: so\n        };\n      };\n\n      this.getEndPoint = function () {\n        return {\n          node: ec,\n          offset: eo\n        };\n      };\n\n      /**\n       * select update visible range\n       */\n      this.select = function () {\n        var nativeRng = nativeRange();\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (selection.rangeCount > 0) {\n            selection.removeAllRanges();\n          }\n          selection.addRange(nativeRng);\n        } else {\n          nativeRng.select();\n        }\n        \n        return this;\n      };\n\n      /**\n       * Moves the scrollbar to start container(sc) of current range\n       *\n       * @return {WrappedRange}\n       */\n      this.scrollIntoView = function (container) {\n        var height = $(container).height();\n        if (container.scrollTop + height < this.sc.offsetTop) {\n          container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);\n        }\n\n        return this;\n      };\n\n      /**\n       * @return {WrappedRange}\n       */\n      this.normalize = function () {\n\n        /**\n         * @param {BoundaryPoint} point\n         * @param {Boolean} isLeftToRight\n         * @return {BoundaryPoint}\n         */\n        var getVisiblePoint = function (point, isLeftToRight) {\n          if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||\n              (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {\n            return point;\n          }\n\n          // point on block's edge\n          var block = dom.ancestor(point.node, dom.isBlock);\n          if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||\n              ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {\n\n            // returns point already on visible point\n            if (dom.isVisiblePoint(point)) {\n              return point;\n            }\n            // reverse direction \n            isLeftToRight = !isLeftToRight;\n          }\n\n          var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) :\n                                          dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);\n          return nextPoint || point;\n        };\n\n        var endPoint = getVisiblePoint(this.getEndPoint(), false);\n        var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n\n      /**\n       * returns matched nodes on range\n       *\n       * @param {Function} [pred] - predicate function\n       * @param {Object} [options]\n       * @param {Boolean} [options.includeAncestor]\n       * @param {Boolean} [options.fullyContains]\n       * @return {Node[]}\n       */\n      this.nodes = function (pred, options) {\n        pred = pred || func.ok;\n\n        var includeAncestor = options && options.includeAncestor;\n        var fullyContains = options && options.fullyContains;\n\n        // TODO compare points and sort\n        var startPoint = this.getStartPoint();\n        var endPoint = this.getEndPoint();\n\n        var nodes = [];\n        var leftEdgeNodes = [];\n\n        dom.walkPoint(startPoint, endPoint, function (point) {\n          if (dom.isEditable(point.node)) {\n            return;\n          }\n\n          var node;\n          if (fullyContains) {\n            if (dom.isLeftEdgePoint(point)) {\n              leftEdgeNodes.push(point.node);\n            }\n            if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {\n              node = point.node;\n            }\n          } else if (includeAncestor) {\n            node = dom.ancestor(point.node, pred);\n          } else {\n            node = point.node;\n          }\n\n          if (node && pred(node)) {\n            nodes.push(node);\n          }\n        }, true);\n\n        return list.unique(nodes);\n      };\n\n      /**\n       * returns commonAncestor of range\n       * @return {Element} - commonAncestor\n       */\n      this.commonAncestor = function () {\n        return dom.commonAncestor(sc, ec);\n      };\n\n      /**\n       * returns expanded range by pred\n       *\n       * @param {Function} pred - predicate function\n       * @return {WrappedRange}\n       */\n      this.expand = function (pred) {\n        var startAncestor = dom.ancestor(sc, pred);\n        var endAncestor = dom.ancestor(ec, pred);\n\n        if (!startAncestor && !endAncestor) {\n          return new WrappedRange(sc, so, ec, eo);\n        }\n\n        var boundaryPoints = this.getPoints();\n\n        if (startAncestor) {\n          boundaryPoints.sc = startAncestor;\n          boundaryPoints.so = 0;\n        }\n\n        if (endAncestor) {\n          boundaryPoints.ec = endAncestor;\n          boundaryPoints.eo = dom.nodeLength(endAncestor);\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * @param {Boolean} isCollapseToStart\n       * @return {WrappedRange}\n       */\n      this.collapse = function (isCollapseToStart) {\n        if (isCollapseToStart) {\n          return new WrappedRange(sc, so, sc, so);\n        } else {\n          return new WrappedRange(ec, eo, ec, eo);\n        }\n      };\n\n      /**\n       * splitText on range\n       */\n      this.splitText = function () {\n        var isSameContainer = sc === ec;\n        var boundaryPoints = this.getPoints();\n\n        if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {\n          ec.splitText(eo);\n        }\n\n        if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {\n          boundaryPoints.sc = sc.splitText(so);\n          boundaryPoints.so = 0;\n\n          if (isSameContainer) {\n            boundaryPoints.ec = boundaryPoints.sc;\n            boundaryPoints.eo = eo - so;\n          }\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * delete contents on range\n       * @return {WrappedRange}\n       */\n      this.deleteContents = function () {\n        if (this.isCollapsed()) {\n          return this;\n        }\n\n        var rng = this.splitText();\n        var nodes = rng.nodes(null, {\n          fullyContains: true\n        });\n\n        // find new cursor point\n        var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {\n          return !list.contains(nodes, point.node);\n        });\n\n        var emptyParents = [];\n        $.each(nodes, function (idx, node) {\n          // find empty parents\n          var parent = node.parentNode;\n          if (point.node !== parent && dom.nodeLength(parent) === 1) {\n            emptyParents.push(parent);\n          }\n          dom.remove(node, false);\n        });\n\n        // remove empty parents\n        $.each(emptyParents, function (idx, node) {\n          dom.remove(node, false);\n        });\n\n        return new WrappedRange(\n          point.node,\n          point.offset,\n          point.node,\n          point.offset\n        ).normalize();\n      };\n      \n      /**\n       * makeIsOn: return isOn(pred) function\n       */\n      var makeIsOn = function (pred) {\n        return function () {\n          var ancestor = dom.ancestor(sc, pred);\n          return !!ancestor && (ancestor === dom.ancestor(ec, pred));\n        };\n      };\n  \n      // isOnEditable: judge whether range is on editable or not\n      this.isOnEditable = makeIsOn(dom.isEditable);\n      // isOnList: judge whether range is on list node or not\n      this.isOnList = makeIsOn(dom.isList);\n      // isOnAnchor: judge whether range is on anchor node or not\n      this.isOnAnchor = makeIsOn(dom.isAnchor);\n      // isOnAnchor: judge whether range is on cell node or not\n      this.isOnCell = makeIsOn(dom.isCell);\n\n      /**\n       * @param {Function} pred\n       * @return {Boolean}\n       */\n      this.isLeftEdgeOf = function (pred) {\n        if (!dom.isLeftEdgePoint(this.getStartPoint())) {\n          return false;\n        }\n\n        var node = dom.ancestor(this.sc, pred);\n        return node && dom.isLeftEdgeOf(this.sc, node);\n      };\n\n      /**\n       * returns whether range was collapsed or not\n       */\n      this.isCollapsed = function () {\n        return sc === ec && so === eo;\n      };\n\n      /**\n       * wrap inline nodes which children of body with paragraph\n       *\n       * @return {WrappedRange}\n       */\n      this.wrapBodyInlineWithPara = function () {\n        if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {\n          sc.innerHTML = dom.emptyPara;\n          return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);\n        }\n\n        /**\n         * [workaround] firefox often create range on not visible point. so normalize here.\n         *  - firefox: |<p>text</p>|\n         *  - chrome: <p>|text|</p>\n         */\n        var rng = this.normalize();\n        if (dom.isParaInline(sc) || dom.isPara(sc)) {\n          return rng;\n        }\n\n        // find inline top ancestor\n        var topAncestor;\n        if (dom.isInline(rng.sc)) {\n          var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));\n          topAncestor = list.last(ancestors);\n          if (!dom.isInline(topAncestor)) {\n            topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];\n          }\n        } else {\n          topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];\n        }\n\n        // siblings not in paragraph\n        var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();\n        inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));\n\n        // wrap with paragraph\n        if (inlineSiblings.length) {\n          var para = dom.wrap(list.head(inlineSiblings), 'p');\n          dom.appendChildNodes(para, list.tail(inlineSiblings));\n        }\n\n        return this.normalize();\n      };\n\n      /**\n       * insert node at current cursor\n       *\n       * @param {Node} node\n       * @return {Node}\n       */\n      this.insertNode = function (node) {\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n        var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));\n\n        if (info.rightNode) {\n          info.rightNode.parentNode.insertBefore(node, info.rightNode);\n        } else {\n          info.container.appendChild(node);\n        }\n\n        return node;\n      };\n\n      /**\n       * insert html at current cursor\n       */\n      this.pasteHTML = function (markup) {\n        var contentsContainer = $('<div></div>').html(markup)[0];\n        var childNodes = list.from(contentsContainer.childNodes);\n\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n\n        return childNodes.reverse().map(function (childNode) {\n          return rng.insertNode(childNode);\n        }).reverse();\n      };\n  \n      /**\n       * returns text in range\n       *\n       * @return {String}\n       */\n      this.toString = function () {\n        var nativeRng = nativeRange();\n        return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;\n      };\n\n      /**\n       * returns range for word before cursor\n       *\n       * @param {Boolean} [findAfter] - find after cursor, default: false\n       * @return {WrappedRange}\n       */\n      this.getWordRange = function (findAfter) {\n        var endPoint = this.getEndPoint();\n\n        if (!dom.isCharPoint(endPoint)) {\n          return this;\n        }\n\n        var startPoint = dom.prevPointUntil(endPoint, function (point) {\n          return !dom.isCharPoint(point);\n        });\n\n        if (findAfter) {\n          endPoint = dom.nextPointUntil(endPoint, function (point) {\n            return !dom.isCharPoint(point);\n          });\n        }\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n  \n      /**\n       * create offsetPath bookmark\n       *\n       * @param {Node} editable\n       */\n      this.bookmark = function (editable) {\n        return {\n          s: {\n            path: dom.makeOffsetPath(editable, sc),\n            offset: so\n          },\n          e: {\n            path: dom.makeOffsetPath(editable, ec),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * create offsetPath bookmark base on paragraph\n       *\n       * @param {Node[]} paras\n       */\n      this.paraBookmark = function (paras) {\n        return {\n          s: {\n            path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),\n            offset: so\n          },\n          e: {\n            path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * getClientRects\n       * @return {Rect[]}\n       */\n      this.getClientRects = function () {\n        var nativeRng = nativeRange();\n        return nativeRng.getClientRects();\n      };\n    };\n\n  /**\n   * @class core.range\n   *\n   * Data structure\n   *  * BoundaryPoint: a point of dom tree\n   *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range\n   *\n   * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position\n   *\n   * @singleton\n   * @alternateClassName range\n   */\n    return {\n      /**\n       * create Range Object From arguments or Browser Selection\n       *\n       * @param {Node} sc - start container\n       * @param {Number} so - start offset\n       * @param {Node} ec - end container\n       * @param {Number} eo - end offset\n       * @return {WrappedRange}\n       */\n      create: function (sc, so, ec, eo) {\n        if (arguments.length === 4) {\n          return new WrappedRange(sc, so, ec, eo);\n        } else if (arguments.length === 2) { //collapsed\n          ec = sc;\n          eo = so;\n          return new WrappedRange(sc, so, ec, eo);\n        } else {\n          var wrappedRange = this.createFromSelection();\n          if (!wrappedRange && arguments.length === 1) {\n            wrappedRange = this.createFromNode(arguments[0]);\n            return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);\n          }\n          return wrappedRange;\n        }\n      },\n\n      createFromSelection: function () {\n        var sc, so, ec, eo;\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (!selection || selection.rangeCount === 0) {\n            return null;\n          } else if (dom.isBody(selection.anchorNode)) {\n            // Firefox: returns entire body as range on initialization.\n            // We won't never need it.\n            return null;\n          }\n\n          var nativeRng = selection.getRangeAt(0);\n          sc = nativeRng.startContainer;\n          so = nativeRng.startOffset;\n          ec = nativeRng.endContainer;\n          eo = nativeRng.endOffset;\n        } else { // IE8: TextRange\n          var textRange = document.selection.createRange();\n          var textRangeEnd = textRange.duplicate();\n          textRangeEnd.collapse(false);\n          var textRangeStart = textRange;\n          textRangeStart.collapse(true);\n\n          var startPoint = textRangeToPoint(textRangeStart, true),\n          endPoint = textRangeToPoint(textRangeEnd, false);\n\n          // same visible point case: range was collapsed.\n          if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&\n              dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&\n              endPoint.node.nextSibling === startPoint.node) {\n            startPoint = endPoint;\n          }\n\n          sc = startPoint.cont;\n          so = startPoint.offset;\n          ec = endPoint.cont;\n          eo = endPoint.offset;\n        }\n\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from node\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNode: function (node) {\n        var sc = node;\n        var so = 0;\n        var ec = node;\n        var eo = dom.nodeLength(ec);\n\n        // browsers can't target a picture or void node\n        if (dom.isVoid(sc)) {\n          so = dom.listPrev(sc).length - 1;\n          sc = sc.parentNode;\n        }\n        if (dom.isBR(ec)) {\n          eo = dom.listPrev(ec).length - 1;\n          ec = ec.parentNode;\n        } else if (dom.isVoid(ec)) {\n          eo = dom.listPrev(ec).length;\n          ec = ec.parentNode;\n        }\n\n        return this.create(sc, so, ec, eo);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeBefore: function (node) {\n        return this.createFromNode(node).collapse(true);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeAfter: function (node) {\n        return this.createFromNode(node).collapse();\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from bookmark\n       *\n       * @param {Node} editable\n       * @param {Object} bookmark\n       * @return {WrappedRange}\n       */\n      createFromBookmark: function (editable, bookmark) {\n        var sc = dom.fromOffsetPath(editable, bookmark.s.path);\n        var so = bookmark.s.offset;\n        var ec = dom.fromOffsetPath(editable, bookmark.e.path);\n        var eo = bookmark.e.offset;\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       *\n       * create WrappedRange from paraBookmark\n       *\n       * @param {Object} bookmark\n       * @param {Node[]} paras\n       * @return {WrappedRange}\n       */\n      createFromParaBookmark: function (bookmark, paras) {\n        var so = bookmark.s.offset;\n        var eo = bookmark.e.offset;\n        var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);\n        var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);\n\n        return new WrappedRange(sc, so, ec, eo);\n      }\n    };\n  })();\n\n  /**\n   * @class core.async\n   *\n   * Async functions which returns `Promise`\n   *\n   * @singleton\n   * @alternateClassName async\n   */\n  var async = (function () {\n    /**\n     * @method readFileAsDataURL\n     *\n     * read contents of file as representing URL\n     *\n     * @param {File} file\n     * @return {Promise} - then: dataUrl\n     */\n    var readFileAsDataURL = function (file) {\n      return $.Deferred(function (deferred) {\n        $.extend(new FileReader(), {\n          onload: function (e) {\n            var dataURL = e.target.result;\n            deferred.resolve(dataURL);\n          },\n          onerror: function () {\n            deferred.reject(this);\n          }\n        }).readAsDataURL(file);\n      }).promise();\n    };\n  \n    /**\n     * @method createImage\n     *\n     * create `<image>` from url string\n     *\n     * @param {String} url\n     * @return {Promise} - then: $image\n     */\n    var createImage = function (url) {\n      return $.Deferred(function (deferred) {\n        var $img = $('<img>');\n\n        $img.one('load', function () {\n          $img.off('error abort');\n          deferred.resolve($img);\n        }).one('error abort', function () {\n          $img.off('load').detach();\n          deferred.reject($img);\n        }).css({\n          display: 'none'\n        }).appendTo(document.body).attr('src', url);\n      }).promise();\n    };\n\n    return {\n      readFileAsDataURL: readFileAsDataURL,\n      createImage: createImage\n    };\n  })();\n\n  /**\n   * @class editing.History\n   *\n   * Editor History\n   *\n   */\n  var History = function ($editable) {\n    var stack = [], stackOffset = -1;\n    var editable = $editable[0];\n\n    var makeSnapshot = function () {\n      var rng = range.create(editable);\n      var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};\n\n      return {\n        contents: $editable.html(),\n        bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)\n      };\n    };\n\n    var applySnapshot = function (snapshot) {\n      if (snapshot.contents !== null) {\n        $editable.html(snapshot.contents);\n      }\n      if (snapshot.bookmark !== null) {\n        range.createFromBookmark(editable, snapshot.bookmark).select();\n      }\n    };\n\n    /**\n    * @method rewind\n    * Rewinds the history stack back to the first snapshot taken.\n    * Leaves the stack intact, so that \"Redo\" can still be used.\n    */\n    this.rewind = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      // Return to the first available snapshot.\n      stackOffset = 0;\n\n      // Apply that snapshot.\n      applySnapshot(stack[stackOffset]);\n    };\n\n    /**\n    * @method reset\n    * Resets the history stack completely; reverting to an empty editor.\n    */\n    this.reset = function () {\n      // Clear the stack.\n      stack = [];\n\n      // Restore stackOffset to its original value.\n      stackOffset = -1;\n\n      // Clear the editable area.\n      $editable.html('');\n\n      // Record our first snapshot (of nothing).\n      this.recordUndo();\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      if (0 < stackOffset) {\n        stackOffset--;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      if (stack.length - 1 > stackOffset) {\n        stackOffset++;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * recorded undo\n     */\n    this.recordUndo = function () {\n      stackOffset++;\n\n      // Wash out stack after stackOffset\n      if (stack.length > stackOffset) {\n        stack = stack.slice(0, stackOffset);\n      }\n\n      // Create new snapshot and push it to the end\n      stack.push(makeSnapshot());\n    };\n  };\n\n  /**\n   * @class editing.Style\n   *\n   * Style\n   *\n   */\n  var Style = function () {\n    /**\n     * @method jQueryCSS\n     *\n     * [workaround] for old jQuery\n     * passing an array of style properties to .css()\n     * will result in an object of property-value pairs.\n     * (compability with version < 1.9)\n     *\n     * @private\n     * @param  {jQuery} $obj\n     * @param  {Array} propertyNames - An array of one or more CSS properties.\n     * @return {Object}\n     */\n    var jQueryCSS = function ($obj, propertyNames) {\n      if (agent.jqueryVersion < 1.9) {\n        var result = {};\n        $.each(propertyNames, function (idx, propertyName) {\n          result[propertyName] = $obj.css(propertyName);\n        });\n        return result;\n      }\n      return $obj.css.call($obj, propertyNames);\n    };\n\n    /**\n     * returns style object from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.fromNode = function ($node) {\n      var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];\n      var styleInfo = jQueryCSS($node, properties) || {};\n      styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);\n      return styleInfo;\n    };\n\n    /**\n     * paragraph level style\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} styleInfo\n     */\n    this.stylePara = function (rng, styleInfo) {\n      $.each(rng.nodes(dom.isPara, {\n        includeAncestor: true\n      }), function (idx, para) {\n        $(para).css(styleInfo);\n      });\n    };\n\n    /**\n     * insert and returns styleNodes on range.\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} [options] - options for styleNodes\n     * @param {String} [options.nodeName] - default: `SPAN`\n     * @param {Boolean} [options.expandClosestSibling] - default: `false`\n     * @param {Boolean} [options.onlyPartialContains] - default: `false`\n     * @return {Node[]}\n     */\n    this.styleNodes = function (rng, options) {\n      rng = rng.splitText();\n\n      var nodeName = options && options.nodeName || 'SPAN';\n      var expandClosestSibling = !!(options && options.expandClosestSibling);\n      var onlyPartialContains = !!(options && options.onlyPartialContains);\n\n      if (rng.isCollapsed()) {\n        return [rng.insertNode(dom.create(nodeName))];\n      }\n\n      var pred = dom.makePredByNodeName(nodeName);\n      var nodes = rng.nodes(dom.isText, {\n        fullyContains: true\n      }).map(function (text) {\n        return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);\n      });\n\n      if (expandClosestSibling) {\n        if (onlyPartialContains) {\n          var nodesInRange = rng.nodes();\n          // compose with partial contains predication\n          pred = func.and(pred, function (node) {\n            return list.contains(nodesInRange, node);\n          });\n        }\n\n        return nodes.map(function (node) {\n          var siblings = dom.withClosestSiblings(node, pred);\n          var head = list.head(siblings);\n          var tails = list.tail(siblings);\n          $.each(tails, function (idx, elem) {\n            dom.appendChildNodes(head, elem.childNodes);\n            dom.remove(elem);\n          });\n          return list.head(siblings);\n        });\n      } else {\n        return nodes;\n      }\n    };\n\n    /**\n     * get current style on cursor\n     *\n     * @param {WrappedRange} rng\n     * @return {Object} - object contains style properties.\n     */\n    this.current = function (rng) {\n      var $cont = $(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);\n      var styleInfo = this.fromNode($cont);\n\n      // document.queryCommandState for toggle state\n      // [workaround] prevent Firefox nsresult: \"0x80004005 (NS_ERROR_FAILURE)\"\n      try {\n        styleInfo = $.extend(styleInfo, {\n          'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',\n          'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',\n          'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',\n          'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',\n          'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',\n          'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal'\n        });\n      } catch (e) {}\n\n      // list-style-type to list-style(unordered, ordered)\n      if (!rng.isOnList()) {\n        styleInfo['list-style'] = 'none';\n      } else {\n        var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];\n        var isUnordered = $.inArray(styleInfo['list-style-type'], orderedTypes) > -1;\n        styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';\n      }\n\n      var para = dom.ancestor(rng.sc, dom.isPara);\n      if (para && para.style['line-height']) {\n        styleInfo['line-height'] = para.style.lineHeight;\n      } else {\n        var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);\n        styleInfo['line-height'] = lineHeight.toFixed(1);\n      }\n\n      styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);\n      styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);\n      styleInfo.range = rng;\n\n      return styleInfo;\n    };\n  };\n\n\n  /**\n   * @class editing.Bullet\n   *\n   * @alternateClassName Bullet\n   */\n  var Bullet = function () {\n    var self = this;\n\n    /**\n     * toggle ordered list\n     */\n    this.insertOrderedList = function (editable) {\n      this.toggleList('OL', editable);\n    };\n\n    /**\n     * toggle unordered list\n     */\n    this.insertUnorderedList = function (editable) {\n      this.toggleList('UL', editable);\n    };\n\n    /**\n     * indent\n     */\n    this.indent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.wrapList(paras, head.parentNode.nodeName);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              return (parseInt(val, 10) || 0) + 25;\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * outdent\n     */\n    this.outdent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.releaseList([paras]);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              val = (parseInt(val, 10) || 0);\n              return val > 25 ? val - 25 : '';\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * toggle list\n     *\n     * @param {String} listName - OL or UL\n     */\n    this.toggleList = function (listName, editable) {\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var bookmark = rng.paraBookmark(paras);\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      // paragraph to list\n      if (list.find(paras, dom.isPurePara)) {\n        var wrappedParas = [];\n        $.each(clustereds, function (idx, paras) {\n          wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));\n        });\n        paras = wrappedParas;\n      // list to paragraph or change list style\n      } else {\n        var diffLists = rng.nodes(dom.isList, {\n          includeAncestor: true\n        }).filter(function (listNode) {\n          return !$.nodeName(listNode, listName);\n        });\n\n        if (diffLists.length) {\n          $.each(diffLists, function (idx, listNode) {\n            dom.replace(listNode, listName);\n          });\n        } else {\n          paras = this.releaseList(clustereds, true);\n        }\n      }\n\n      range.createFromParaBookmark(bookmark, paras).select();\n    };\n\n    /**\n     * @param {Node[]} paras\n     * @param {String} listName\n     * @return {Node[]}\n     */\n    this.wrapList = function (paras, listName) {\n      var head = list.head(paras);\n      var last = list.last(paras);\n\n      var prevList = dom.isList(head.previousSibling) && head.previousSibling;\n      var nextList = dom.isList(last.nextSibling) && last.nextSibling;\n\n      var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);\n\n      // P to LI\n      paras = paras.map(function (para) {\n        return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;\n      });\n\n      // append to list(<ul>, <ol>)\n      dom.appendChildNodes(listNode, paras);\n\n      if (nextList) {\n        dom.appendChildNodes(listNode, list.from(nextList.childNodes));\n        dom.remove(nextList);\n      }\n\n      return paras;\n    };\n\n    /**\n     * @method releaseList\n     *\n     * @param {Array[]} clustereds\n     * @param {Boolean} isEscapseToBody\n     * @return {Node[]}\n     */\n    this.releaseList = function (clustereds, isEscapseToBody) {\n      var releasedParas = [];\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        var last = list.last(paras);\n\n        var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :\n                                         head.parentNode;\n        var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {\n          node: last.parentNode,\n          offset: dom.position(last) + 1\n        }, {\n          isSkipPaddingBlankHTML: true\n        }) : null;\n\n        var middleList = dom.splitTree(headList, {\n          node: head.parentNode,\n          offset: dom.position(head)\n        }, {\n          isSkipPaddingBlankHTML: true\n        });\n\n        paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :\n                                  list.from(middleList.childNodes).filter(dom.isLi);\n\n        // LI to P\n        if (isEscapseToBody || !dom.isList(headList.parentNode)) {\n          paras = paras.map(function (para) {\n            return dom.replace(para, 'P');\n          });\n        }\n\n        $.each(list.from(paras).reverse(), function (idx, para) {\n          dom.insertAfter(para, headList);\n        });\n\n        // remove empty lists\n        var rootLists = list.compact([headList, middleList, lastList]);\n        $.each(rootLists, function (idx, rootList) {\n          var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));\n          $.each(listNodes.reverse(), function (idx, listNode) {\n            if (!dom.nodeLength(listNode)) {\n              dom.remove(listNode, true);\n            }\n          });\n        });\n\n        releasedParas = releasedParas.concat(paras);\n      });\n\n      return releasedParas;\n    };\n  };\n\n\n  /**\n   * @class editing.Typing\n   *\n   * Typing\n   *\n   */\n  var Typing = function () {\n\n    // a Bullet instance to toggle lists off\n    var bullet = new Bullet();\n\n    /**\n     * insert tab\n     *\n     * @param {WrappedRange} rng\n     * @param {Number} tabsize\n     */\n    this.insertTab = function (rng, tabsize) {\n      var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));\n      rng = rng.deleteContents();\n      rng.insertNode(tab, true);\n\n      rng = range.create(tab, tabsize);\n      rng.select();\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = function (editable) {\n      var rng = range.create(editable);\n\n      // deleteContents on range.\n      rng = rng.deleteContents();\n\n      // Wrap range if it needs to be wrapped by paragraph\n      rng = rng.wrapBodyInlineWithPara();\n\n      // finding paragraph\n      var splitRoot = dom.ancestor(rng.sc, dom.isPara);\n\n      var nextPara;\n      // on paragraph: split paragraph\n      if (splitRoot) {\n        // if it is an empty line with li\n        if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {\n          // toogle UL/OL and escape\n          bullet.toggleList(splitRoot.parentNode.nodeName);\n          return;\n        // if it is an empty line with para on blockquote\n        } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {\n          // escape blockquote\n          dom.insertAfter(splitRoot, splitRoot.parentNode);\n          nextPara = splitRoot;\n        // if new line has content (not a line break)\n        } else {\n          nextPara = dom.splitTree(splitRoot, rng.getStartPoint());\n\n          var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);\n          emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));\n\n          $.each(emptyAnchors, function (idx, anchor) {\n            dom.remove(anchor);\n          });\n\n          // replace empty heading or pre with P tag\n          if ((dom.isHeading(nextPara) || dom.isPre(nextPara)) && dom.isEmpty(nextPara)) {\n            nextPara = dom.replace(nextPara, 'p');\n          }\n        }\n      // no paragraph: insert empty paragraph\n      } else {\n        var next = rng.sc.childNodes[rng.so];\n        nextPara = $(dom.emptyPara)[0];\n        if (next) {\n          rng.sc.insertBefore(nextPara, next);\n        } else {\n          rng.sc.appendChild(nextPara);\n        }\n      }\n\n      range.create(nextPara, 0).normalize().select().scrollIntoView(editable);\n    };\n  };\n\n  /**\n   * @class editing.Table\n   *\n   * Table\n   *\n   */\n  var Table = function () {\n    /**\n     * handle tab key\n     *\n     * @param {WrappedRange} rng\n     * @param {Boolean} isShift\n     */\n    this.tab = function (rng, isShift) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var table = dom.ancestor(cell, dom.isTable);\n      var cells = dom.listDescendant(table, dom.isCell);\n\n      var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);\n      if (nextCell) {\n        range.create(nextCell, 0).select();\n      }\n    };\n\n    /**\n     * create empty table element\n     *\n     * @param {Number} rowCount\n     * @param {Number} colCount\n     * @return {Node}\n     */\n    this.createTable = function (colCount, rowCount, options) {\n      var tds = [], tdHTML;\n      for (var idxCol = 0; idxCol < colCount; idxCol++) {\n        tds.push('<td>' + dom.blank + '</td>');\n      }\n      tdHTML = tds.join('');\n\n      var trs = [], trHTML;\n      for (var idxRow = 0; idxRow < rowCount; idxRow++) {\n        trs.push('<tr>' + tdHTML + '</tr>');\n      }\n      trHTML = trs.join('');\n      var $table = $('<table>' + trHTML + '</table>');\n      if (options && options.tableClassName) {\n        $table.addClass(options.tableClassName);\n      }\n\n      return $table[0];\n    };\n  };\n\n\n  var KEY_BOGUS = 'bogus';\n\n  /**\n   * @class Editor\n   */\n  var Editor = function (context) {\n    var self = this;\n\n    var $note = context.layoutInfo.note;\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var editable = $editable[0];\n    var lastRange = null;\n\n    var style = new Style();\n    var table = new Table();\n    var typing = new Typing();\n    var bullet = new Bullet();\n    var history = new History($editable);\n\n    this.initialize = function () {\n      // bind custom events\n      $editable.on('keydown', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          context.triggerEvent('enter', event);\n        }\n        context.triggerEvent('keydown', event);\n\n        if (options.shortcuts && !event.isDefaultPrevented()) {\n          self.handleKeyMap(event);\n        }\n      }).on('keyup', function (event) {\n        context.triggerEvent('keyup', event);\n      }).on('focus', function (event) {\n        context.triggerEvent('focus', event);\n      }).on('blur', function (event) {\n        context.triggerEvent('blur', event);\n      }).on('mousedown', function (event) {\n        context.triggerEvent('mousedown', event);\n      }).on('mouseup', function (event) {\n        context.triggerEvent('mouseup', event);\n      }).on('scroll', function (event) {\n        context.triggerEvent('scroll', event);\n      }).on('paste', function (event) {\n        context.triggerEvent('paste', event);\n      });\n\n      // init content before set event\n      $editable.html(dom.html($note) || dom.emptyPara);\n\n      // [workaround] IE doesn't have input events for contentEditable\n      // - see: https://goo.gl/4bfIvA\n      var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';\n      $editable.on(changeEventName, function () {\n        context.triggerEvent('change', $editable.html());\n      });\n\n      $editor.on('focusin', function (event) {\n        context.triggerEvent('focusin', event);\n      }).on('focusout', function (event) {\n        context.triggerEvent('focusout', event);\n      });\n\n      if (!options.airMode && options.height) {\n        this.setHeight(options.height);\n      }\n      if (!options.airMode && options.maxHeight) {\n        $editable.css('max-height', options.maxHeight);\n      }\n      if (!options.airMode && options.minHeight) {\n        $editable.css('min-height', options.minHeight);\n      }\n\n      history.recordUndo();\n    };\n\n    this.destroy = function () {\n      $editable.off();\n    };\n\n    this.handleKeyMap = function (event) {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      var keys = [];\n\n      if (event.metaKey) { keys.push('CMD'); }\n      if (event.ctrlKey && !event.altKey) { keys.push('CTRL'); }\n      if (event.shiftKey) { keys.push('SHIFT'); }\n\n      var keyName = key.nameFromCode[event.keyCode];\n      if (keyName) {\n        keys.push(keyName);\n      }\n\n      var eventName = keyMap[keys.join('+')];\n      if (eventName) {\n        event.preventDefault();\n        context.invoke(eventName);\n      } else if (key.isEdit(event.keyCode)) {\n        this.afterCommand();\n      }\n    };\n\n    /**\n     * create range\n     * @return {WrappedRange}\n     */\n    this.createRange = function () {\n      this.focus();\n      return range.create(editable);\n    };\n\n    /**\n     * saveRange\n     *\n     * save current range\n     *\n     * @param {Boolean} [thenCollapse=false]\n     */\n    this.saveRange = function (thenCollapse) {\n      lastRange = this.createRange();\n      if (thenCollapse) {\n        lastRange.collapse().select();\n      }\n    };\n\n    /**\n     * restoreRange\n     *\n     * restore lately range\n     */\n    this.restoreRange = function () {\n      if (lastRange) {\n        lastRange.select();\n        this.focus();\n      }\n    };\n\n    this.saveTarget = function (node) {\n      $editable.data('target', node);\n    };\n\n    this.clearTarget = function () {\n      $editable.removeData('target');\n    };\n\n    this.restoreTarget = function () {\n      return $editable.data('target');\n    };\n\n    /**\n     * currentStyle\n     *\n     * current style\n     * @return {Object|Boolean} unfocus\n     */\n    this.currentStyle = function () {\n      var rng = range.create();\n      if (rng) {\n        rng = rng.normalize();\n      }\n      return rng ? style.current(rng) : style.fromNode($editable);\n    };\n\n    /**\n     * style from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.styleFromNode = function ($node) {\n      return style.fromNode($node);\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.undo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.undo', lang.help.undo);\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.redo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.redo', lang.help.redo);\n\n    /**\n     * before command\n     */\n    var beforeCommand = this.beforeCommand = function () {\n      context.triggerEvent('before.command', $editable.html());\n      // keep focus on editable before command execution\n      self.focus();\n    };\n\n    /**\n     * after command\n     * @param {Boolean} isPreventTrigger\n     */\n    var afterCommand = this.afterCommand = function (isPreventTrigger) {\n      history.recordUndo();\n      if (!isPreventTrigger) {\n        context.triggerEvent('change', $editable.html());\n      }\n    };\n\n    /* jshint ignore:start */\n    // native commands(with execCommand), generate function for execCommand\n    var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',\n                    'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',\n                    'formatBlock', 'removeFormat',\n                    'backColor', 'foreColor', 'fontName'];\n\n    for (var idx = 0, len = commands.length; idx < len; idx ++) {\n      this[commands[idx]] = (function (sCmd) {\n        return function (value) {\n          beforeCommand();\n          document.execCommand(sCmd, false, value);\n          afterCommand(true);\n        };\n      })(commands[idx]);\n      context.memo('help.' + commands[idx], lang.help[commands[idx]]);\n    }\n    /* jshint ignore:end */\n\n    /**\n     * handle tab key\n     */\n    this.tab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng);\n      } else {\n        beforeCommand();\n        typing.insertTab(rng, options.tabSize);\n        afterCommand();\n      }\n    };\n    context.memo('help.tab', lang.help.tab);\n\n    /**\n     * handle shift+tab key\n     */\n    this.untab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng, true);\n      }\n    };\n    context.memo('help.untab', lang.help.untab);\n\n    /**\n     * run given function between beforeCommand and afterCommand\n     */\n    this.wrapCommand = function (fn) {\n      return function () {\n        beforeCommand();\n        fn.apply(self, arguments);\n        afterCommand();\n      };\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = this.wrapCommand(function () {\n      typing.insertParagraph(editable);\n    });\n    context.memo('help.insertParagraph', lang.help.insertParagraph);\n\n    this.insertOrderedList = this.wrapCommand(function () {\n      bullet.insertOrderedList(editable);\n    });\n    context.memo('help.insertOrderedList', lang.help.insertOrderedList);\n\n    this.insertUnorderedList = this.wrapCommand(function () {\n      bullet.insertUnorderedList(editable);\n    });\n    context.memo('help.insertUnorderedList', lang.help.insertUnorderedList);\n\n    this.indent = this.wrapCommand(function () {\n      bullet.indent(editable);\n    });\n    context.memo('help.indent', lang.help.indent);\n\n    this.outdent = this.wrapCommand(function () {\n      bullet.outdent(editable);\n    });\n    context.memo('help.outdent', lang.help.outdent);\n\n    /**\n     * insert image\n     *\n     * @param {String} src\n     * @param {String|Function} param\n     * @return {Promise}\n     */\n    this.insertImage = function (src, param) {\n      return async.createImage(src, param).then(function ($image) {\n        beforeCommand();\n\n        if (typeof param === 'function') {\n          param($image);\n        } else {\n          if (typeof param === 'string') {\n            $image.attr('data-filename', param);\n          }\n          $image.css('width', Math.min($editable.width(), $image.width()));\n        }\n\n        $image.show();\n        range.create(editable).insertNode($image[0]);\n        range.createFromNodeAfter($image[0]).select();\n        afterCommand();\n      }).fail(function (e) {\n        context.triggerEvent('image.upload.error', e);\n      });\n    };\n\n    /**\n     * insertImages\n     * @param {File[]} files\n     */\n    this.insertImages = function (files) {\n      $.each(files, function (idx, file) {\n        var filename = file.name;\n        if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {\n          context.triggerEvent('image.upload.error', lang.image.maximumFileSizeError);\n        } else {\n          async.readFileAsDataURL(file).then(function (dataURL) {\n            return self.insertImage(dataURL, filename);\n          }).fail(function () {\n            context.triggerEvent('image.upload.error');\n          });\n        }\n      });\n    };\n\n    /**\n     * insertImagesOrCallback\n     * @param {File[]} files\n     */\n    this.insertImagesOrCallback = function (files) {\n      var callbacks = options.callbacks;\n\n      // If onImageUpload options setted\n      if (callbacks.onImageUpload) {\n        context.triggerEvent('image.upload', files);\n      // else insert Image as dataURL\n      } else {\n        this.insertImages(files);\n      }\n    };\n\n    /**\n     * insertNode\n     * insert node\n     * @param {Node} node\n     */\n    this.insertNode = this.wrapCommand(function (node) {\n      var rng = this.createRange();\n      rng.insertNode(node);\n      range.createFromNodeAfter(node).select();\n    });\n\n    /**\n     * insert text\n     * @param {String} text\n     */\n    this.insertText = this.wrapCommand(function (text) {\n      var rng = this.createRange();\n      var textNode = rng.insertNode(dom.createText(text));\n      range.create(textNode, dom.nodeLength(textNode)).select();\n    });\n\n    /**\n     * return selected plain text\n     * @return {String} text\n     */\n    this.getSelectedText = function () {\n      var rng = this.createRange();\n\n      // if range on anchor, expand range with anchor\n      if (rng.isOnAnchor()) {\n        rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));\n      }\n\n      return rng.toString();\n    };\n\n    /**\n     * paste HTML\n     * @param {String} markup\n     */\n    this.pasteHTML = this.wrapCommand(function (markup) {\n      var contents = this.createRange().pasteHTML(markup);\n      range.createFromNodeAfter(list.last(contents)).select();\n    });\n\n    /**\n     * formatBlock\n     *\n     * @param {String} tagName\n     */\n    this.formatBlock = this.wrapCommand(function (tagName) {\n      // [workaround] for MSIE, IE need `<`\n      tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;\n      document.execCommand('FormatBlock', false, tagName);\n    });\n\n    this.formatPara = function () {\n      this.formatBlock('P');\n    };\n    context.memo('help.formatPara', lang.help.formatPara);\n\n    /* jshint ignore:start */\n    for (var idx = 1; idx <= 6; idx ++) {\n      this['formatH' + idx] = function (idx) {\n        return function () {\n          this.formatBlock('H' + idx);\n        };\n      }(idx);\n      context.memo('help.formatH'+idx, lang.help['formatH' + idx]);\n    };\n    /* jshint ignore:end */\n\n    /**\n     * fontSize\n     *\n     * @param {String} value - px\n     */\n    this.fontSize = function (value) {\n      var rng = this.createRange();\n\n      if (rng && rng.isCollapsed()) {\n        var spans = style.styleNodes(rng);\n        var firstSpan = list.head(spans);\n\n        $(spans).css({\n          'font-size': value + 'px'\n        });\n\n        // [workaround] added styled bogus span for style\n        //  - also bogus character needed for cursor position\n        if (firstSpan && !dom.nodeLength(firstSpan)) {\n          firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;\n          range.createFromNodeAfter(firstSpan.firstChild).select();\n          $editable.data(KEY_BOGUS, firstSpan);\n        }\n      } else {\n        beforeCommand();\n        $(style.styleNodes(rng)).css({\n          'font-size': value + 'px'\n        });\n        afterCommand();\n      }\n    };\n\n    /**\n     * insert horizontal rule\n     */\n    this.insertHorizontalRule = this.wrapCommand(function () {\n      var hrNode = this.createRange().insertNode(dom.create('HR'));\n      if (hrNode.nextSibling) {\n        range.create(hrNode.nextSibling, 0).normalize().select();\n      }\n    });\n    context.memo('help.insertHorizontalRule', lang.help.insertHorizontalRule);\n\n    /**\n     * remove bogus node and character\n     */\n    this.removeBogus = function () {\n      var bogusNode = $editable.data(KEY_BOGUS);\n      if (!bogusNode) {\n        return;\n      }\n\n      var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);\n\n      var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);\n      if (bogusCharIdx !== -1) {\n        textNode.deleteData(bogusCharIdx, 1);\n      }\n\n      if (dom.isEmpty(bogusNode)) {\n        dom.remove(bogusNode);\n      }\n\n      $editable.removeData(KEY_BOGUS);\n    };\n\n    /**\n     * lineHeight\n     * @param {String} value\n     */\n    this.lineHeight = this.wrapCommand(function (value) {\n      style.stylePara(this.createRange(), {\n        lineHeight: value\n      });\n    });\n\n    /**\n     * unlink\n     *\n     * @type command\n     */\n    this.unlink = function () {\n      var rng = this.createRange();\n      if (rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        rng = range.createFromNode(anchor);\n        rng.select();\n\n        beforeCommand();\n        document.execCommand('unlink');\n        afterCommand();\n      }\n    };\n\n    /**\n     * create link (command)\n     *\n     * @param {Object} linkInfo\n     */\n    this.createLink = this.wrapCommand(function (linkInfo) {\n      var linkUrl = linkInfo.url;\n      var linkText = linkInfo.text;\n      var isNewWindow = linkInfo.isNewWindow;\n      var rng = linkInfo.range || this.createRange();\n      var isTextChanged = rng.toString() !== linkText;\n\n      if (options.onCreateLink) {\n        linkUrl = options.onCreateLink(linkUrl);\n      }\n\n      var anchors = [];\n      if (isTextChanged) {\n        rng = rng.deleteContents();\n        var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);\n        anchors.push(anchor);\n      } else {\n        anchors = style.styleNodes(rng, {\n          nodeName: 'A',\n          expandClosestSibling: true,\n          onlyPartialContains: true\n        });\n      }\n\n      $.each(anchors, function (idx, anchor) {\n        $(anchor).attr('href', linkUrl);\n        if (isNewWindow) {\n          $(anchor).attr('target', '_blank');\n        } else {\n          $(anchor).removeAttr('target');\n        }\n      });\n\n      var startRange = range.createFromNodeBefore(list.head(anchors));\n      var startPoint = startRange.getStartPoint();\n      var endRange = range.createFromNodeAfter(list.last(anchors));\n      var endPoint = endRange.getEndPoint();\n\n      range.create(\n        startPoint.node,\n        startPoint.offset,\n        endPoint.node,\n        endPoint.offset\n      ).select();\n    });\n\n    /**\n     * returns link info\n     *\n     * @return {Object}\n     * @return {WrappedRange} return.range\n     * @return {String} return.text\n     * @return {Boolean} [return.isNewWindow=true]\n     * @return {String} [return.url=\"\"]\n     */\n    this.getLinkInfo = function () {\n      var rng = this.createRange().expand(dom.isAnchor);\n\n      // Get the first anchor on range(for edit).\n      var $anchor = $(list.head(rng.nodes(dom.isAnchor)));\n\n      return {\n        range: rng,\n        text: rng.toString(),\n        isNewWindow: $anchor.length ? $anchor.attr('target') === '_blank' : false,\n        url: $anchor.length ? $anchor.attr('href') : ''\n      };\n    };\n\n    /**\n     * setting color\n     *\n     * @param {Object} sObjColor  color code\n     * @param {String} sObjColor.foreColor foreground color\n     * @param {String} sObjColor.backColor background color\n     */\n    this.color = this.wrapCommand(function (colorInfo) {\n      var foreColor = colorInfo.foreColor;\n      var backColor = colorInfo.backColor;\n\n      if (foreColor) { document.execCommand('foreColor', false, foreColor); }\n      if (backColor) { document.execCommand('backColor', false, backColor); }\n    });\n\n    /**\n     * insert Table\n     *\n     * @param {String} dimension of table (ex : \"5x5\")\n     */\n    this.insertTable = this.wrapCommand(function (dim) {\n      var dimension = dim.split('x');\n\n      var rng = this.createRange().deleteContents();\n      rng.insertNode(table.createTable(dimension[0], dimension[1], options));\n    });\n\n    /**\n     * float me\n     *\n     * @param {String} value\n     */\n    this.floatMe = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css('float', value);\n    });\n\n    /**\n     * resize overlay element\n     * @param {String} value\n     */\n    this.resize = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css({\n        width: value * 100 + '%',\n        height: ''\n      });\n    });\n\n    /**\n     * @param {Position} pos\n     * @param {jQuery} $target - target element\n     * @param {Boolean} [bKeepRatio] - keep ratio\n     */\n    this.resizeTo = function (pos, $target, bKeepRatio) {\n      var imageSize;\n      if (bKeepRatio) {\n        var newRatio = pos.y / pos.x;\n        var ratio = $target.data('ratio');\n        imageSize = {\n          width: ratio > newRatio ? pos.x : pos.y / ratio,\n          height: ratio > newRatio ? pos.x * ratio : pos.y\n        };\n      } else {\n        imageSize = {\n          width: pos.x,\n          height: pos.y\n        };\n      }\n\n      $target.css(imageSize);\n    };\n\n    /**\n     * remove media object\n     */\n    this.removeMedia = this.wrapCommand(function () {\n      var $target = $(this.restoreTarget()).detach();\n      context.triggerEvent('media.delete', $target, $editable);\n    });\n\n    /**\n     * returns whether editable area has focus or not.\n     */\n    this.hasFocus = function () {\n      return $editable.is(':focus');\n    };\n\n    /**\n     * set focus\n     */\n    this.focus = function () {\n      // [workaround] Screen will move when page is scolled in IE.\n      //  - do focus when not focused\n      if (!this.hasFocus()) {\n        $editable.focus();\n      }\n    };\n\n    /**\n     * returns whether contents is empty or not.\n     * @return {Boolean}\n     */\n    this.isEmpty = function () {\n      return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();\n    };\n\n    /**\n     * Removes all contents and restores the editable instance to an _emptyPara_.\n     */\n    this.empty = function () {\n      context.invoke('code', dom.emptyPara);\n    };\n\n    /**\n     * set height for editable\n     */\n    this.setHeight = function (height) {\n      $editable.outerHeight(height);\n    };\n  };\n\n  var Clipboard = function (context) {\n    var self = this;\n\n    var $editable = context.layoutInfo.editable;\n\n    this.events = {\n      'summernote.keydown': function (we, e) {\n        if (self.needKeydownHook()) {\n          if ((e.ctrlKey || e.metaKey) && e.keyCode === key.code.V) {\n            context.invoke('editor.saveRange');\n            self.$paste.focus();\n\n            setTimeout(function () {\n              self.pasteByHook();\n            }, 0);\n          }\n        }\n      }\n    };\n\n    this.needKeydownHook = function () {\n      return (agent.isMSIE && agent.browserVersion > 10) || agent.isFF;\n    };\n\n    this.initialize = function () {\n      // [workaround] getting image from clipboard\n      //  - IE11 and Firefox: CTRL+v hook\n      //  - Webkit: event.clipboardData\n      if (this.needKeydownHook()) {\n        this.$paste = $('<div />').attr('contenteditable', true).css({\n          position: 'absolute',\n          left: -100000,\n          opacity: 0\n        });\n        $editable.before(this.$paste);\n\n        this.$paste.on('paste', function (event) {\n          context.triggerEvent('paste', event);\n        });\n      } else {\n        $editable.on('paste', this.pasteByEvent);\n      }\n    };\n\n    this.destroy = function () {\n      if (this.needKeydownHook()) {\n        this.$paste.remove();\n        this.$paste = null;\n      }\n    };\n\n    this.pasteByHook = function () {\n      var node = this.$paste[0].firstChild;\n\n      if (dom.isImg(node)) {\n        var dataURI = node.src;\n        var decodedData = atob(dataURI.split(',')[1]);\n        var array = new Uint8Array(decodedData.length);\n        for (var i = 0; i < decodedData.length; i++) {\n          array[i] = decodedData.charCodeAt(i);\n        }\n\n        var blob = new Blob([array], { type: 'image/png' });\n        blob.name = 'clipboard.png';\n\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n        context.invoke('editor.insertImagesOrCallback', [blob]);\n      } else {\n        var pasteContent = $('<div />').html(this.$paste.html()).html();\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n\n        if (pasteContent) {\n          context.invoke('editor.pasteHTML', pasteContent);\n        }\n      }\n\n      this.$paste.empty();\n    };\n\n    /**\n     * paste by clipboard event\n     *\n     * @param {Event} event\n     */\n    this.pasteByEvent = function (event) {\n      var clipboardData = event.originalEvent.clipboardData;\n      if (clipboardData && clipboardData.items && clipboardData.items.length) {\n        var item = list.head(clipboardData.items);\n        if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {\n          context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);\n        }\n        context.invoke('editor.afterCommand');\n      }\n    };\n  };\n\n  var Dropzone = function (context) {\n    var $document = $(document);\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var $dropzone = $([\n      '<div class=\"note-dropzone\">',\n      '  <div class=\"note-dropzone-message\"/>',\n      '</div>'\n    ].join('')).prependTo($editor);\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.initialize = function () {\n      if (options.disableDragAndDrop) {\n        // prevent default drop event\n        $document.on('drop', function (e) {\n          e.preventDefault();\n        });\n      } else {\n        this.attachDragAndDropEvent();\n      }\n    };\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.attachDragAndDropEvent = function () {\n      var collection = $(),\n          $dropzoneMessage = $dropzone.find('.note-dropzone-message');\n\n      // show dropzone on dragenter when dragging a object to document\n      // -but only if the editor is visible, i.e. has a positive width and height\n      $document.on('dragenter', function (e) {\n        var isCodeview = context.invoke('codeview.isActivated');\n        var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;\n        if (!isCodeview && !collection.length && hasEditorSize) {\n          $editor.addClass('dragover');\n          $dropzone.width($editor.width());\n          $dropzone.height($editor.height());\n          $dropzoneMessage.text(lang.image.dragImageHere);\n        }\n        collection = collection.add(e.target);\n      }).on('dragleave', function (e) {\n        collection = collection.not(e.target);\n        if (!collection.length) {\n          $editor.removeClass('dragover');\n        }\n      }).on('drop', function () {\n        collection = $();\n        $editor.removeClass('dragover');\n      });\n\n      // change dropzone's message on hover.\n      $dropzone.on('dragenter', function () {\n        $dropzone.addClass('hover');\n        $dropzoneMessage.text(lang.image.dropImage);\n      }).on('dragleave', function () {\n        $dropzone.removeClass('hover');\n        $dropzoneMessage.text(lang.image.dragImageHere);\n      });\n\n      // attach dropImage\n      $dropzone.on('drop', function (event) {\n        var dataTransfer = event.originalEvent.dataTransfer;\n\n        if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n          event.preventDefault();\n          $editable.focus();\n          context.invoke('editor.insertImagesOrCallback', dataTransfer.files);\n        } else {\n          $.each(dataTransfer.types, function (idx, type) {\n            var content = dataTransfer.getData(type);\n\n            if (type.toLowerCase().indexOf('text') > -1) {\n              context.invoke('editor.pasteHTML', content);\n            } else {\n              $(content).each(function () {\n                context.invoke('editor.insertNode', this);\n              });\n            }\n          });\n        }\n      }).on('dragover', false); // prevent default dragover event\n    };\n  };\n\n\n  var CodeMirror;\n  if (agent.hasCodeMirror) {\n    if (agent.isSupportAmd) {\n      new Promise(function(resolve) { resolve(); }).then(function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(149)]; (function (cm) {\n        CodeMirror = cm;\n      }.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}).catch(__webpack_require__.oe);\n    } else {\n      CodeMirror = window.CodeMirror;\n    }\n  }\n\n  /**\n   * @class Codeview\n   */\n  var Codeview = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n    var options = context.options;\n\n    this.sync = function () {\n      var isCodeview = this.isActivated();\n      if (isCodeview && agent.hasCodeMirror) {\n        $codable.data('cmEditor').save();\n      }\n    };\n\n    /**\n     * @return {Boolean}\n     */\n    this.isActivated = function () {\n      return $editor.hasClass('codeview');\n    };\n\n    /**\n     * toggle codeview\n     */\n    this.toggle = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n      context.triggerEvent('codeview.toggled');\n    };\n\n    /**\n     * activate code view\n     */\n    this.activate = function () {\n      $codable.val(dom.html($editable, options.prettifyHtml));\n      $codable.height($editable.height());\n\n      context.invoke('toolbar.updateCodeview', true);\n      $editor.addClass('codeview');\n      $codable.focus();\n\n      // activate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);\n\n        // CodeMirror TernServer\n        if (options.codemirror.tern) {\n          var server = new CodeMirror.TernServer(options.codemirror.tern);\n          cmEditor.ternServer = server;\n          cmEditor.on('cursorActivity', function (cm) {\n            server.updateArgHints(cm);\n          });\n        }\n\n        // CodeMirror hasn't Padding.\n        cmEditor.setSize(null, $editable.outerHeight());\n        $codable.data('cmEditor', cmEditor);\n      }\n    };\n\n    /**\n     * deactivate code view\n     */\n    this.deactivate = function () {\n      // deactivate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = $codable.data('cmEditor');\n        $codable.val(cmEditor.getValue());\n        cmEditor.toTextArea();\n      }\n\n      var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;\n      var isChange = $editable.html() !== value;\n\n      $editable.html(value);\n      $editable.height(options.height ? $codable.height() : 'auto');\n      $editor.removeClass('codeview');\n\n      if (isChange) {\n        context.triggerEvent('change', $editable.html(), $editable);\n      }\n\n      $editable.focus();\n\n      context.invoke('toolbar.updateCodeview', false);\n    };\n\n    this.destroy = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      }\n    };\n  };\n\n  var EDITABLE_PADDING = 24;\n\n  var Statusbar = function (context) {\n    var $document = $(document);\n    var $statusbar = context.layoutInfo.statusbar;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n\n    this.initialize = function () {\n      if (options.airMode || options.disableResizeEditor) {\n        return;\n      }\n\n      $statusbar.on('mousedown', function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        var editableTop = $editable.offset().top - $document.scrollTop();\n\n        $document.on('mousemove', function (event) {\n          var height = event.clientY - (editableTop + EDITABLE_PADDING);\n\n          height = (options.minheight > 0) ? Math.max(height, options.minheight) : height;\n          height = (options.maxHeight > 0) ? Math.min(height, options.maxHeight) : height;\n\n          $editable.height(height);\n        }).one('mouseup', function () {\n          $document.off('mousemove');\n        });\n      });\n    };\n\n    this.destroy = function () {\n      $statusbar.off();\n    };\n  };\n\n  var Fullscreen = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $toolbar = context.layoutInfo.toolbar;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n\n    var $window = $(window);\n    var $scrollbar = $('html, body');\n\n    /**\n     * toggle fullscreen\n     */\n    this.toggle = function () {\n      var resize = function (size) {\n        $editable.css('height', size.h);\n        $codable.css('height', size.h);\n        if ($codable.data('cmeditor')) {\n          $codable.data('cmeditor').setsize(null, size.h);\n        }\n      };\n\n      $editor.toggleClass('fullscreen');\n      if (this.isFullscreen()) {\n        $editable.data('orgHeight', $editable.css('height'));\n\n        $window.on('resize', function () {\n          resize({\n            h: $window.height() - $toolbar.outerHeight()\n          });\n        }).trigger('resize');\n\n        $scrollbar.css('overflow', 'hidden');\n      } else {\n        $window.off('resize');\n        resize({\n          h: $editable.data('orgHeight')\n        });\n        $scrollbar.css('overflow', 'visible');\n      }\n\n      context.invoke('toolbar.updateFullscreen', this.isFullscreen());\n    };\n\n    this.isFullscreen = function () {\n      return $editor.hasClass('fullscreen');\n    };\n  };\n\n  var Handle = function (context) {\n    var self = this;\n\n    var $document = $(document);\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.mousedown': function (we, e) {\n        if (self.update(e.target)) {\n          e.preventDefault();\n        }\n      },\n      'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {\n        self.update();\n      }\n    };\n\n    this.initialize = function () {\n      this.$handle = $([\n        '<div class=\"note-handle\">',\n        '<div class=\"note-control-selection\">',\n        '<div class=\"note-control-selection-bg\"></div>',\n        '<div class=\"note-control-holder note-control-nw\"></div>',\n        '<div class=\"note-control-holder note-control-ne\"></div>',\n        '<div class=\"note-control-holder note-control-sw\"></div>',\n        '<div class=\"',\n        (options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),\n        ' note-control-se\"></div>',\n        (options.disableResizeImage ? '' : '<div class=\"note-control-selection-info\"></div>'),\n        '</div>',\n        '</div>'\n      ].join('')).prependTo($editingArea);\n\n      this.$handle.on('mousedown', function (event) {\n        if (dom.isControlSizing(event.target)) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          var $target = self.$handle.find('.note-control-selection').data('target'),\n              posStart = $target.offset(),\n              scrollTop = $document.scrollTop();\n\n          $document.on('mousemove', function (event) {\n            context.invoke('editor.resizeTo', {\n              x: event.clientX - posStart.left,\n              y: event.clientY - (posStart.top - scrollTop)\n            }, $target, !event.shiftKey);\n\n            self.update($target[0]);\n          }).one('mouseup', function (e) {\n            e.preventDefault();\n            $document.off('mousemove');\n            context.invoke('editor.afterCommand');\n          });\n\n          if (!$target.data('ratio')) { // original ratio.\n            $target.data('ratio', $target.height() / $target.width());\n          }\n        }\n      });\n    };\n\n    this.destroy = function () {\n      this.$handle.remove();\n    };\n\n    this.update = function (target) {\n      var isImage = dom.isImg(target);\n      var $selection = this.$handle.find('.note-control-selection');\n\n      context.invoke('imagePopover.update', target);\n\n      if (isImage) {\n        var $image = $(target);\n        var pos = $image.position();\n\n        // include margin\n        var imageSize = {\n          w: $image.outerWidth(true),\n          h: $image.outerHeight(true)\n        };\n\n        $selection.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top,\n          width: imageSize.w,\n          height: imageSize.h\n        }).data('target', $image); // save current image element.\n\n        var sizingText = imageSize.w + 'x' + imageSize.h;\n        $selection.find('.note-control-selection-info').text(sizingText);\n        context.invoke('editor.saveTarget', target);\n      } else {\n        this.hide();\n      }\n\n      return isImage;\n    };\n\n    /**\n     * hide\n     *\n     * @param {jQuery} $handle\n     */\n    this.hide = function () {\n      context.invoke('editor.clearTarget');\n      this.$handle.children().hide();\n    };\n  };\n\n  var AutoLink = function (context) {\n    var self = this;\n    var defaultScheme = 'http://';\n    var linkPattern = /^(https?:\\/\\/|ssh:\\/\\/|ftp:\\/\\/|file:\\/|mailto:[A-Z0-9._%+-]+@)?(www\\.)?(.+)$/i;\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      }\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n    };\n\n    this.destroy = function () {\n      this.lastWordRange = null;\n    };\n\n    this.replace = function () {\n      if (!this.lastWordRange) {\n        return;\n      }\n\n      var keyword = this.lastWordRange.toString();\n      var match = keyword.match(linkPattern);\n\n      if (match && (match[1] || match[2])) {\n        var link = match[1] ? keyword : defaultScheme + keyword;\n        var node = $('<a />').html(keyword).attr('href', link)[0];\n\n        this.lastWordRange.insertNode(node);\n        this.lastWordRange = null;\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.handleKeydown = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        this.lastWordRange = wordRange;\n      }\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        this.replace();\n      }\n    };\n  };\n\n  /**\n   * textarea auto sync.\n   */\n  var AutoSync = function (context) {\n    var $note = context.layoutInfo.note;\n\n    this.events = {\n      'summernote.change': function () {\n        $note.val(context.invoke('code'));\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return dom.isTextarea($note[0]);\n    };\n  };\n\n  var Placeholder = function (context) {\n    var self = this;\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.init summernote.change': function () {\n        self.update();\n      },\n      'summernote.codeview.toggled': function () {\n        self.update();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !!options.placeholder;\n    };\n\n    this.initialize = function () {\n      this.$placeholder = $('<div class=\"note-placeholder\">');\n      this.$placeholder.on('click', function () {\n        context.invoke('focus');\n      }).text(options.placeholder).prependTo($editingArea);\n    };\n\n    this.destroy = function () {\n      this.$placeholder.remove();\n    };\n\n    this.update = function () {\n      var isShow = !context.invoke('codeview.isActivated') && context.invoke('editor.isEmpty');\n      this.$placeholder.toggle(isShow);\n    };\n  };\n\n  var Buttons = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var invertedKeyMap = func.invertObject(options.keyMap[agent.isMac ? 'mac' : 'pc']);\n\n    var representShortcut = this.representShortcut = function (editorMethod) {\n      var shortcut = invertedKeyMap[editorMethod];\n      if (agent.isMac) {\n        shortcut = shortcut.replace('CMD', '').replace('SHIFT', '');\n      }\n\n      shortcut = shortcut.replace('BACKSLASH', '\\\\')\n                         .replace('SLASH', '/')\n                         .replace('LEFTBRACKET', '[')\n                         .replace('RIGHTBRACKET', ']');\n\n      return ' (' + shortcut + ')';\n    };\n\n    this.initialize = function () {\n      this.addToolbarButtons();\n      this.addImagePopoverButtons();\n      this.addLinkPopoverButtons();\n      this.fontInstalledMap = {};\n    };\n\n    this.destroy = function () {\n      delete this.fontInstalledMap;\n    };\n\n    this.isFontInstalled = function (name) {\n      if (!self.fontInstalledMap.hasOwnProperty(name)) {\n        self.fontInstalledMap[name] = agent.isFontInstalled(name) ||\n          list.contains(options.fontNamesIgnoreCheck, name);\n      }\n\n      return self.fontInstalledMap[name];\n    };\n\n    this.addToolbarButtons = function () {\n      context.memo('button.style', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.magic) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.style.style,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'dropdown-style',\n            items: context.options.styleTags,\n            template: function (item) {\n\n              if (typeof item === 'string') {\n                item = { tag: item, title: item };\n              }\n\n              var tag = item.tag;\n              var title = item.title;\n              var style = item.style ? ' style=\"' + item.style + '\" ' : '';\n              var className = item.className ? ' className=\"' + item.className + '\"' : '';\n\n              return '<' + tag + style + className + '>' + title + '</' + tag +  '>';\n            },\n            click: context.createInvokeHandler('editor.formatBlock')\n          })\n        ]).render();\n      });\n\n      context.memo('button.bold', function () {\n        return ui.button({\n          className: 'note-btn-bold',\n          contents: ui.icon(options.icons.bold),\n          tooltip: lang.font.bold + representShortcut('bold'),\n          click: context.createInvokeHandler('editor.bold')\n        }).render();\n      });\n\n      context.memo('button.italic', function () {\n        return ui.button({\n          className: 'note-btn-italic',\n          contents: ui.icon(options.icons.italic),\n          tooltip: lang.font.italic + representShortcut('italic'),\n          click: context.createInvokeHandler('editor.italic')\n        }).render();\n      });\n\n      context.memo('button.underline', function () {\n        return ui.button({\n          className: 'note-btn-underline',\n          contents: ui.icon(options.icons.underline),\n          tooltip: lang.font.underline + representShortcut('underline'),\n          click: context.createInvokeHandler('editor.underline')\n        }).render();\n      });\n\n      context.memo('button.clear', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.eraser),\n          tooltip: lang.font.clear + representShortcut('removeFormat'),\n          click: context.createInvokeHandler('editor.removeFormat')\n        }).render();\n      });\n\n      context.memo('button.strikethrough', function () {\n        return ui.button({\n          className: 'note-btn-strikethrough',\n          contents: ui.icon(options.icons.strikethrough),\n          tooltip: lang.font.strikethrough + representShortcut('strikethrough'),\n          click: context.createInvokeHandler('editor.strikethrough')\n        }).render();\n      });\n\n      context.memo('button.superscript', function () {\n        return ui.button({\n          className: 'note-btn-superscript',\n          contents: ui.icon(options.icons.superscript),\n          tooltip: lang.font.superscript,\n          click: context.createInvokeHandler('editor.superscript')\n        }).render();\n      });\n\n      context.memo('button.subscript', function () {\n        return ui.button({\n          className: 'note-btn-subscript',\n          contents: ui.icon(options.icons.subscript),\n          tooltip: lang.font.subscript,\n          click: context.createInvokeHandler('editor.subscript')\n        }).render();\n      });\n\n      context.memo('button.fontname', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: '<span class=\"note-current-fontname\"/> ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.name,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontname',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontNames.filter(self.isFontInstalled),\n            template: function (item) {\n              return '<span style=\"font-family:' + item + '\">' + item + '</span>';\n            },\n            click: context.createInvokeHandler('editor.fontName')\n          })\n        ]).render();\n      });\n\n      context.memo('button.fontsize', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: '<span class=\"note-current-fontsize\"/>' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.size,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontsize',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontSizes,\n            click: context.createInvokeHandler('editor.fontSize')\n          })\n        ]).render();\n      });\n\n      context.memo('button.color', function () {\n        return ui.buttonGroup({\n          className: 'note-color',\n          children: [\n            ui.button({\n              className: 'note-current-color-button',\n              contents: ui.icon(options.icons.font + ' note-recent-color'),\n              tooltip: lang.color.recent,\n              click: function (e) {\n                var $button = $(e.currentTarget);\n                context.invoke('editor.color', {\n                  backColor: $button.attr('data-backColor'),\n                  foreColor: $button.attr('data-foreColor')\n                });\n              },\n              callback: function ($button) {\n                var $recentColor = $button.find('.note-recent-color');\n                $recentColor.css('background-color', '#FFFF00');\n                $button.attr('data-backColor', '#FFFF00');\n              }\n            }),\n            ui.button({\n              className: 'dropdown-toggle',\n              contents: ui.icon(options.icons.caret, 'span'),\n              tooltip: lang.color.more,\n              data: {\n                toggle: 'dropdown'\n              }\n            }),\n            ui.dropdown({\n              items: [\n                '<li>',\n                '<div class=\"btn-group\">',\n                '  <div class=\"note-palette-title\">' + lang.color.background + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"backColor\" data-value=\"inherit\">',\n                lang.color.transparent,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"backColor\"/>',\n                '</div>',\n                '<div class=\"btn-group\">',\n                '  <div class=\"note-palette-title\">' + lang.color.foreground + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"removeFormat\" data-value=\"foreColor\">',\n                lang.color.resetToDefault,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"foreColor\"/>',\n                '</div>',\n                '</li>'\n              ].join(''),\n              callback: function ($dropdown) {\n                $dropdown.find('.note-holder').each(function () {\n                  var $holder = $(this);\n                  $holder.append(ui.palette({\n                    colors: options.colors,\n                    eventName: $holder.data('event')\n                  }).render());\n                });\n              },\n              click: function (event) {\n                var $button = $(event.target);\n                var eventName = $button.data('event');\n                var value = $button.data('value');\n\n                if (eventName && value) {\n                  var key = eventName === 'backColor' ? 'background-color' : 'color';\n                  var $color = $button.closest('.note-color').find('.note-recent-color');\n                  var $currentButton = $button.closest('.note-color').find('.note-current-color-button');\n\n                  $color.css(key, value);\n                  $currentButton.attr('data-' + eventName, value);\n                  context.invoke('editor.' + eventName, value);\n                }\n              }\n            })\n          ]\n        }).render();\n      });\n\n      context.memo('button.ul',  function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unorderedlist),\n          tooltip: lang.lists.unordered + representShortcut('insertUnorderedList'),\n          click: context.createInvokeHandler('editor.insertUnorderedList')\n        }).render();\n      });\n\n      context.memo('button.ol', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.orderedlist),\n          tooltip: lang.lists.ordered + representShortcut('insertOrderedList'),\n          click:  context.createInvokeHandler('editor.insertOrderedList')\n        }).render();\n      });\n\n      var justifyLeft = ui.button({\n        contents: ui.icon(options.icons.alignLeft),\n        tooltip: lang.paragraph.left + representShortcut('justifyLeft'),\n        click: context.createInvokeHandler('editor.justifyLeft')\n      });\n\n      var justifyCenter = ui.button({\n        contents: ui.icon(options.icons.alignCenter),\n        tooltip: lang.paragraph.center + representShortcut('justifyCenter'),\n        click: context.createInvokeHandler('editor.justifyCenter')\n      });\n\n      var justifyRight = ui.button({\n        contents: ui.icon(options.icons.alignRight),\n        tooltip: lang.paragraph.right + representShortcut('justifyRight'),\n        click: context.createInvokeHandler('editor.justifyRight')\n      });\n\n      var justifyFull = ui.button({\n        contents: ui.icon(options.icons.alignJustify),\n        tooltip: lang.paragraph.justify + representShortcut('justifyFull'),\n        click: context.createInvokeHandler('editor.justifyFull')\n      });\n\n      var outdent = ui.button({\n        contents: ui.icon(options.icons.outdent),\n        tooltip: lang.paragraph.outdent + representShortcut('outdent'),\n        click: context.createInvokeHandler('editor.outdent')\n      });\n\n      var indent = ui.button({\n        contents: ui.icon(options.icons.indent),\n        tooltip: lang.paragraph.indent + representShortcut('indent'),\n        click: context.createInvokeHandler('editor.indent')\n      });\n\n      context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));\n      context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));\n      context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));\n      context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));\n      context.memo('button.outdent', func.invoke(outdent, 'render'));\n      context.memo('button.indent', func.invoke(indent, 'render'));\n\n      context.memo('button.paragraph', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.alignLeft) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.paragraph.paragraph,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown([\n            ui.buttonGroup({\n              className: 'note-align',\n              children: [justifyLeft, justifyCenter, justifyRight, justifyFull]\n            }),\n            ui.buttonGroup({\n              className: 'note-list',\n              children: [outdent, indent]\n            })\n          ])\n        ]).render();\n      });\n\n      context.memo('button.height', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.textHeight) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.height,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            items: options.lineHeights,\n            checkClassName: options.icons.menuCheck,\n            className: 'dropdown-line-height',\n            click: context.createInvokeHandler('editor.lineHeight')\n          })\n        ]).render();\n      });\n\n      context.memo('button.table', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.table) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.table.table,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'note-table',\n            items: [\n              '<div class=\"note-dimension-picker\">',\n              '  <div class=\"note-dimension-picker-mousecatcher\" data-event=\"insertTable\" data-value=\"1x1\"/>',\n              '  <div class=\"note-dimension-picker-highlighted\"/>',\n              '  <div class=\"note-dimension-picker-unhighlighted\"/>',\n              '</div>',\n              '<div class=\"note-dimension-display\">1 x 1</div>'\n            ].join('')\n          })\n        ], {\n          callback: function ($node) {\n            var $catcher = $node.find('.note-dimension-picker-mousecatcher');\n            $catcher.css({\n              width: options.insertTableMaxSize.col + 'em',\n              height: options.insertTableMaxSize.row + 'em'\n            }).mousedown(context.createInvokeHandler('editor.insertTable'))\n              .on('mousemove', self.tableMoveHandler);\n          }\n        }).render();\n      });\n\n      context.memo('button.link', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.link,\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.picture', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.picture),\n          tooltip: lang.image.image,\n          click: context.createInvokeHandler('imageDialog.show')\n        }).render();\n      });\n\n      context.memo('button.video', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.video),\n          tooltip: lang.video.video,\n          click: context.createInvokeHandler('videoDialog.show')\n        }).render();\n      });\n\n      context.memo('button.hr', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.minus),\n          tooltip: lang.hr.insert + representShortcut('insertHorizontalRule'),\n          click: context.createInvokeHandler('editor.insertHorizontalRule')\n        }).render();\n      });\n\n      context.memo('button.fullscreen', function () {\n        return ui.button({\n          className: 'btn-fullscreen',\n          contents: ui.icon(options.icons.arrowsAlt),\n          tooltip: lang.options.fullscreen,\n          click: context.createInvokeHandler('fullscreen.toggle')\n        }).render();\n      });\n\n      context.memo('button.codeview', function () {\n        return ui.button({\n          className: 'btn-codeview',\n          contents: ui.icon(options.icons.code),\n          tooltip: lang.options.codeview,\n          click: context.createInvokeHandler('codeview.toggle')\n        }).render();\n      });\n\n      context.memo('button.redo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.redo),\n          tooltip: lang.history.redo + representShortcut('redo'),\n          click: context.createInvokeHandler('editor.redo')\n        }).render();\n      });\n\n      context.memo('button.undo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.undo),\n          tooltip: lang.history.undo + representShortcut('undo'),\n          click: context.createInvokeHandler('editor.undo')\n        }).render();\n      });\n\n      context.memo('button.help', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.question),\n          tooltip: lang.options.help,\n          click: context.createInvokeHandler('helpDialog.show')\n        }).render();\n      });\n    };\n\n    /**\n     * image : [\n     *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n     *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],\n     *   ['remove', ['removeMedia']]\n     * ],\n     */\n    this.addImagePopoverButtons = function () {\n      // Image Size Buttons\n      context.memo('button.imageSize100', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">100%</span>',\n          tooltip: lang.image.resizeFull,\n          click: context.createInvokeHandler('editor.resize', '1')\n        }).render();\n      });\n      context.memo('button.imageSize50', function () {\n        return  ui.button({\n          contents: '<span class=\"note-fontsize-10\">50%</span>',\n          tooltip: lang.image.resizeHalf,\n          click: context.createInvokeHandler('editor.resize', '0.5')\n        }).render();\n      });\n      context.memo('button.imageSize25', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">25%</span>',\n          tooltip: lang.image.resizeQuarter,\n          click: context.createInvokeHandler('editor.resize', '0.25')\n        }).render();\n      });\n\n      // Float Buttons\n      context.memo('button.floatLeft', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignLeft),\n          tooltip: lang.image.floatLeft,\n          click: context.createInvokeHandler('editor.floatMe', 'left')\n        }).render();\n      });\n\n      context.memo('button.floatRight', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignRight),\n          tooltip: lang.image.floatRight,\n          click: context.createInvokeHandler('editor.floatMe', 'right')\n        }).render();\n      });\n\n      context.memo('button.floatNone', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignJustify),\n          tooltip: lang.image.floatNone,\n          click: context.createInvokeHandler('editor.floatMe', 'none')\n        }).render();\n      });\n\n      // Remove Buttons\n      context.memo('button.removeMedia', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.trash),\n          tooltip: lang.image.remove,\n          click: context.createInvokeHandler('editor.removeMedia')\n        }).render();\n      });\n    };\n\n    this.addLinkPopoverButtons = function () {\n      context.memo('button.linkDialogShow', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.edit,\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.unlink', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unlink),\n          tooltip: lang.link.unlink,\n          click: context.createInvokeHandler('editor.unlink')\n        }).render();\n      });\n    };\n\n    this.build = function ($container, groups) {\n      for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {\n        var group = groups[groupIdx];\n        var groupName = group[0];\n        var buttons = group[1];\n\n        var $group = ui.buttonGroup({\n          className: 'note-' + groupName\n        }).render();\n\n        for (var idx = 0, len = buttons.length; idx < len; idx++) {\n          var button = context.memo('button.' + buttons[idx]);\n          if (button) {\n            $group.append(typeof button === 'function' ? button(context) : button);\n          }\n        }\n        $group.appendTo($container);\n      }\n    };\n\n    this.updateCurrentStyle = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      this.updateBtnStates({\n        '.note-btn-bold': function () {\n          return styleInfo['font-bold'] === 'bold';\n        },\n        '.note-btn-italic': function () {\n          return styleInfo['font-italic'] === 'italic';\n        },\n        '.note-btn-underline': function () {\n          return styleInfo['font-underline'] === 'underline';\n        },\n        '.note-btn-subscript': function () {\n          return styleInfo['font-subscript'] === 'subscript';\n        },\n        '.note-btn-superscript': function () {\n          return styleInfo['font-superscript'] === 'superscript';\n        },\n        '.note-btn-strikethrough': function () {\n          return styleInfo['font-strikethrough'] === 'strikethrough';\n        }\n      });\n\n      if (styleInfo['font-family']) {\n        var fontNames = styleInfo['font-family'].split(',').map(function (name) {\n          return name.replace(/[\\'\\\"]/g, '')\n            .replace(/\\s+$/, '')\n            .replace(/^\\s+/, '');\n        });\n        var fontName = list.find(fontNames, self.isFontInstalled);\n\n        $toolbar.find('.dropdown-fontname li a').each(function () {\n          // always compare string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (fontName + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n        $toolbar.find('.note-current-fontname').text(fontName);\n      }\n\n      if (styleInfo['font-size']) {\n        var fontSize = styleInfo['font-size'];\n        $toolbar.find('.dropdown-fontsize li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (fontSize + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n        $toolbar.find('.note-current-fontsize').text(fontSize);\n      }\n\n      if (styleInfo['line-height']) {\n        var lineHeight = styleInfo['line-height'];\n        $toolbar.find('.dropdown-line-height li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (lineHeight + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n      }\n    };\n\n    this.updateBtnStates = function (infos) {\n      $.each(infos, function (selector, pred) {\n        ui.toggleBtnActive($toolbar.find(selector), pred());\n      });\n    };\n\n    this.tableMoveHandler = function (event) {\n      var PX_PER_EM = 18;\n      var $picker = $(event.target.parentNode); // target is mousecatcher\n      var $dimensionDisplay = $picker.next();\n      var $catcher = $picker.find('.note-dimension-picker-mousecatcher');\n      var $highlighted = $picker.find('.note-dimension-picker-highlighted');\n      var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');\n\n      var posOffset;\n      // HTML5 with jQuery - e.offsetX is undefined in Firefox\n      if (event.offsetX === undefined) {\n        var posCatcher = $(event.target).offset();\n        posOffset = {\n          x: event.pageX - posCatcher.left,\n          y: event.pageY - posCatcher.top\n        };\n      } else {\n        posOffset = {\n          x: event.offsetX,\n          y: event.offsetY\n        };\n      }\n\n      var dim = {\n        c: Math.ceil(posOffset.x / PX_PER_EM) || 1,\n        r: Math.ceil(posOffset.y / PX_PER_EM) || 1\n      };\n\n      $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });\n      $catcher.data('value', dim.c + 'x' + dim.r);\n\n      if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {\n        $unhighlighted.css({ width: dim.c + 1 + 'em'});\n      }\n\n      if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {\n        $unhighlighted.css({ height: dim.r + 1 + 'em'});\n      }\n\n      $dimensionDisplay.html(dim.c + ' x ' + dim.r);\n    };\n  };\n\n  var Toolbar = function (context) {\n    var ui = $.summernote.ui;\n\n    var $note = context.layoutInfo.note;\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !options.airMode;\n    };\n\n    this.initialize = function () {\n      options.toolbar = options.toolbar || [];\n\n      if (!options.toolbar.length) {\n        $toolbar.hide();\n      } else {\n        context.invoke('buttons.build', $toolbar, options.toolbar);\n      }\n\n      if (options.toolbarContainer) {\n        $toolbar.appendTo(options.toolbarContainer);\n      }\n\n      $note.on('summernote.keyup summernote.mouseup summernote.change', function () {\n        context.invoke('buttons.updateCurrentStyle');\n      });\n\n      context.invoke('buttons.updateCurrentStyle');\n    };\n\n    this.destroy = function () {\n      $toolbar.children().remove();\n    };\n\n    this.updateFullscreen = function (isFullscreen) {\n      ui.toggleBtnActive($toolbar.find('.btn-fullscreen'), isFullscreen);\n    };\n\n    this.updateCodeview = function (isCodeview) {\n      ui.toggleBtnActive($toolbar.find('.btn-codeview'), isCodeview);\n      if (isCodeview) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n    };\n\n    this.activate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, true);\n    };\n\n    this.deactivate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, false);\n    };\n  };\n\n  var LinkDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group\">' +\n                   '<label>' + lang.link.textToDisplay + '</label>' +\n                   '<input class=\"note-link-text form-control\" type=\"text\" />' +\n                 '</div>' +\n                 '<div class=\"form-group\">' +\n                   '<label>' + lang.link.url + '</label>' +\n                   '<input class=\"note-link-url form-control\" type=\"text\" value=\"http://\" />' +\n                 '</div>' +\n                 (!options.disableLinkTarget ?\n                   '<div class=\"checkbox\">' +\n                     '<label>' + '<input type=\"checkbox\" checked> ' + lang.link.openInNewWindow + '</label>' +\n                   '</div>' : ''\n                 );\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-link-btn disabled\" disabled>' + lang.link.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        className: 'link-dialog',\n        title: lang.link.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    /**\n     * Show link dialog and set event handlers on dialog controls.\n     *\n     * @param {Object} linkInfo\n     * @return {Promise}\n     */\n    this.showLinkDialog = function (linkInfo) {\n      return $.Deferred(function (deferred) {\n        var $linkText = self.$dialog.find('.note-link-text'),\n        $linkUrl = self.$dialog.find('.note-link-url'),\n        $linkBtn = self.$dialog.find('.note-link-btn'),\n        $openInNewWindow = self.$dialog.find('input[type=checkbox]');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          $linkText.val(linkInfo.text);\n\n          $linkText.on('input', function () {\n            ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n            // if linktext was modified by keyup,\n            // stop cloning text from linkUrl\n            linkInfo.text = $linkText.val();\n          });\n\n          // if no url was given, copy text to url\n          if (!linkInfo.url) {\n            linkInfo.url = linkInfo.text || 'http://';\n            ui.toggleBtn($linkBtn, linkInfo.text);\n          }\n\n          $linkUrl.on('input', function () {\n            ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n            // display same link on `Text to display` input\n            // when create a new link\n            if (!linkInfo.text) {\n              $linkText.val($linkUrl.val());\n            }\n          }).val(linkInfo.url).trigger('focus');\n\n          self.bindEnterKey($linkUrl, $linkBtn);\n          self.bindEnterKey($linkText, $linkBtn);\n\n          $openInNewWindow.prop('checked', linkInfo.isNewWindow);\n\n          $linkBtn.one('click', function (event) {\n            event.preventDefault();\n\n            deferred.resolve({\n              range: linkInfo.range,\n              url: $linkUrl.val(),\n              text: $linkText.val(),\n              isNewWindow: $openInNewWindow.is(':checked')\n            });\n            self.$dialog.modal('hide');\n          });\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          // detach events\n          $linkText.off('input keypress');\n          $linkUrl.off('input keypress');\n          $linkBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    /**\n     * @param {Object} layoutInfo\n     */\n    this.show = function () {\n      var linkInfo = context.invoke('editor.getLinkInfo');\n\n      context.invoke('editor.saveRange');\n      this.showLinkDialog(linkInfo).then(function (linkInfo) {\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.createLink', linkInfo);\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n    context.memo('help.linkDialog.show', options.langInfo.help['linkDialog.show']);\n  };\n\n  var LinkPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.link);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-link-popover',\n        callback: function ($node) {\n          var $content = $node.find('.popover-content');\n          $content.prepend('<span><a target=\"_blank\"></a>&nbsp;</span>');\n        }\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.link);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      // Prevent focusing on editable when invoke('code') is executed\n      if (!context.invoke('editor.hasFocus')) {\n        this.hide();\n        return;\n      }\n\n      var rng = context.invoke('editor.createRange');\n      if (rng.isCollapsed() && rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        var href = $(anchor).attr('href');\n        this.$popover.find('a').attr('href', href).html(href);\n\n        var pos = dom.posFromPlaceholder(anchor);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var ImageDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var imageLimitation = '';\n      if (options.maximumImageFileSize) {\n        var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));\n        var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +\n                           ' ' + ' KMGTP'[unit] + 'B';\n        imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';\n      }\n\n      var body = '<div class=\"form-group note-group-select-from-files\">' +\n                   '<label>' + lang.image.selectFromFiles + '</label>' +\n                   '<input class=\"note-image-input form-control\" type=\"file\" name=\"files\" accept=\"image/*\" multiple=\"multiple\" />' +\n                   imageLimitation +\n                 '</div>' +\n                 '<div class=\"form-group\" style=\"overflow:auto;\">' +\n                   '<label>' + lang.image.url + '</label>' +\n                   '<input class=\"note-image-url form-control col-md-12\" type=\"text\" />' +\n                 '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-image-btn disabled\" disabled>' + lang.image.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.image.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showImageDialog().then(function (data) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        if (typeof data === 'string') { // image url\n          context.invoke('editor.insertImage', data);\n        } else { // array of files\n          context.invoke('editor.insertImagesOrCallback', data);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showImageDialog = function () {\n      return $.Deferred(function (deferred) {\n        var $imageInput = self.$dialog.find('.note-image-input'),\n            $imageUrl = self.$dialog.find('.note-image-url'),\n            $imageBtn = self.$dialog.find('.note-image-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          // Cloning imageInput to clear element.\n          $imageInput.replaceWith($imageInput.clone()\n            .on('change', function () {\n              deferred.resolve(this.files || this.value);\n            })\n            .val('')\n          );\n\n          $imageBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($imageUrl.val());\n          });\n\n          $imageUrl.on('keyup paste', function () {\n            var url = $imageUrl.val();\n            ui.toggleBtn($imageBtn, url);\n          }).val('').trigger('focus');\n          self.bindEnterKey($imageUrl, $imageBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $imageInput.off('change');\n          $imageUrl.off('keyup paste keypress');\n          $imageBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var ImagePopover = function (context) {\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.image);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-image-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.image);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function (target) {\n      if (dom.isImg(target)) {\n        var pos = dom.posFromPlaceholder(target);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var VideoDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group row-fluid\">' +\n          '<label>' + lang.video.url + ' <small class=\"text-muted\">' + lang.video.providers + '</small></label>' +\n          '<input class=\"note-video-url form-control span12\" type=\"text\" />' +\n          '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-video-btn disabled\" disabled>' + lang.video.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.video.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.createVideoNode = function (url) {\n      // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)\n      var ytRegExp = /^(?:https?:\\/\\/)?(?:www\\.)?(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))((\\w|-){11})(?:\\S+)?$/;\n      var ytMatch = url.match(ytRegExp);\n\n      var igRegExp = /\\/\\/instagram.com\\/p\\/(.[a-zA-Z0-9_-]*)/;\n      var igMatch = url.match(igRegExp);\n\n      var vRegExp = /\\/\\/vine.co\\/v\\/(.[a-zA-Z0-9]*)/;\n      var vMatch = url.match(vRegExp);\n\n      var vimRegExp = /\\/\\/(player.)?vimeo.com\\/([a-z]*\\/)*([0-9]{6,11})[?]?.*/;\n      var vimMatch = url.match(vimRegExp);\n\n      var dmRegExp = /.+dailymotion.com\\/(video|hub)\\/([^_]+)[^#]*(#video=([^_&]+))?/;\n      var dmMatch = url.match(dmRegExp);\n\n      var youkuRegExp = /\\/\\/v\\.youku\\.com\\/v_show\\/id_(\\w+)=*\\.html/;\n      var youkuMatch = url.match(youkuRegExp);\n\n      var mp4RegExp = /^.+.(mp4|m4v)$/;\n      var mp4Match = url.match(mp4RegExp);\n\n      var oggRegExp = /^.+.(ogg|ogv)$/;\n      var oggMatch = url.match(oggRegExp);\n\n      var webmRegExp = /^.+.(webm)$/;\n      var webmMatch = url.match(webmRegExp);\n\n      var $video;\n      if (ytMatch && ytMatch[1].length === 11) {\n        var youtubeId = ytMatch[1];\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.youtube.com/embed/' + youtubeId)\n            .attr('width', '640').attr('height', '360');\n      } else if (igMatch && igMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', igMatch[0] + '/embed/')\n            .attr('width', '612').attr('height', '710')\n            .attr('scrolling', 'no')\n            .attr('allowtransparency', 'true');\n      } else if (vMatch && vMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', vMatch[0] + '/embed/simple')\n            .attr('width', '600').attr('height', '600')\n            .attr('class', 'vine-embed');\n      } else if (vimMatch && vimMatch[3].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('src', '//player.vimeo.com/video/' + vimMatch[3])\n            .attr('width', '640').attr('height', '360');\n      } else if (dmMatch && dmMatch[2].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])\n            .attr('width', '640').attr('height', '360');\n      } else if (youkuMatch && youkuMatch[1].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('height', '498')\n            .attr('width', '510')\n            .attr('src', '//player.youku.com/embed/' + youkuMatch[1]);\n      } else if (mp4Match || oggMatch || webmMatch) {\n        $video = $('<video controls>')\n            .attr('src', url)\n            .attr('width', '640').attr('height', '360');\n      } else {\n        // this is not a known video link. Now what, Cat? Now what?\n        return false;\n      }\n\n      $video.addClass('note-video-clip');\n\n      return $video[0];\n    };\n\n    this.show = function () {\n      var text = context.invoke('editor.getSelectedText');\n      context.invoke('editor.saveRange');\n      this.showVideoDialog(text).then(function (url) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        // build node\n        var $node = self.createVideoNode(url);\n\n        if ($node) {\n          // insert video node\n          context.invoke('editor.insertNode', $node);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showVideoDialog = function (text) {\n      return $.Deferred(function (deferred) {\n        var $videoUrl = self.$dialog.find('.note-video-url'),\n            $videoBtn = self.$dialog.find('.note-video-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          $videoUrl.val(text).on('input', function () {\n            ui.toggleBtn($videoBtn, $videoUrl.val());\n          }).trigger('focus');\n\n          $videoBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($videoUrl.val());\n          });\n\n          self.bindEnterKey($videoUrl, $videoBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $videoUrl.off('input');\n          $videoBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var HelpDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.createShortCutList = function () {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      return Object.keys(keyMap).map(function (key) {\n        var command = keyMap[key];\n        var $row = $('<div><div class=\"help-list-item\"/></div>');\n        $row.append($('<label><kbd>' + key + '</kdb></label>').css({\n          'width': 180,\n          'margin-right': 10\n        })).append($('<span/>').html(context.memo('help.' + command) || command));\n        return $row.html();\n      }).join('');\n    };\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = [\n        '<p class=\"text-center\">',\n        '<a href=\"//summernote.org/\" target=\"_blank\">Summernote 0.8.1</a>  ',\n        '<a href=\"//github.com/summernote/summernote\" target=\"_blank\">Project</a>  ',\n        '<a href=\"//github.com/summernote/summernote/issues\" target=\"_blank\">Issues</a>',\n        '</p>'\n      ].join('');\n\n      this.$dialog = ui.dialog({\n        title: lang.options.help,\n        fade: options.dialogsFade,\n        body: this.createShortCutList(),\n        footer: body,\n        callback: function ($node) {\n          $node.find('.modal-body').css({\n            'max-height': 300,\n            'overflow': 'scroll'\n          });\n        }\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    /**\n     * show help dialog\n     *\n     * @return {Promise}\n     */\n    this.showHelpDialog = function () {\n      return $.Deferred(function (deferred) {\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n          deferred.resolve();\n        });\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showHelpDialog().then(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n  };\n\n  var AirPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    var AIR_MODE_POPOVER_X_OFFSET = 20;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.change summernote.dialog.shown': function () {\n        self.hide();\n      },\n      'summernote.focusout': function (we, e) {\n        // [workaround] Firefox doesn't support relatedTarget on focusout\n        //  - Ignore hide action on focus out in FF.\n        if (agent.isFF) {\n          return;\n        }\n\n        if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(self.$popover[0]))) {\n          self.hide();\n        }\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return options.airMode && !list.isEmpty(options.popover.air);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-air-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.air);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      if (styleInfo.range && !styleInfo.range.isCollapsed()) {\n        var rect = list.last(styleInfo.range.getClientRects());\n        if (rect) {\n          var bnd = func.rect2bnd(rect);\n          this.$popover.css({\n            display: 'block',\n            left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,\n            top: bnd.top + bnd.height\n          });\n        }\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var HintPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var POPOVER_DIST = 5;\n    var hint = context.options.hint || [];\n    var direction = context.options.hintDirection || 'bottom';\n    var hints = $.isArray(hint) ? hint : [hint];\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      },\n      'summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return hints.length > 0;\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n      this.$popover = ui.popover({\n        className: 'note-hint-popover',\n        hideArrow: true,\n        direction: ''\n      }).render().appendTo('body');\n\n      this.$popover.hide();\n\n      this.$content = this.$popover.find('.popover-content');\n\n      this.$content.on('click', '.note-hint-item', function () {\n        self.$content.find('.active').removeClass('active');\n        $(this).addClass('active');\n        self.replace();\n      });\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.selectItem = function ($item) {\n      this.$content.find('.active').removeClass('active');\n      $item.addClass('active');\n\n      this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);\n    };\n\n    this.moveDown = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $next = $current.next();\n\n      if ($next.length) {\n        this.selectItem($next);\n      } else {\n        var $nextGroup = $current.parent().next();\n\n        if (!$nextGroup.length) {\n          $nextGroup = this.$content.find('.note-hint-group').first();\n        }\n\n        this.selectItem($nextGroup.find('.note-hint-item').first());\n      }\n    };\n\n    this.moveUp = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $prev = $current.prev();\n\n      if ($prev.length) {\n        this.selectItem($prev);\n      } else {\n        var $prevGroup = $current.parent().prev();\n\n        if (!$prevGroup.length) {\n          $prevGroup = this.$content.find('.note-hint-group').last();\n        }\n\n        this.selectItem($prevGroup.find('.note-hint-item').last());\n      }\n    };\n\n    this.replace = function () {\n      var $item = this.$content.find('.note-hint-item.active');\n\n      if ($item.length) {\n        var node = this.nodeFromItem($item);\n        this.lastWordRange.insertNode(node);\n        range.createFromNode(node).collapse().select();\n\n        this.lastWordRange = null;\n        this.hide();\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.nodeFromItem = function ($item) {\n      var hint = hints[$item.data('index')];\n      var item = $item.data('item');\n      var node = hint.content ? hint.content(item) : item;\n      if (typeof node === 'string') {\n        node = dom.createText(node);\n      }\n      return node;\n    };\n\n    this.createItemTemplates = function (hintIdx, items) {\n      var hint = hints[hintIdx];\n      return items.map(function (item, idx) {\n        var $item = $('<div class=\"note-hint-item\"/>');\n        $item.append(hint.template ? hint.template(item) : item + '');\n        $item.data({\n          'index': hintIdx,\n          'item': item\n        });\n\n        if (hintIdx === 0 && idx === 0) {\n          $item.addClass('active');\n        }\n        return $item;\n      });\n    };\n\n    this.handleKeydown = function (e) {\n      if (!this.$popover.is(':visible')) {\n        return;\n      }\n\n      if (e.keyCode === key.code.ENTER) {\n        e.preventDefault();\n        this.replace();\n      } else if (e.keyCode === key.code.UP) {\n        e.preventDefault();\n        this.moveUp();\n      } else if (e.keyCode === key.code.DOWN) {\n        e.preventDefault();\n        this.moveDown();\n      }\n    };\n\n    this.searchKeyword = function (index, keyword, callback) {\n      var hint = hints[index];\n      if (hint && hint.match.test(keyword) && hint.search) {\n        var matches = hint.match.exec(keyword);\n        hint.search(matches[1], callback);\n      } else {\n        callback();\n      }\n    };\n\n    this.createGroup = function (idx, keyword) {\n      var $group = $('<div class=\"note-hint-group note-hint-group-' + idx + '\"/>');\n      this.searchKeyword(idx, keyword, function (items) {\n        items = items || [];\n        if (items.length) {\n          $group.html(self.createItemTemplates(idx, items));\n          self.show();\n        }\n      });\n\n      return $group;\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {\n        if (e.keyCode === key.code.ENTER) {\n          if (this.$popover.is(':visible')) {\n            return;\n          }\n        }\n      } else {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        var keyword = wordRange.toString();\n        if (hints.length && keyword) {\n          this.$content.empty();\n\n          var bnd = func.rect2bnd(list.last(wordRange.getClientRects()));\n          if (bnd) {\n\n            this.$popover.hide();\n\n            this.lastWordRange = wordRange;\n\n            hints.forEach(function (hint, idx) {\n              if (hint.match.test(keyword)) {\n                self.createGroup(idx, keyword).appendTo(self.$content);\n              }\n            });\n\n            // set position for popover after group is created\n            if (direction === 'top') {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST\n              });\n            } else {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top + bnd.height + POPOVER_DIST\n              });\n            }\n\n          }\n        } else {\n          this.hide();\n        }\n      }\n    };\n\n    this.show = function () {\n      this.$popover.show();\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n\n  $.summernote = $.extend($.summernote, {\n    version: '0.8.1',\n    ui: ui,\n\n    plugins: {},\n\n    options: {\n      modules: {\n        'editor': Editor,\n        'clipboard': Clipboard,\n        'dropzone': Dropzone,\n        'codeview': Codeview,\n        'statusbar': Statusbar,\n        'fullscreen': Fullscreen,\n        'handle': Handle,\n        // FIXME: HintPopover must be front of autolink\n        //  - Script error about range when Enter key is pressed on hint popover\n        'hintPopover': HintPopover,\n        'autoLink': AutoLink,\n        'autoSync': AutoSync,\n        'placeholder': Placeholder,\n        'buttons': Buttons,\n        'toolbar': Toolbar,\n        'linkDialog': LinkDialog,\n        'linkPopover': LinkPopover,\n        'imageDialog': ImageDialog,\n        'imagePopover': ImagePopover,\n        'videoDialog': VideoDialog,\n        'helpDialog': HelpDialog,\n        'airPopover': AirPopover\n      },\n\n      buttons: {},\n      \n      lang: 'en-US',\n\n      // toolbar\n      toolbar: [\n        ['style', ['style']],\n        ['font', ['bold', 'underline', 'clear']],\n        ['fontname', ['fontname']],\n        ['color', ['color']],\n        ['para', ['ul', 'ol', 'paragraph']],\n        ['table', ['table']],\n        ['insert', ['link', 'picture', 'video']],\n        ['view', ['fullscreen', 'codeview', 'help']]\n      ],\n\n      // popover\n      popover: {\n        image: [\n          ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n          ['float', ['floatLeft', 'floatRight', 'floatNone']],\n          ['remove', ['removeMedia']]\n        ],\n        link: [\n          ['link', ['linkDialogShow', 'unlink']]\n        ],\n        air: [\n          ['color', ['color']],\n          ['font', ['bold', 'underline', 'clear']],\n          ['para', ['ul', 'paragraph']],\n          ['table', ['table']],\n          ['insert', ['link', 'picture']]\n        ]\n      },\n\n      // air mode: inline editor\n      airMode: false,\n\n      width: null,\n      height: null,\n\n      focus: false,\n      tabSize: 4,\n      styleWithSpan: true,\n      shortcuts: true,\n      textareaAutoSync: true,\n      direction: null,\n\n      styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\n      fontNames: [\n        'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',\n        'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',\n        'Tahoma', 'Times New Roman', 'Verdana'\n      ],\n\n      fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],\n\n      // pallete colors(n x n)\n      colors: [\n        ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],\n        ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],\n        ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],\n        ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],\n        ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],\n        ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],\n        ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],\n        ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']\n      ],\n\n      lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],\n\n      tableClassName: 'table table-bordered',\n\n      insertTableMaxSize: {\n        col: 10,\n        row: 10\n      },\n\n      dialogsInBody: false,\n      dialogsFade: false,\n\n      maximumImageFileSize: null,\n\n      callbacks: {\n        onInit: null,\n        onFocus: null,\n        onBlur: null,\n        onEnter: null,\n        onKeyup: null,\n        onKeydown: null,\n        onSubmit: null,\n        onImageUpload: null,\n        onImageUploadError: null\n      },\n\n      codemirror: {\n        mode: 'text/html',\n        htmlMode: true,\n        lineNumbers: true\n      },\n\n      keyMap: {\n        pc: {\n          'ENTER': 'insertParagraph',\n          'CTRL+Z': 'undo',\n          'CTRL+Y': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CTRL+B': 'bold',\n          'CTRL+I': 'italic',\n          'CTRL+U': 'underline',\n          'CTRL+SHIFT+S': 'strikethrough',\n          'CTRL+BACKSLASH': 'removeFormat',\n          'CTRL+SHIFT+L': 'justifyLeft',\n          'CTRL+SHIFT+E': 'justifyCenter',\n          'CTRL+SHIFT+R': 'justifyRight',\n          'CTRL+SHIFT+J': 'justifyFull',\n          'CTRL+SHIFT+NUM7': 'insertUnorderedList',\n          'CTRL+SHIFT+NUM8': 'insertOrderedList',\n          'CTRL+LEFTBRACKET': 'outdent',\n          'CTRL+RIGHTBRACKET': 'indent',\n          'CTRL+NUM0': 'formatPara',\n          'CTRL+NUM1': 'formatH1',\n          'CTRL+NUM2': 'formatH2',\n          'CTRL+NUM3': 'formatH3',\n          'CTRL+NUM4': 'formatH4',\n          'CTRL+NUM5': 'formatH5',\n          'CTRL+NUM6': 'formatH6',\n          'CTRL+ENTER': 'insertHorizontalRule',\n          'CTRL+K': 'linkDialog.show'\n        },\n\n        mac: {\n          'ENTER': 'insertParagraph',\n          'CMD+Z': 'undo',\n          'CMD+SHIFT+Z': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CMD+B': 'bold',\n          'CMD+I': 'italic',\n          'CMD+U': 'underline',\n          'CMD+SHIFT+S': 'strikethrough',\n          'CMD+BACKSLASH': 'removeFormat',\n          'CMD+SHIFT+L': 'justifyLeft',\n          'CMD+SHIFT+E': 'justifyCenter',\n          'CMD+SHIFT+R': 'justifyRight',\n          'CMD+SHIFT+J': 'justifyFull',\n          'CMD+SHIFT+NUM7': 'insertUnorderedList',\n          'CMD+SHIFT+NUM8': 'insertOrderedList',\n          'CMD+LEFTBRACKET': 'outdent',\n          'CMD+RIGHTBRACKET': 'indent',\n          'CMD+NUM0': 'formatPara',\n          'CMD+NUM1': 'formatH1',\n          'CMD+NUM2': 'formatH2',\n          'CMD+NUM3': 'formatH3',\n          'CMD+NUM4': 'formatH4',\n          'CMD+NUM5': 'formatH5',\n          'CMD+NUM6': 'formatH6',\n          'CMD+ENTER': 'insertHorizontalRule',\n          'CMD+K': 'linkDialog.show'\n        }\n      },\n      icons: {\n        'align': 'note-icon-align',\n        'alignCenter': 'note-icon-align-center',\n        'alignJustify': 'note-icon-align-justify',\n        'alignLeft': 'note-icon-align-left',\n        'alignRight': 'note-icon-align-right',\n        'indent': 'note-icon-align-indent',\n        'outdent': 'note-icon-align-outdent',\n        'arrowsAlt': 'note-icon-arrows-alt',\n        'bold': 'note-icon-bold',\n        'caret': 'note-icon-caret',\n        'circle': 'note-icon-circle',\n        'close': 'note-icon-close',\n        'code': 'note-icon-code',\n        'eraser': 'note-icon-eraser',\n        'font': 'note-icon-font',\n        'frame': 'note-icon-frame',\n        'italic': 'note-icon-italic',\n        'link': 'note-icon-link',\n        'unlink': 'note-icon-chain-broken',\n        'magic': 'note-icon-magic',\n        'menuCheck': 'note-icon-check',\n        'minus': 'note-icon-minus',\n        'orderedlist': 'note-icon-orderedlist',\n        'pencil': 'note-icon-pencil',\n        'picture': 'note-icon-picture',\n        'question': 'note-icon-question',\n        'redo': 'note-icon-redo',\n        'square': 'note-icon-square',\n        'strikethrough': 'note-icon-strikethrough',\n        'subscript': 'note-icon-subscript',\n        'superscript': 'note-icon-superscript',\n        'table': 'note-icon-table',\n        'textHeight': 'note-icon-text-height',\n        'trash': 'note-icon-trash',\n        'underline': 'note-icon-underline',\n        'undo': 'note-icon-undo',\n        'unorderedlist': 'note-icon-unorderedlist',\n        'video': 'note-icon-video'\n      }\n    }\n  });\n\n}));\n\n\n/***/ }),\n\n/***/ 152:\n/***/ (function(module, exports) {\n\n/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 0.js","import $ from 'jquery';\nimport sn from 'summernote-webpack';\n\nclass SummerNote {\n    constructor() {\n        $('.summernote').summernote({\n            height: 400\n        });\n    }\n}\n\nexport default SummerNote;\n\n\n\n// WEBPACK FOOTER //\n// ./www/src/js/summernote.js","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n// Kludges for bugs and behavior differences that can't be feature\n// detected are enabled based on userAgent etc sniffing.\nvar userAgent = navigator.userAgent;\nvar platform = navigator.platform;\n\nvar gecko = /gecko\\/\\d/i.test(userAgent);\nvar ie_upto10 = /MSIE \\d/.test(userAgent);\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\nvar edge = /Edge\\/(\\d+)/.exec(userAgent);\nvar ie = ie_upto10 || ie_11up || edge;\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\nvar webkit = !edge && /WebKit\\//.test(userAgent);\nvar qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\nvar chrome = !edge && /Chrome\\//.test(userAgent);\nvar presto = /Opera\\//.test(userAgent);\nvar safari = /Apple Computer/.test(navigator.vendor);\nvar mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\nvar phantom = /PhantomJS/.test(userAgent);\n\nvar ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\nvar android = /Android/.test(userAgent);\n// This is woefully incomplete. Suggestions for alternative methods welcome.\nvar mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\nvar mac = ios || /Mac/.test(platform);\nvar chromeOS = /\\bCrOS\\b/.test(userAgent);\nvar windows = /win/i.test(platform);\n\nvar presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\nif (presto_version) { presto_version = Number(presto_version[1]); }\nif (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\nvar captureRightClick = gecko || (ie && ie_version >= 9);\n\nfunction classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\nvar rmClass = function(node, cls) {\n  var current = node.className;\n  var match = classTest(cls).exec(current);\n  if (match) {\n    var after = current.slice(match.index + match[0].length);\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n  }\n};\n\nfunction removeChildren(e) {\n  for (var count = e.childNodes.length; count > 0; --count)\n    { e.removeChild(e.firstChild); }\n  return e\n}\n\nfunction removeChildrenAndAdd(parent, e) {\n  return removeChildren(parent).appendChild(e)\n}\n\nfunction elt(tag, content, className, style) {\n  var e = document.createElement(tag);\n  if (className) { e.className = className; }\n  if (style) { e.style.cssText = style; }\n  if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n  return e\n}\n// wrapper for elt, which removes the elt from the accessibility tree\nfunction eltP(tag, content, className, style) {\n  var e = elt(tag, content, className, style);\n  e.setAttribute(\"role\", \"presentation\");\n  return e\n}\n\nvar range;\nif (document.createRange) { range = function(node, start, end, endNode) {\n  var r = document.createRange();\n  r.setEnd(endNode || node, end);\n  r.setStart(node, start);\n  return r\n}; }\nelse { range = function(node, start, end) {\n  var r = document.body.createTextRange();\n  try { r.moveToElementText(node.parentNode); }\n  catch(e) { return r }\n  r.collapse(true);\n  r.moveEnd(\"character\", end);\n  r.moveStart(\"character\", start);\n  return r\n}; }\n\nfunction contains(parent, child) {\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n    { child = child.parentNode; }\n  if (parent.contains)\n    { return parent.contains(child) }\n  do {\n    if (child.nodeType == 11) { child = child.host; }\n    if (child == parent) { return true }\n  } while (child = child.parentNode)\n}\n\nfunction activeElt() {\n  // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n  var activeElement;\n  try {\n    activeElement = document.activeElement;\n  } catch(e) {\n    activeElement = document.body || null;\n  }\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n    { activeElement = activeElement.shadowRoot.activeElement; }\n  return activeElement\n}\n\nfunction addClass(node, cls) {\n  var current = node.className;\n  if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n}\nfunction joinClasses(a, b) {\n  var as = a.split(\" \");\n  for (var i = 0; i < as.length; i++)\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n  return b\n}\n\nvar selectInput = function(node) { node.select(); };\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\nelse if (ie) // Suppress mysterious IE10 errors\n  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\nfunction bind(f) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function(){return f.apply(null, args)}\n}\n\nfunction copyObj(obj, target, overwrite) {\n  if (!target) { target = {}; }\n  for (var prop in obj)\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n      { target[prop] = obj[prop]; } }\n  return target\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) { end = string.length; }\n  }\n  for (var i = startIndex || 0, n = startValue || 0;;) {\n    var nextTab = string.indexOf(\"\\t\", i);\n    if (nextTab < 0 || nextTab >= end)\n      { return n + (end - i) }\n    n += nextTab - i;\n    n += tabSize - (n % tabSize);\n    i = nextTab + 1;\n  }\n}\n\nvar Delayed = function() {this.id = null;};\nDelayed.prototype.set = function (ms, f) {\n  clearTimeout(this.id);\n  this.id = setTimeout(f, ms);\n};\n\nfunction indexOf(array, elt) {\n  for (var i = 0; i < array.length; ++i)\n    { if (array[i] == elt) { return i } }\n  return -1\n}\n\n// Number of pixels added to scroller and sizer to hide scrollbar\nvar scrollerGap = 30;\n\n// Returned or thrown by various protocols to signal 'I'm not\n// handling this'.\nvar Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n// Reused option objects for setSelection & friends\nvar sel_dontScroll = {scroll: false};\nvar sel_mouse = {origin: \"*mouse\"};\nvar sel_move = {origin: \"+move\"};\n\n// The inverse of countColumn -- find the offset that corresponds to\n// a particular column.\nfunction findColumn(string, goal, tabSize) {\n  for (var pos = 0, col = 0;;) {\n    var nextTab = string.indexOf(\"\\t\", pos);\n    if (nextTab == -1) { nextTab = string.length; }\n    var skipped = nextTab - pos;\n    if (nextTab == string.length || col + skipped >= goal)\n      { return pos + Math.min(skipped, goal - col) }\n    col += nextTab - pos;\n    col += tabSize - (col % tabSize);\n    pos = nextTab + 1;\n    if (col >= goal) { return pos }\n  }\n}\n\nvar spaceStrs = [\"\"];\nfunction spaceStr(n) {\n  while (spaceStrs.length <= n)\n    { spaceStrs.push(lst(spaceStrs) + \" \"); }\n  return spaceStrs[n]\n}\n\nfunction lst(arr) { return arr[arr.length-1] }\n\nfunction map(array, f) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n  return out\n}\n\nfunction insertSorted(array, value, score) {\n  var pos = 0, priority = score(value);\n  while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n  array.splice(pos, 0, value);\n}\n\nfunction nothing() {}\n\nfunction createObj(base, props) {\n  var inst;\n  if (Object.create) {\n    inst = Object.create(base);\n  } else {\n    nothing.prototype = base;\n    inst = new nothing();\n  }\n  if (props) { copyObj(props, inst); }\n  return inst\n}\n\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nfunction isWordCharBasic(ch) {\n  return /\\w/.test(ch) || ch > \"\\x80\" &&\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n}\nfunction isWordChar(ch, helper) {\n  if (!helper) { return isWordCharBasic(ch) }\n  if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n  return helper.test(ch)\n}\n\nfunction isEmpty(obj) {\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n  return true\n}\n\n// Extending unicode characters. A series of a non-extending char +\n// any number of extending chars is treated as a single unit as far\n// as editing and measuring is concerned. This is not fully correct,\n// since some scripts/fonts/browsers also treat other configurations\n// of code points as a group.\nvar extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\nfunction skipExtendingChars(str, pos, dir) {\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n  return pos\n}\n\n// Returns the value from the range [`from`; `to`] that satisfies\n// `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`.\nfunction findFirst(pred, from, to) {\n  for (;;) {\n    if (Math.abs(from - to) <= 1) { return pred(from) ? from : to }\n    var mid = Math.floor((from + to) / 2);\n    if (pred(mid)) { to = mid; }\n    else { from = mid; }\n  }\n}\n\n// The display handles the DOM integration, both for input reading\n// and content drawing. It holds references to DOM nodes and\n// display-related state.\n\nfunction Display(place, doc, input) {\n  var d = this;\n  this.input = input;\n\n  // Covers bottom-right square when both scrollbars are present.\n  d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n  d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\n  // and h scrollbar is present.\n  d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n  d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n  // Will contain the actual code, positioned to cover the viewport.\n  d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n  // Elements are added to these to represent selection and cursors.\n  d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n  d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n  // A visibility: hidden element used to find the size of things.\n  d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n  // When lines outside of the viewport are measured, they are drawn in this.\n  d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\n  d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                    null, \"position: relative; outline: none\");\n  var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n  // Moved around its parent to cover visible view.\n  d.mover = elt(\"div\", [lines], null, \"position: relative\");\n  // Set to the height of the document, allowing scrolling.\n  d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n  d.sizerWidth = null;\n  // Behavior of elts with overflow: auto and padding is\n  // inconsistent across browsers. This is used to ensure the\n  // scrollable area is big enough.\n  d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n  // Will contain the gutters, if any.\n  d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n  d.lineGutter = null;\n  // Actual scrollable element.\n  d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n  d.scroller.setAttribute(\"tabIndex\", \"-1\");\n  // The element in which the editor lives.\n  d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n  if (place) {\n    if (place.appendChild) { place.appendChild(d.wrapper); }\n    else { place(d.wrapper); }\n  }\n\n  // Current rendered range (may be bigger than the view window).\n  d.viewFrom = d.viewTo = doc.first;\n  d.reportedViewFrom = d.reportedViewTo = doc.first;\n  // Information about the rendered lines.\n  d.view = [];\n  d.renderedView = null;\n  // Holds info about a single rendered line when it was rendered\n  // for measurement, while not in view.\n  d.externalMeasured = null;\n  // Empty space (in pixels) above the view\n  d.viewOffset = 0;\n  d.lastWrapHeight = d.lastWrapWidth = 0;\n  d.updateLineNumbers = null;\n\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n  d.scrollbarsClipped = false;\n\n  // Used to only resize the line number gutter when necessary (when\n  // the amount of lines crosses a boundary that makes its width change)\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n  // Set to true when a non-horizontal-scrolling line widget is\n  // added. As an optimization, line widget aligning is skipped when\n  // this is false.\n  d.alignWidgets = false;\n\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n  // Tracks the maximum line length so that the horizontal scrollbar\n  // can be kept static when scrolling.\n  d.maxLine = null;\n  d.maxLineLength = 0;\n  d.maxLineChanged = false;\n\n  // Used for measuring wheel scrolling granularity\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n  // True when shift is held down.\n  d.shift = false;\n\n  // Used to track whether anything happened since the context menu\n  // was opened.\n  d.selForContextMenu = null;\n\n  d.activeTouch = null;\n\n  input.init(d);\n}\n\n// Find the line object corresponding to the given line number.\nfunction getLine(doc, n) {\n  n -= doc.first;\n  if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n  var chunk = doc;\n  while (!chunk.lines) {\n    for (var i = 0;; ++i) {\n      var child = chunk.children[i], sz = child.chunkSize();\n      if (n < sz) { chunk = child; break }\n      n -= sz;\n    }\n  }\n  return chunk.lines[n]\n}\n\n// Get the part of a document between two positions, as an array of\n// strings.\nfunction getBetween(doc, start, end) {\n  var out = [], n = start.line;\n  doc.iter(start.line, end.line + 1, function (line) {\n    var text = line.text;\n    if (n == end.line) { text = text.slice(0, end.ch); }\n    if (n == start.line) { text = text.slice(start.ch); }\n    out.push(text);\n    ++n;\n  });\n  return out\n}\n// Get the lines between from and to, as array of strings.\nfunction getLines(doc, from, to) {\n  var out = [];\n  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n  return out\n}\n\n// Update the height of a line, propagating the height change\n// upwards to parent nodes.\nfunction updateLineHeight(line, height) {\n  var diff = height - line.height;\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n}\n\n// Given a line object, find its line number by walking up through\n// its parent links.\nfunction lineNo(line) {\n  if (line.parent == null) { return null }\n  var cur = line.parent, no = indexOf(cur.lines, line);\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n    for (var i = 0;; ++i) {\n      if (chunk.children[i] == cur) { break }\n      no += chunk.children[i].chunkSize();\n    }\n  }\n  return no + cur.first\n}\n\n// Find the line at the given vertical position, using the height\n// information in the document tree.\nfunction lineAtHeight(chunk, h) {\n  var n = chunk.first;\n  outer: do {\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n      var child = chunk.children[i$1], ch = child.height;\n      if (h < ch) { chunk = child; continue outer }\n      h -= ch;\n      n += child.chunkSize();\n    }\n    return n\n  } while (!chunk.lines)\n  var i = 0;\n  for (; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i], lh = line.height;\n    if (h < lh) { break }\n    h -= lh;\n  }\n  return n + i\n}\n\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\nfunction lineNumberFor(options, i) {\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\n}\n\n// A Pos instance represents a position within the text.\nfunction Pos(line, ch, sticky) {\n  if ( sticky === void 0 ) sticky = null;\n\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n  this.line = line;\n  this.ch = ch;\n  this.sticky = sticky;\n}\n\n// Compare two positions, return 0 if they are the same, a negative\n// number when a is less, and a positive number otherwise.\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\nfunction copyPos(x) {return Pos(x.line, x.ch)}\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n// Most of the external API clips given positions to make sure they\n// actually exist within the document.\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\nfunction clipPos(doc, pos) {\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\n  var last = doc.first + doc.size - 1;\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\n}\nfunction clipToLen(pos, linelen) {\n  var ch = pos.ch;\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n  else if (ch < 0) { return Pos(pos.line, 0) }\n  else { return pos }\n}\nfunction clipPosArray(doc, array) {\n  var out = [];\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n  return out\n}\n\n// Optimize some code when these features are not used.\nvar sawReadOnlySpans = false;\nvar sawCollapsedSpans = false;\n\nfunction seeReadOnlySpans() {\n  sawReadOnlySpans = true;\n}\n\nfunction seeCollapsedSpans() {\n  sawCollapsedSpans = true;\n}\n\n// TEXTMARKER SPANS\n\nfunction MarkedSpan(marker, from, to) {\n  this.marker = marker;\n  this.from = from; this.to = to;\n}\n\n// Search an array of spans for a span matching the given marker.\nfunction getMarkedSpanFor(spans, marker) {\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.marker == marker) { return span }\n  } }\n}\n// Remove a span from an array, returning undefined if no spans are\n// left (we don't store arrays for lines without spans).\nfunction removeMarkedSpan(spans, span) {\n  var r;\n  for (var i = 0; i < spans.length; ++i)\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n  return r\n}\n// Add a span to a line.\nfunction addMarkedSpan(line, span) {\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n  span.marker.attachLine(line);\n}\n\n// Used for the algorithm that adjusts markers for a change in the\n// document. These functions cut an array of spans at a given\n// character position, returning an array of remaining chunks (or\n// undefined if nothing remains).\nfunction markedSpansBefore(old, startCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n    if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n    }\n  } }\n  return nw\n}\nfunction markedSpansAfter(old, endCh, isInsert) {\n  var nw;\n  if (old) { for (var i = 0; i < old.length; ++i) {\n    var span = old[i], marker = span.marker;\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n    if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                            span.to == null ? null : span.to - endCh));\n    }\n  } }\n  return nw\n}\n\n// Given a change object, compute the new set of marker spans that\n// cover the line in which the change took place. Removes spans\n// entirely within the change, reconnects spans belonging to the\n// same marker that appear on both sides of the change, and cuts off\n// spans partially within the change. Returns an array of span\n// arrays with one element for each line in (after) the change.\nfunction stretchSpansOverChange(doc, change) {\n  if (change.full) { return null }\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n  if (!oldFirst && !oldLast) { return null }\n\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n  // Get the spans that 'stick out' on both sides\n  var first = markedSpansBefore(oldFirst, startCh, isInsert);\n  var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n  // Next, merge those two ends\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n  if (first) {\n    // Fix up .to properties of first\n    for (var i = 0; i < first.length; ++i) {\n      var span = first[i];\n      if (span.to == null) {\n        var found = getMarkedSpanFor(last, span.marker);\n        if (!found) { span.to = startCh; }\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n      }\n    }\n  }\n  if (last) {\n    // Fix up .from in last (or move them into first in case of sameLine)\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\n      var span$1 = last[i$1];\n      if (span$1.to != null) { span$1.to += offset; }\n      if (span$1.from == null) {\n        var found$1 = getMarkedSpanFor(first, span$1.marker);\n        if (!found$1) {\n          span$1.from = offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      } else {\n        span$1.from += offset;\n        if (sameLine) { (first || (first = [])).push(span$1); }\n      }\n    }\n  }\n  // Make sure we didn't create any zero-length spans\n  if (first) { first = clearEmptySpans(first); }\n  if (last && last != first) { last = clearEmptySpans(last); }\n\n  var newMarkers = [first];\n  if (!sameLine) {\n    // Fill gap with whole-line-spans\n    var gap = change.text.length - 2, gapMarkers;\n    if (gap > 0 && first)\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\n        { if (first[i$2].to == null)\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n    for (var i$3 = 0; i$3 < gap; ++i$3)\n      { newMarkers.push(gapMarkers); }\n    newMarkers.push(last);\n  }\n  return newMarkers\n}\n\n// Remove spans that are empty and don't have a clearWhenEmpty\n// option of false.\nfunction clearEmptySpans(spans) {\n  for (var i = 0; i < spans.length; ++i) {\n    var span = spans[i];\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n      { spans.splice(i--, 1); }\n  }\n  if (!spans.length) { return null }\n  return spans\n}\n\n// Used to 'clip' out readOnly ranges when making a change.\nfunction removeReadOnlyRanges(doc, from, to) {\n  var markers = null;\n  doc.iter(from.line, to.line + 1, function (line) {\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var mark = line.markedSpans[i].marker;\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n        { (markers || (markers = [])).push(mark); }\n    } }\n  });\n  if (!markers) { return null }\n  var parts = [{from: from, to: to}];\n  for (var i = 0; i < markers.length; ++i) {\n    var mk = markers[i], m = mk.find(0);\n    for (var j = 0; j < parts.length; ++j) {\n      var p = parts[j];\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n        { newParts.push({from: p.from, to: m.from}); }\n      if (dto > 0 || !mk.inclusiveRight && !dto)\n        { newParts.push({from: m.to, to: p.to}); }\n      parts.splice.apply(parts, newParts);\n      j += newParts.length - 3;\n    }\n  }\n  return parts\n}\n\n// Connect or disconnect spans from a line.\nfunction detachMarkedSpans(line) {\n  var spans = line.markedSpans;\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.detachLine(line); }\n  line.markedSpans = null;\n}\nfunction attachMarkedSpans(line, spans) {\n  if (!spans) { return }\n  for (var i = 0; i < spans.length; ++i)\n    { spans[i].marker.attachLine(line); }\n  line.markedSpans = spans;\n}\n\n// Helpers used when computing which overlapping collapsed span\n// counts as the larger one.\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n// Returns a number indicating which of two overlapping collapsed\n// spans is larger (and thus includes the other). Falls back to\n// comparing ids when the spans cover exactly the same range.\nfunction compareCollapsedMarkers(a, b) {\n  var lenDiff = a.lines.length - b.lines.length;\n  if (lenDiff != 0) { return lenDiff }\n  var aPos = a.find(), bPos = b.find();\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n  if (fromCmp) { return -fromCmp }\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n  if (toCmp) { return toCmp }\n  return b.id - a.id\n}\n\n// Find out whether a line ends or starts in a collapsed span. If\n// so, return the marker for that span.\nfunction collapsedSpanAtSide(line, start) {\n  var sps = sawCollapsedSpans && line.markedSpans, found;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n      { found = sp.marker; }\n  } }\n  return found\n}\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n// Test whether there exists a collapsed span that partially\n// overlaps (covers the start or end, but not both) of a new span.\n// Such overlap is not allowed.\nfunction conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n  var line = getLine(doc, lineNo$$1);\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\n    var sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    var found = sp.marker.find(0);\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n      { return true }\n  } }\n}\n\n// A visual line is a line as drawn on the screen. Folding, for\n// example, can cause multiple logical lines to appear on the same\n// visual line. This finds the start of the visual line that the\n// given line is part of (usually that is the line itself).\nfunction visualLine(line) {\n  var merged;\n  while (merged = collapsedSpanAtStart(line))\n    { line = merged.find(-1, true).line; }\n  return line\n}\n\nfunction visualLineEnd(line) {\n  var merged;\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return line\n}\n\n// Returns an array of logical lines that continue the visual line\n// started by the argument, or undefined if there are no such lines.\nfunction visualLineContinued(line) {\n  var merged, lines;\n  while (merged = collapsedSpanAtEnd(line)) {\n    line = merged.find(1, true).line\n    ;(lines || (lines = [])).push(line);\n  }\n  return lines\n}\n\n// Get the line number of the start of the visual line that the\n// given line number is part of.\nfunction visualLineNo(doc, lineN) {\n  var line = getLine(doc, lineN), vis = visualLine(line);\n  if (line == vis) { return lineN }\n  return lineNo(vis)\n}\n\n// Get the line number of the start of the next visual line after\n// the given line.\nfunction visualLineEndNo(doc, lineN) {\n  if (lineN > doc.lastLine()) { return lineN }\n  var line = getLine(doc, lineN), merged;\n  if (!lineIsHidden(doc, line)) { return lineN }\n  while (merged = collapsedSpanAtEnd(line))\n    { line = merged.find(1, true).line; }\n  return lineNo(line) + 1\n}\n\n// Compute whether a line is hidden. Lines count as hidden when they\n// are part of a visual line that starts with another line, or when\n// they are entirely covered by collapsed, non-widget span.\nfunction lineIsHidden(doc, line) {\n  var sps = sawCollapsedSpans && line.markedSpans;\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n    sp = sps[i];\n    if (!sp.marker.collapsed) { continue }\n    if (sp.from == null) { return true }\n    if (sp.marker.widgetNode) { continue }\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n      { return true }\n  } }\n}\nfunction lineIsHiddenInner(doc, line, span) {\n  if (span.to == null) {\n    var end = span.marker.find(1, true);\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n  }\n  if (span.marker.inclusiveRight && span.to == line.text.length)\n    { return true }\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n    sp = line.markedSpans[i];\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n        (sp.to == null || sp.to != span.from) &&\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n        lineIsHiddenInner(doc, line, sp)) { return true }\n  }\n}\n\n// Find the height above the given line.\nfunction heightAtLine(lineObj) {\n  lineObj = visualLine(lineObj);\n\n  var h = 0, chunk = lineObj.parent;\n  for (var i = 0; i < chunk.lines.length; ++i) {\n    var line = chunk.lines[i];\n    if (line == lineObj) { break }\n    else { h += line.height; }\n  }\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n      var cur = p.children[i$1];\n      if (cur == chunk) { break }\n      else { h += cur.height; }\n    }\n  }\n  return h\n}\n\n// Compute the character length of a line, taking into account\n// collapsed ranges (see markText) that might hide parts, and join\n// other lines onto it.\nfunction lineLength(line) {\n  if (line.height == 0) { return 0 }\n  var len = line.text.length, merged, cur = line;\n  while (merged = collapsedSpanAtStart(cur)) {\n    var found = merged.find(0, true);\n    cur = found.from.line;\n    len += found.from.ch - found.to.ch;\n  }\n  cur = line;\n  while (merged = collapsedSpanAtEnd(cur)) {\n    var found$1 = merged.find(0, true);\n    len -= cur.text.length - found$1.from.ch;\n    cur = found$1.to.line;\n    len += cur.text.length - found$1.to.ch;\n  }\n  return len\n}\n\n// Find the longest line in the document.\nfunction findMaxLine(cm) {\n  var d = cm.display, doc = cm.doc;\n  d.maxLine = getLine(doc, doc.first);\n  d.maxLineLength = lineLength(d.maxLine);\n  d.maxLineChanged = true;\n  doc.iter(function (line) {\n    var len = lineLength(line);\n    if (len > d.maxLineLength) {\n      d.maxLineLength = len;\n      d.maxLine = line;\n    }\n  });\n}\n\n// BIDI HELPERS\n\nfunction iterateBidiSections(order, from, to, f) {\n  if (!order) { return f(from, to, \"ltr\") }\n  var found = false;\n  for (var i = 0; i < order.length; ++i) {\n    var part = order[i];\n    if (part.from < to && part.to > from || from == to && part.to == from) {\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n      found = true;\n    }\n  }\n  if (!found) { f(from, to, \"ltr\"); }\n}\n\nvar bidiOther = null;\nfunction getBidiPartAt(order, ch, sticky) {\n  var found;\n  bidiOther = null;\n  for (var i = 0; i < order.length; ++i) {\n    var cur = order[i];\n    if (cur.from < ch && cur.to > ch) { return i }\n    if (cur.to == ch) {\n      if (cur.from != cur.to && sticky == \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n    if (cur.from == ch) {\n      if (cur.from != cur.to && sticky != \"before\") { found = i; }\n      else { bidiOther = i; }\n    }\n  }\n  return found != null ? found : bidiOther\n}\n\n// Bidirectional ordering algorithm\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n// that this (partially) implements.\n\n// One-char codes used for character types:\n// L (L):   Left-to-Right\n// R (R):   Right-to-Left\n// r (AL):  Right-to-Left Arabic\n// 1 (EN):  European Number\n// + (ES):  European Number Separator\n// % (ET):  European Number Terminator\n// n (AN):  Arabic Number\n// , (CS):  Common Number Separator\n// m (NSM): Non-Spacing Mark\n// b (BN):  Boundary Neutral\n// s (B):   Paragraph Separator\n// t (S):   Segment Separator\n// w (WS):  Whitespace\n// N (ON):  Other Neutrals\n\n// Returns null if characters are ordered as they appear\n// (left-to-right), or an array of sections ({from, to, level}\n// objects) in the order in which they occur visually.\nvar bidiOrdering = (function() {\n  // Character types for codepoints 0 to 0xff\n  var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n  // Character types for codepoints 0x600 to 0x6f9\n  var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n  function charType(code) {\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\n    else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n    else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n    else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n    else if (code == 0x200c) { return \"b\" }\n    else { return \"L\" }\n  }\n\n  var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n  function BidiSpan(level, from, to) {\n    this.level = level;\n    this.from = from; this.to = to;\n  }\n\n  return function(str, direction) {\n    var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n    if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n    var len = str.length, types = [];\n    for (var i = 0; i < len; ++i)\n      { types.push(charType(str.charCodeAt(i))); }\n\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\n    // change the type of the NSM to the type of the previous\n    // character. If the NSM is at the start of the level run, it will\n    // get the type of sor.\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n      var type = types[i$1];\n      if (type == \"m\") { types[i$1] = prev; }\n      else { prev = type; }\n    }\n\n    // W2. Search backwards from each instance of a European number\n    // until the first strong type (R, L, AL, or sor) is found. If an\n    // AL is found, change the type of the European number to Arabic\n    // number.\n    // W3. Change all ALs to R.\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n      var type$1 = types[i$2];\n      if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n    }\n\n    // W4. A single European separator between two European numbers\n    // changes to a European number. A single common separator between\n    // two numbers of the same type changes to that type.\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n      var type$2 = types[i$3];\n      if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n      else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n               (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n      prev$1 = type$2;\n    }\n\n    // W5. A sequence of European terminators adjacent to European\n    // numbers changes to all European numbers.\n    // W6. Otherwise, separators and terminators change to Other\n    // Neutral.\n    for (var i$4 = 0; i$4 < len; ++i$4) {\n      var type$3 = types[i$4];\n      if (type$3 == \",\") { types[i$4] = \"N\"; }\n      else if (type$3 == \"%\") {\n        var end = (void 0);\n        for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n        var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n        for (var j = i$4; j < end; ++j) { types[j] = replace; }\n        i$4 = end - 1;\n      }\n    }\n\n    // W7. Search backwards from each instance of a European number\n    // until the first strong type (R, L, or sor) is found. If an L is\n    // found, then change the type of the European number to L.\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n      var type$4 = types[i$5];\n      if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n      else if (isStrong.test(type$4)) { cur$1 = type$4; }\n    }\n\n    // N1. A sequence of neutrals takes the direction of the\n    // surrounding strong text if the text on both sides has the same\n    // direction. European and Arabic numbers act as if they were R in\n    // terms of their influence on neutrals. Start-of-level-run (sor)\n    // and end-of-level-run (eor) are used at level run boundaries.\n    // N2. Any remaining neutrals take the embedding direction.\n    for (var i$6 = 0; i$6 < len; ++i$6) {\n      if (isNeutral.test(types[i$6])) {\n        var end$1 = (void 0);\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n        var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n        var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n        var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n        i$6 = end$1 - 1;\n      }\n    }\n\n    // Here we depart from the documented algorithm, in order to avoid\n    // building up an actual levels array. Since there are only three\n    // levels (0, 1, 2) in an implementation that doesn't take\n    // explicit embedding into account, we can build up the order on\n    // the fly, without following the level-based algorithm.\n    var order = [], m;\n    for (var i$7 = 0; i$7 < len;) {\n      if (countsAsLeft.test(types[i$7])) {\n        var start = i$7;\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n        order.push(new BidiSpan(0, start, i$7));\n      } else {\n        var pos = i$7, at = order.length;\n        for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n        for (var j$2 = pos; j$2 < i$7;) {\n          if (countsAsNum.test(types[j$2])) {\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n            var nstart = j$2;\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n            pos = j$2;\n          } else { ++j$2; }\n        }\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n      }\n    }\n    if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n      order[0].from = m[0].length;\n      order.unshift(new BidiSpan(0, 0, m[0].length));\n    }\n    if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n      lst(order).to -= m[0].length;\n      order.push(new BidiSpan(0, len - m[0].length, len));\n    }\n\n    return direction == \"rtl\" ? order.reverse() : order\n  }\n})();\n\n// Get the bidi ordering for the given line (and cache it). Returns\n// false for lines that are fully left-to-right, and an array of\n// BidiSpan objects otherwise.\nfunction getOrder(line, direction) {\n  var order = line.order;\n  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n  return order\n}\n\nfunction moveCharLogically(line, ch, dir) {\n  var target = skipExtendingChars(line.text, ch + dir, dir);\n  return target < 0 || target > line.text.length ? null : target\n}\n\nfunction moveLogically(line, start, dir) {\n  var ch = moveCharLogically(line, start.ch, dir);\n  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n}\n\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\n  if (visually) {\n    var order = getOrder(lineObj, cm.doc.direction);\n    if (order) {\n      var part = dir < 0 ? lst(order) : order[0];\n      var moveInStorageOrder = (dir < 0) == (part.level == 1);\n      var sticky = moveInStorageOrder ? \"after\" : \"before\";\n      var ch;\n      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n      // it could be that the last bidi part is not on the last visual line,\n      // since visual lines contain content order-consecutive chunks.\n      // Thus, in rtl, we are looking for the first (content-order) character\n      // in the rtl chunk that is on the last line (that is, the same line\n      // as the last (content-order) character).\n      if (part.level > 0) {\n        var prep = prepareMeasureForLine(cm, lineObj);\n        ch = dir < 0 ? lineObj.text.length - 1 : 0;\n        var targetTop = measureCharPrepared(cm, prep, ch).top;\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n        if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n      } else { ch = dir < 0 ? part.to : part.from; }\n      return new Pos(lineNo, ch, sticky)\n    }\n  }\n  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n}\n\nfunction moveVisually(cm, line, start, dir) {\n  var bidi = getOrder(line, cm.doc.direction);\n  if (!bidi) { return moveLogically(line, start, dir) }\n  if (start.ch >= line.text.length) {\n    start.ch = line.text.length;\n    start.sticky = \"before\";\n  } else if (start.ch <= 0) {\n    start.ch = 0;\n    start.sticky = \"after\";\n  }\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n  if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n    // nothing interesting happens.\n    return moveLogically(line, start, dir)\n  }\n\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n  var prep;\n  var getWrappedLineExtent = function (ch) {\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n    prep = prep || prepareMeasureForLine(cm, line);\n    return wrappedLineExtentChar(cm, line, prep, ch)\n  };\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n  if (cm.doc.direction == \"rtl\" || part.level == 1) {\n    var moveInStorageOrder = (part.level == 1) == (dir < 0);\n    var ch = mv(start, moveInStorageOrder ? 1 : -1);\n    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n      // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n      var sticky = moveInStorageOrder ? \"before\" : \"after\";\n      return new Pos(start.line, ch, sticky)\n    }\n  }\n\n  // Case 3: Could not move within this bidi part in this visual line, so leave\n  // the current bidi part\n\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n      ? new Pos(start.line, mv(ch, 1), \"before\")\n      : new Pos(start.line, ch, \"after\"); };\n\n    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n      var part = bidi[partPos];\n      var moveInStorageOrder = (dir > 0) == (part.level != 1);\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n    }\n  };\n\n  // Case 3a: Look for other bidi parts on the same visual line\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n  if (res) { return res }\n\n  // Case 3b: Look for other bidi parts on the next visual line\n  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n    if (res) { return res }\n  }\n\n  // Case 4: Nowhere to move\n  return null\n}\n\n// EVENT HANDLING\n\n// Lightweight event framework. on/off also work on DOM nodes,\n// registering native DOM handlers.\n\nvar noHandlers = [];\n\nvar on = function(emitter, type, f) {\n  if (emitter.addEventListener) {\n    emitter.addEventListener(type, f, false);\n  } else if (emitter.attachEvent) {\n    emitter.attachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers || (emitter._handlers = {});\n    map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n  }\n};\n\nfunction getHandlers(emitter, type) {\n  return emitter._handlers && emitter._handlers[type] || noHandlers\n}\n\nfunction off(emitter, type, f) {\n  if (emitter.removeEventListener) {\n    emitter.removeEventListener(type, f, false);\n  } else if (emitter.detachEvent) {\n    emitter.detachEvent(\"on\" + type, f);\n  } else {\n    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\n    if (arr) {\n      var index = indexOf(arr, f);\n      if (index > -1)\n        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n    }\n  }\n}\n\nfunction signal(emitter, type /*, values...*/) {\n  var handlers = getHandlers(emitter, type);\n  if (!handlers.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2);\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n}\n\n// The DOM events that CodeMirror handles can be overridden by\n// registering a (non-DOM) handler on the editor for the event name,\n// and preventDefault-ing the event in that handler.\nfunction signalDOMEvent(cm, e, override) {\n  if (typeof e == \"string\")\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n  signal(cm, override || e.type, cm, e);\n  return e_defaultPrevented(e) || e.codemirrorIgnore\n}\n\nfunction signalCursorActivity(cm) {\n  var arr = cm._handlers && cm._handlers.cursorActivity;\n  if (!arr) { return }\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n    { set.push(arr[i]); } }\n}\n\nfunction hasHandler(emitter, type) {\n  return getHandlers(emitter, type).length > 0\n}\n\n// Add on and off methods to a constructor's prototype, to make\n// registering events on such objects more convenient.\nfunction eventMixin(ctor) {\n  ctor.prototype.on = function(type, f) {on(this, type, f);};\n  ctor.prototype.off = function(type, f) {off(this, type, f);};\n}\n\n// Due to the fact that we still support jurassic IE versions, some\n// compatibility wrappers are needed.\n\nfunction e_preventDefault(e) {\n  if (e.preventDefault) { e.preventDefault(); }\n  else { e.returnValue = false; }\n}\nfunction e_stopPropagation(e) {\n  if (e.stopPropagation) { e.stopPropagation(); }\n  else { e.cancelBubble = true; }\n}\nfunction e_defaultPrevented(e) {\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n}\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\nfunction e_target(e) {return e.target || e.srcElement}\nfunction e_button(e) {\n  var b = e.which;\n  if (b == null) {\n    if (e.button & 1) { b = 1; }\n    else if (e.button & 2) { b = 3; }\n    else if (e.button & 4) { b = 2; }\n  }\n  if (mac && e.ctrlKey && b == 1) { b = 3; }\n  return b\n}\n\n// Detect drag-and-drop\nvar dragAndDrop = function() {\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\n  // couldn't get it to work yet.\n  if (ie && ie_version < 9) { return false }\n  var div = elt('div');\n  return \"draggable\" in div || \"dragDrop\" in div\n}();\n\nvar zwspSupported;\nfunction zeroWidthElement(measure) {\n  if (zwspSupported == null) {\n    var test = elt(\"span\", \"\\u200b\");\n    removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n    if (measure.firstChild.offsetHeight != 0)\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n  }\n  var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n    elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  node.setAttribute(\"cm-text\", \"\");\n  return node\n}\n\n// Feature-detect IE's crummy client rect reporting for bidi text\nvar badBidiRects;\nfunction hasBadBidiRects(measure) {\n  if (badBidiRects != null) { return badBidiRects }\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n  var r0 = range(txt, 0, 1).getBoundingClientRect();\n  var r1 = range(txt, 1, 2).getBoundingClientRect();\n  removeChildren(measure);\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n  return badBidiRects = (r1.right - r0.right < 3)\n}\n\n// See if \"\".split is the broken IE version, if so, provide an\n// alternative way to split lines.\nvar splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n  var pos = 0, result = [], l = string.length;\n  while (pos <= l) {\n    var nl = string.indexOf(\"\\n\", pos);\n    if (nl == -1) { nl = string.length; }\n    var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n    var rt = line.indexOf(\"\\r\");\n    if (rt != -1) {\n      result.push(line.slice(0, rt));\n      pos += rt + 1;\n    } else {\n      result.push(line);\n      pos = nl + 1;\n    }\n  }\n  return result\n} : function (string) { return string.split(/\\r\\n?|\\n/); };\n\nvar hasSelection = window.getSelection ? function (te) {\n  try { return te.selectionStart != te.selectionEnd }\n  catch(e) { return false }\n} : function (te) {\n  var range$$1;\n  try {range$$1 = te.ownerDocument.selection.createRange();}\n  catch(e) {}\n  if (!range$$1 || range$$1.parentElement() != te) { return false }\n  return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n};\n\nvar hasCopyEvent = (function () {\n  var e = elt(\"div\");\n  if (\"oncopy\" in e) { return true }\n  e.setAttribute(\"oncopy\", \"return;\");\n  return typeof e.oncopy == \"function\"\n})();\n\nvar badZoomedRects = null;\nfunction hasBadZoomedRects(measure) {\n  if (badZoomedRects != null) { return badZoomedRects }\n  var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n  var normal = node.getBoundingClientRect();\n  var fromRange = range(node, 0, 1).getBoundingClientRect();\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n}\n\n// Known modes, by name and by MIME\nvar modes = {};\nvar mimeModes = {};\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nfunction defineMode(name, mode) {\n  if (arguments.length > 2)\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n  modes[name] = mode;\n}\n\nfunction defineMIME(mime, spec) {\n  mimeModes[mime] = spec;\n}\n\n// Given a MIME type, a {name, ...options} config object, or a name\n// string, return a mode config object.\nfunction resolveMode(spec) {\n  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n    spec = mimeModes[spec];\n  } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n    var found = mimeModes[spec.name];\n    if (typeof found == \"string\") { found = {name: found}; }\n    spec = createObj(found, spec);\n    spec.name = found.name;\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n    return resolveMode(\"application/xml\")\n  } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n    return resolveMode(\"application/json\")\n  }\n  if (typeof spec == \"string\") { return {name: spec} }\n  else { return spec || {name: \"null\"} }\n}\n\n// Given a mode spec (anything that resolveMode accepts), find and\n// initialize an actual mode object.\nfunction getMode(options, spec) {\n  spec = resolveMode(spec);\n  var mfactory = modes[spec.name];\n  if (!mfactory) { return getMode(options, \"text/plain\") }\n  var modeObj = mfactory(options, spec);\n  if (modeExtensions.hasOwnProperty(spec.name)) {\n    var exts = modeExtensions[spec.name];\n    for (var prop in exts) {\n      if (!exts.hasOwnProperty(prop)) { continue }\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n      modeObj[prop] = exts[prop];\n    }\n  }\n  modeObj.name = spec.name;\n  if (spec.helperType) { modeObj.helperType = spec.helperType; }\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n    { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n  return modeObj\n}\n\n// This can be used to attach properties to mode objects from\n// outside the actual mode definition.\nvar modeExtensions = {};\nfunction extendMode(mode, properties) {\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n  copyObj(properties, exts);\n}\n\nfunction copyState(mode, state) {\n  if (state === true) { return state }\n  if (mode.copyState) { return mode.copyState(state) }\n  var nstate = {};\n  for (var n in state) {\n    var val = state[n];\n    if (val instanceof Array) { val = val.concat([]); }\n    nstate[n] = val;\n  }\n  return nstate\n}\n\n// Given a mode and a state (for that mode), find the inner mode and\n// state at the position that the state refers to.\nfunction innerMode(mode, state) {\n  var info;\n  while (mode.innerMode) {\n    info = mode.innerMode(state);\n    if (!info || info.mode == mode) { break }\n    state = info.state;\n    mode = info.mode;\n  }\n  return info || {mode: mode, state: state}\n}\n\nfunction startState(mode, a1, a2) {\n  return mode.startState ? mode.startState(a1, a2) : true\n}\n\n// STRING STREAM\n\n// Fed to the mode parsers, provides helper functions to make\n// parsers more succinct.\n\nvar StringStream = function(string, tabSize) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n};\n\nStringStream.prototype.eol = function () {return this.pos >= this.string.length};\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\nStringStream.prototype.next = function () {\n  if (this.pos < this.string.length)\n    { return this.string.charAt(this.pos++) }\n};\nStringStream.prototype.eat = function (match) {\n  var ch = this.string.charAt(this.pos);\n  var ok;\n  if (typeof match == \"string\") { ok = ch == match; }\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n  if (ok) {++this.pos; return ch}\n};\nStringStream.prototype.eatWhile = function (match) {\n  var start = this.pos;\n  while (this.eat(match)){}\n  return this.pos > start\n};\nStringStream.prototype.eatSpace = function () {\n    var this$1 = this;\n\n  var start = this.pos;\n  while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n  return this.pos > start\n};\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\nStringStream.prototype.skipTo = function (ch) {\n  var found = this.string.indexOf(ch, this.pos);\n  if (found > -1) {this.pos = found; return true}\n};\nStringStream.prototype.backUp = function (n) {this.pos -= n;};\nStringStream.prototype.column = function () {\n  if (this.lastColumnPos < this.start) {\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n    this.lastColumnPos = this.start;\n  }\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.indentation = function () {\n  return countColumn(this.string, null, this.tabSize) -\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n};\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n  if (typeof pattern == \"string\") {\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n    var substr = this.string.substr(this.pos, pattern.length);\n    if (cased(substr) == cased(pattern)) {\n      if (consume !== false) { this.pos += pattern.length; }\n      return true\n    }\n  } else {\n    var match = this.string.slice(this.pos).match(pattern);\n    if (match && match.index > 0) { return null }\n    if (match && consume !== false) { this.pos += match[0].length; }\n    return match\n  }\n};\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\nStringStream.prototype.hideFirstChars = function (n, inner) {\n  this.lineStart += n;\n  try { return inner() }\n  finally { this.lineStart -= n; }\n};\n\n// Compute a style array (an array starting with a mode generation\n// -- for invalidation -- followed by pairs of end positions and\n// style strings), which is used to highlight the tokens on the\n// line.\nfunction highlightLine(cm, line, state, forceToEnd) {\n  // A styles array always starts with a number identifying the\n  // mode/overlays that it is based on (for easy invalidation).\n  var st = [cm.state.modeGen], lineClasses = {};\n  // Compute the base array of styles\n  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },\n    lineClasses, forceToEnd);\n\n  // Run overlays, adjust style array.\n  var loop = function ( o ) {\n    var overlay = cm.state.overlays[o], i = 1, at = 0;\n    runMode(cm, line.text, overlay.mode, true, function (end, style) {\n      var start = i;\n      // Ensure there's a token end at the current position, and that i points at it\n      while (at < end) {\n        var i_end = st[i];\n        if (i_end > end)\n          { st.splice(i, 1, end, st[i+1], i_end); }\n        i += 2;\n        at = Math.min(end, i_end);\n      }\n      if (!style) { return }\n      if (overlay.opaque) {\n        st.splice(start, i - start, end, \"overlay \" + style);\n        i = start + 2;\n      } else {\n        for (; start < i; start += 2) {\n          var cur = st[start+1];\n          st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n        }\n      }\n    }, lineClasses);\n  };\n\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n}\n\nfunction getLineStyles(cm, line, updateFrontier) {\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\n    var state = getStateBefore(cm, lineNo(line));\n    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n    line.stateAfter = state;\n    line.styles = result.styles;\n    if (result.classes) { line.styleClasses = result.classes; }\n    else if (line.styleClasses) { line.styleClasses = null; }\n    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++; }\n  }\n  return line.styles\n}\n\nfunction getStateBefore(cm, n, precise) {\n  var doc = cm.doc, display = cm.display;\n  if (!doc.mode.startState) { return true }\n  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n  if (!state) { state = startState(doc.mode); }\n  else { state = copyState(doc.mode, state); }\n  doc.iter(pos, n, function (line) {\n    processLine(cm, line.text, state);\n    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n    line.stateAfter = save ? copyState(doc.mode, state) : null;\n    ++pos;\n  });\n  if (precise) { doc.frontier = pos; }\n  return state\n}\n\n// Lightweight form of highlight -- proceed over this line and\n// update state, but don't save a style array. Used for lines that\n// aren't currently visible.\nfunction processLine(cm, text, state, startAt) {\n  var mode = cm.doc.mode;\n  var stream = new StringStream(text, cm.options.tabSize);\n  stream.start = stream.pos = startAt || 0;\n  if (text == \"\") { callBlankLine(mode, state); }\n  while (!stream.eol()) {\n    readToken(mode, stream, state);\n    stream.start = stream.pos;\n  }\n}\n\nfunction callBlankLine(mode, state) {\n  if (mode.blankLine) { return mode.blankLine(state) }\n  if (!mode.innerMode) { return }\n  var inner = innerMode(mode, state);\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n}\n\nfunction readToken(mode, stream, state, inner) {\n  for (var i = 0; i < 10; i++) {\n    if (inner) { inner[0] = innerMode(mode, state).mode; }\n    var style = mode.token(stream, state);\n    if (stream.pos > stream.start) { return style }\n  }\n  throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n}\n\n// Utility for getTokenAt and getLineTokens\nfunction takeToken(cm, pos, precise, asArray) {\n  var getObj = function (copy) { return ({\n    start: stream.start, end: stream.pos,\n    string: stream.current(),\n    type: style || null,\n    state: copy ? copyState(doc.mode, state) : state\n  }); };\n\n  var doc = cm.doc, mode = doc.mode, style;\n  pos = clipPos(doc, pos);\n  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n  var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n  if (asArray) { tokens = []; }\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n    stream.start = stream.pos;\n    style = readToken(mode, stream, state);\n    if (asArray) { tokens.push(getObj(true)); }\n  }\n  return asArray ? tokens : getObj()\n}\n\nfunction extractLineClasses(type, output) {\n  if (type) { for (;;) {\n    var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n    if (!lineClass) { break }\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n    var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n    if (output[prop] == null)\n      { output[prop] = lineClass[2]; }\n    else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n      { output[prop] += \" \" + lineClass[2]; }\n  } }\n  return type\n}\n\n// Run the given mode's parser over a line, calling f for each token.\nfunction runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n  var flattenSpans = mode.flattenSpans;\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n  var curStart = 0, curStyle = null;\n  var stream = new StringStream(text, cm.options.tabSize), style;\n  var inner = cm.options.addModeClass && [null];\n  if (text == \"\") { extractLineClasses(callBlankLine(mode, state), lineClasses); }\n  while (!stream.eol()) {\n    if (stream.pos > cm.options.maxHighlightLength) {\n      flattenSpans = false;\n      if (forceToEnd) { processLine(cm, text, state, stream.pos); }\n      stream.pos = text.length;\n      style = null;\n    } else {\n      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n    }\n    if (inner) {\n      var mName = inner[0].name;\n      if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n    }\n    if (!flattenSpans || curStyle != style) {\n      while (curStart < stream.start) {\n        curStart = Math.min(stream.start, curStart + 5000);\n        f(curStart, curStyle);\n      }\n      curStyle = style;\n    }\n    stream.start = stream.pos;\n  }\n  while (curStart < stream.pos) {\n    // Webkit seems to refuse to render text nodes longer than 57444\n    // characters, and returns inaccurate measurements in nodes\n    // starting around 5000 chars.\n    var pos = Math.min(stream.pos, curStart + 5000);\n    f(pos, curStyle);\n    curStart = pos;\n  }\n}\n\n// Finds the line to start with when starting a parse. Tries to\n// find a line with a stateAfter, so that it can start with a\n// valid state. If that fails, it returns the line with the\n// smallest indentation, which tends to need the least context to\n// parse correctly.\nfunction findStartLine(cm, n, precise) {\n  var minindent, minline, doc = cm.doc;\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n  for (var search = n; search > lim; --search) {\n    if (search <= doc.first) { return doc.first }\n    var line = getLine(doc, search - 1);\n    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }\n    var indented = countColumn(line.text, null, cm.options.tabSize);\n    if (minline == null || minindent > indented) {\n      minline = search - 1;\n      minindent = indented;\n    }\n  }\n  return minline\n}\n\n// LINE DATA STRUCTURE\n\n// Line objects. These hold state related to a line, including\n// highlighting info (the styles array).\nvar Line = function(text, markedSpans, estimateHeight) {\n  this.text = text;\n  attachMarkedSpans(this, markedSpans);\n  this.height = estimateHeight ? estimateHeight(this) : 1;\n};\n\nLine.prototype.lineNo = function () { return lineNo(this) };\neventMixin(Line);\n\n// Change the content (text, markers) of a line. Automatically\n// invalidates cached information and tries to re-estimate the\n// line's height.\nfunction updateLine(line, text, markedSpans, estimateHeight) {\n  line.text = text;\n  if (line.stateAfter) { line.stateAfter = null; }\n  if (line.styles) { line.styles = null; }\n  if (line.order != null) { line.order = null; }\n  detachMarkedSpans(line);\n  attachMarkedSpans(line, markedSpans);\n  var estHeight = estimateHeight ? estimateHeight(line) : 1;\n  if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n}\n\n// Detach a line from the document tree and its markers.\nfunction cleanUpLine(line) {\n  line.parent = null;\n  detachMarkedSpans(line);\n}\n\n// Convert a style as returned by a mode (either null, or a string\n// containing one or more styles) to a CSS style. This is cached,\n// and also looks for line-wide styles.\nvar styleToClassCache = {};\nvar styleToClassCacheWithMode = {};\nfunction interpretTokenStyle(style, options) {\n  if (!style || /^\\s*$/.test(style)) { return null }\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n  return cache[style] ||\n    (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n}\n\n// Render the DOM representation of the text of a line. Also builds\n// up a 'line map', which points at the DOM nodes that represent\n// specific stretches of text, and is used by the measuring code.\n// The returned object contains the DOM node, this map, and\n// information about line-wide styles that were set by the mode.\nfunction buildLineContent(cm, lineView) {\n  // The padding-right forces the element to have a 'border', which\n  // is needed on Webkit to be able to get line-level bounding\n  // rectangles for it (in measureChar).\n  var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n  var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                 col: 0, pos: 0, cm: cm,\n                 trailingSpace: false,\n                 splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n  lineView.measure = {};\n\n  // Iterate over the logical lines that make up this visual line.\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n    builder.pos = 0;\n    builder.addToken = buildToken;\n    // Optionally wire in some hacks into the token-rendering\n    // algorithm, to deal with browser quirks.\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n    builder.map = [];\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n    if (line.styleClasses) {\n      if (line.styleClasses.bgClass)\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n      if (line.styleClasses.textClass)\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n    }\n\n    // Ensure at least a single node is present, for measuring.\n    if (builder.map.length == 0)\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n    // Store the map and a cache object for the current logical line\n    if (i == 0) {\n      lineView.measure.map = builder.map;\n      lineView.measure.cache = {};\n    } else {\n      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n    }\n  }\n\n  // See issue #2901\n  if (webkit) {\n    var last = builder.content.lastChild;\n    if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n      { builder.content.className = \"cm-tab-wrap-hack\"; }\n  }\n\n  signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n  if (builder.pre.className)\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n  return builder\n}\n\nfunction defaultSpecialCharPlaceholder(ch) {\n  var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n  token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n  token.setAttribute(\"aria-label\", token.title);\n  return token\n}\n\n// Build up the DOM representation for a single token, and add it to\n// the line map. Takes care to render special characters separately.\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\n  if (!text) { return }\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n  var special = builder.cm.state.specialChars, mustWrap = false;\n  var content;\n  if (!special.test(text)) {\n    builder.col += text.length;\n    content = document.createTextNode(displayText);\n    builder.map.push(builder.pos, builder.pos + text.length, content);\n    if (ie && ie_version < 9) { mustWrap = true; }\n    builder.pos += text.length;\n  } else {\n    content = document.createDocumentFragment();\n    var pos = 0;\n    while (true) {\n      special.lastIndex = pos;\n      var m = special.exec(text);\n      var skipped = m ? m.index - pos : text.length - pos;\n      if (skipped) {\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n        else { content.appendChild(txt); }\n        builder.map.push(builder.pos, builder.pos + skipped, txt);\n        builder.col += skipped;\n        builder.pos += skipped;\n      }\n      if (!m) { break }\n      pos += skipped + 1;\n      var txt$1 = (void 0);\n      if (m[0] == \"\\t\") {\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n        txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n        txt$1.setAttribute(\"role\", \"presentation\");\n        txt$1.setAttribute(\"cm-text\", \"\\t\");\n        builder.col += tabWidth;\n      } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n        txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        builder.col += 1;\n      } else {\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n        txt$1.setAttribute(\"cm-text\", m[0]);\n        if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n        else { content.appendChild(txt$1); }\n        builder.col += 1;\n      }\n      builder.map.push(builder.pos, builder.pos + 1, txt$1);\n      builder.pos++;\n    }\n  }\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n  if (style || startStyle || endStyle || mustWrap || css) {\n    var fullStyle = style || \"\";\n    if (startStyle) { fullStyle += startStyle; }\n    if (endStyle) { fullStyle += endStyle; }\n    var token = elt(\"span\", [content], fullStyle, css);\n    if (title) { token.title = title; }\n    return builder.content.appendChild(token)\n  }\n  builder.content.appendChild(content);\n}\n\nfunction splitSpaces(text, trailingBefore) {\n  if (text.length > 1 && !/  /.test(text)) { return text }\n  var spaceBefore = trailingBefore, result = \"\";\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n    if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n      { ch = \"\\u00a0\"; }\n    result += ch;\n    spaceBefore = ch == \" \";\n  }\n  return result\n}\n\n// Work around nonsense dimensions being reported for stretches of\n// right-to-left text.\nfunction buildTokenBadBidi(inner, order) {\n  return function (builder, text, style, startStyle, endStyle, title, css) {\n    style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n    var start = builder.pos, end = start + text.length;\n    for (;;) {\n      // Find the part that overlaps with the start of this text\n      var part = (void 0);\n      for (var i = 0; i < order.length; i++) {\n        part = order[i];\n        if (part.to > start && part.from <= start) { break }\n      }\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n      startStyle = null;\n      text = text.slice(part.to - start);\n      start = part.to;\n    }\n  }\n}\n\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n  var widget = !ignoreWidget && marker.widgetNode;\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n    if (!widget)\n      { widget = builder.content.appendChild(document.createElement(\"span\")); }\n    widget.setAttribute(\"cm-marker\", marker.id);\n  }\n  if (widget) {\n    builder.cm.display.input.setUneditable(widget);\n    builder.content.appendChild(widget);\n  }\n  builder.pos += size;\n  builder.trailingSpace = false;\n}\n\n// Outputs a number of spans to make up a line, taking highlighting\n// and marked text into account.\nfunction insertLineContent(line, builder, styles) {\n  var spans = line.markedSpans, allText = line.text, at = 0;\n  if (!spans) {\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n    return\n  }\n\n  var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n  for (;;) {\n    if (nextChange == pos) { // Update current marker set\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n      collapsed = null; nextChange = Infinity;\n      var foundBookmarks = [], endStyles = (void 0);\n      for (var j = 0; j < spans.length; ++j) {\n        var sp = spans[j], m = sp.marker;\n        if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n          foundBookmarks.push(m);\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n            nextChange = sp.to;\n            spanEndStyle = \"\";\n          }\n          if (m.className) { spanStyle += \" \" + m.className; }\n          if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n          if (m.title && !title) { title = m.title; }\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n            { collapsed = sp; }\n        } else if (sp.from > pos && nextChange > sp.from) {\n          nextChange = sp.from;\n        }\n      }\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n      if (collapsed && (collapsed.from || 0) == pos) {\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                           collapsed.marker, collapsed.from == null);\n        if (collapsed.to == null) { return }\n        if (collapsed.to == pos) { collapsed = false; }\n      }\n    }\n    if (pos >= len) { break }\n\n    var upto = Math.min(len, nextChange);\n    while (true) {\n      if (text) {\n        var end = pos + text.length;\n        if (!collapsed) {\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n        }\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n        pos = end;\n        spanStartStyle = \"\";\n      }\n      text = allText.slice(at, at = styles[i++]);\n      style = interpretTokenStyle(styles[i++], builder.cm.options);\n    }\n  }\n}\n\n\n// These objects are used to represent the visible (currently drawn)\n// part of the document. A LineView may correspond to multiple\n// logical lines, if those are connected by collapsed ranges.\nfunction LineView(doc, line, lineN) {\n  // The starting line\n  this.line = line;\n  // Continuing lines, if any\n  this.rest = visualLineContinued(line);\n  // Number of logical lines in this visual line\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n  this.node = this.text = null;\n  this.hidden = lineIsHidden(doc, line);\n}\n\n// Create a range of LineView objects for the given lines.\nfunction buildViewArray(cm, from, to) {\n  var array = [], nextPos;\n  for (var pos = from; pos < to; pos = nextPos) {\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n    nextPos = pos + view.size;\n    array.push(view);\n  }\n  return array\n}\n\nvar operationGroup = null;\n\nfunction pushOperation(op) {\n  if (operationGroup) {\n    operationGroup.ops.push(op);\n  } else {\n    op.ownsGroup = operationGroup = {\n      ops: [op],\n      delayedCallbacks: []\n    };\n  }\n}\n\nfunction fireCallbacksForOps(group) {\n  // Calls delayed callbacks and cursorActivity handlers until no\n  // new ones appear\n  var callbacks = group.delayedCallbacks, i = 0;\n  do {\n    for (; i < callbacks.length; i++)\n      { callbacks[i].call(null); }\n    for (var j = 0; j < group.ops.length; j++) {\n      var op = group.ops[j];\n      if (op.cursorActivityHandlers)\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n    }\n  } while (i < callbacks.length)\n}\n\nfunction finishOperation(op, endCb) {\n  var group = op.ownsGroup;\n  if (!group) { return }\n\n  try { fireCallbacksForOps(group); }\n  finally {\n    operationGroup = null;\n    endCb(group);\n  }\n}\n\nvar orphanDelayedCallbacks = null;\n\n// Often, we want to signal events at a point where we are in the\n// middle of some work, but don't want the handler to start calling\n// other methods on the editor, which might be in an inconsistent\n// state or simply not expect any other events to happen.\n// signalLater looks whether there are any handlers, and schedules\n// them to be executed when the last operation ends, or, if no\n// operation is active, when a timeout fires.\nfunction signalLater(emitter, type /*, values...*/) {\n  var arr = getHandlers(emitter, type);\n  if (!arr.length) { return }\n  var args = Array.prototype.slice.call(arguments, 2), list;\n  if (operationGroup) {\n    list = operationGroup.delayedCallbacks;\n  } else if (orphanDelayedCallbacks) {\n    list = orphanDelayedCallbacks;\n  } else {\n    list = orphanDelayedCallbacks = [];\n    setTimeout(fireOrphanDelayed, 0);\n  }\n  var loop = function ( i ) {\n    list.push(function () { return arr[i].apply(null, args); });\n  };\n\n  for (var i = 0; i < arr.length; ++i)\n    loop( i );\n}\n\nfunction fireOrphanDelayed() {\n  var delayed = orphanDelayedCallbacks;\n  orphanDelayedCallbacks = null;\n  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n}\n\n// When an aspect of a line changes, a string is added to\n// lineView.changes. This updates the relevant part of the line's\n// DOM structure.\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\n  for (var j = 0; j < lineView.changes.length; j++) {\n    var type = lineView.changes[j];\n    if (type == \"text\") { updateLineText(cm, lineView); }\n    else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n    else if (type == \"class\") { updateLineClasses(cm, lineView); }\n    else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n  }\n  lineView.changes = null;\n}\n\n// Lines with gutter elements, widgets or a background class need to\n// be wrapped, and have the extra elements added to the wrapper div\nfunction ensureLineWrapped(lineView) {\n  if (lineView.node == lineView.text) {\n    lineView.node = elt(\"div\", null, null, \"position: relative\");\n    if (lineView.text.parentNode)\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n    lineView.node.appendChild(lineView.text);\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n  }\n  return lineView.node\n}\n\nfunction updateLineBackground(cm, lineView) {\n  var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n  if (cls) { cls += \" CodeMirror-linebackground\"; }\n  if (lineView.background) {\n    if (cls) { lineView.background.className = cls; }\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n  } else if (cls) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    cm.display.input.setUneditable(lineView.background);\n  }\n}\n\n// Wrapper around buildLineContent which will reuse the structure\n// in display.externalMeasured when possible.\nfunction getLineContent(cm, lineView) {\n  var ext = cm.display.externalMeasured;\n  if (ext && ext.line == lineView.line) {\n    cm.display.externalMeasured = null;\n    lineView.measure = ext.measure;\n    return ext.built\n  }\n  return buildLineContent(cm, lineView)\n}\n\n// Redraw the line's text. Interacts with the background and text\n// classes because the mode may output tokens that influence these\n// classes.\nfunction updateLineText(cm, lineView) {\n  var cls = lineView.text.className;\n  var built = getLineContent(cm, lineView);\n  if (lineView.text == lineView.node) { lineView.node = built.pre; }\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n  lineView.text = built.pre;\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n    lineView.bgClass = built.bgClass;\n    lineView.textClass = built.textClass;\n    updateLineClasses(cm, lineView);\n  } else if (cls) {\n    lineView.text.className = cls;\n  }\n}\n\nfunction updateLineClasses(cm, lineView) {\n  updateLineBackground(cm, lineView);\n  if (lineView.line.wrapClass)\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n  else if (lineView.node != lineView.text)\n    { lineView.node.className = \"\"; }\n  var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n  lineView.text.className = textClass || \"\";\n}\n\nfunction updateLineGutter(cm, lineView, lineN, dims) {\n  if (lineView.gutter) {\n    lineView.node.removeChild(lineView.gutter);\n    lineView.gutter = null;\n  }\n  if (lineView.gutterBackground) {\n    lineView.node.removeChild(lineView.gutterBackground);\n    lineView.gutterBackground = null;\n  }\n  if (lineView.line.gutterClass) {\n    var wrap = ensureLineWrapped(lineView);\n    lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                    (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(lineView.gutterBackground);\n    wrap.insertBefore(lineView.gutterBackground, lineView.text);\n  }\n  var markers = lineView.line.gutterMarkers;\n  if (cm.options.lineNumbers || markers) {\n    var wrap$1 = ensureLineWrapped(lineView);\n    var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n    cm.display.input.setUneditable(gutterWrap);\n    wrap$1.insertBefore(gutterWrap, lineView.text);\n    if (lineView.line.gutterClass)\n      { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n    if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n      { lineView.lineNumber = gutterWrap.appendChild(\n        elt(\"div\", lineNumberFor(cm.options, lineN),\n            \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n            (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n      if (found)\n        { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                   (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n    } }\n  }\n}\n\nfunction updateLineWidgets(cm, lineView, dims) {\n  if (lineView.alignable) { lineView.alignable = null; }\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n    next = node.nextSibling;\n    if (node.className == \"CodeMirror-linewidget\")\n      { lineView.node.removeChild(node); }\n  }\n  insertLineWidgets(cm, lineView, dims);\n}\n\n// Build a line's DOM representation from scratch\nfunction buildLineElement(cm, lineView, lineN, dims) {\n  var built = getLineContent(cm, lineView);\n  lineView.text = lineView.node = built.pre;\n  if (built.bgClass) { lineView.bgClass = built.bgClass; }\n  if (built.textClass) { lineView.textClass = built.textClass; }\n\n  updateLineClasses(cm, lineView);\n  updateLineGutter(cm, lineView, lineN, dims);\n  insertLineWidgets(cm, lineView, dims);\n  return lineView.node\n}\n\n// A lineView may contain multiple logical lines (when merged by\n// collapsed spans). The widgets for all of them need to be drawn.\nfunction insertLineWidgets(cm, lineView, dims) {\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n}\n\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n  if (!line.widgets) { return }\n  var wrap = ensureLineWrapped(lineView);\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n    var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n    if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n    positionLineWidget(widget, node, lineView, dims);\n    cm.display.input.setUneditable(node);\n    if (allowAbove && widget.above)\n      { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n    else\n      { wrap.appendChild(node); }\n    signalLater(widget, \"redraw\");\n  }\n}\n\nfunction positionLineWidget(widget, node, lineView, dims) {\n  if (widget.noHScroll) {\n    (lineView.alignable || (lineView.alignable = [])).push(node);\n    var width = dims.wrapperWidth;\n    node.style.left = dims.fixedPos + \"px\";\n    if (!widget.coverGutter) {\n      width -= dims.gutterTotalWidth;\n      node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n    }\n    node.style.width = width + \"px\";\n  }\n  if (widget.coverGutter) {\n    node.style.zIndex = 5;\n    node.style.position = \"relative\";\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n  }\n}\n\nfunction widgetHeight(widget) {\n  if (widget.height != null) { return widget.height }\n  var cm = widget.doc.cm;\n  if (!cm) { return 0 }\n  if (!contains(document.body, widget.node)) {\n    var parentStyle = \"position: relative;\";\n    if (widget.coverGutter)\n      { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n    if (widget.noHScroll)\n      { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n    removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n  }\n  return widget.height = widget.node.parentNode.offsetHeight\n}\n\n// Return true when the given mouse event happened in a widget\nfunction eventInWidget(display, e) {\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n    if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n        (n.parentNode == display.sizer && n != display.mover))\n      { return true }\n  }\n}\n\n// POSITION MEASUREMENT\n\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\nfunction paddingH(display) {\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\n  var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n  return data\n}\n\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\nfunction displayWidth(cm) {\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n}\nfunction displayHeight(cm) {\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n}\n\n// Ensure the lineView.wrapping.heights array is populated. This is\n// an array of bottom offsets for the lines that make up a drawn\n// line. When lineWrapping is on, there might be more than one\n// height.\nfunction ensureLineHeights(cm, lineView, rect) {\n  var wrapping = cm.options.lineWrapping;\n  var curWidth = wrapping && displayWidth(cm);\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n    var heights = lineView.measure.heights = [];\n    if (wrapping) {\n      lineView.measure.width = curWidth;\n      var rects = lineView.text.firstChild.getClientRects();\n      for (var i = 0; i < rects.length - 1; i++) {\n        var cur = rects[i], next = rects[i + 1];\n        if (Math.abs(cur.bottom - next.bottom) > 2)\n          { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n      }\n    }\n    heights.push(rect.bottom - rect.top);\n  }\n}\n\n// Find a line map (mapping character offsets to text nodes) and a\n// measurement cache for the given line number. (A line view might\n// contain multiple lines when collapsed ranges are present.)\nfunction mapFromLineView(lineView, line, lineN) {\n  if (lineView.line == line)\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n  for (var i = 0; i < lineView.rest.length; i++)\n    { if (lineView.rest[i] == line)\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n    { if (lineNo(lineView.rest[i$1]) > lineN)\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n}\n\n// Render a line into the hidden node display.externalMeasured. Used\n// when measurement is needed for a line that's not in the viewport.\nfunction updateExternalMeasurement(cm, line) {\n  line = visualLine(line);\n  var lineN = lineNo(line);\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n  view.lineN = lineN;\n  var built = view.built = buildLineContent(cm, view);\n  view.text = built.pre;\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n  return view\n}\n\n// Get a {top, bottom, left, right} box (in line-local coordinates)\n// for a given character.\nfunction measureChar(cm, line, ch, bias) {\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n}\n\n// Find a line view that corresponds to the given line number.\nfunction findViewForLine(cm, lineN) {\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n    { return cm.display.view[findViewIndex(cm, lineN)] }\n  var ext = cm.display.externalMeasured;\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n    { return ext }\n}\n\n// Measurement can be split in two steps, the set-up work that\n// applies to the whole line, and the measurement of the actual\n// character. Functions like coordsChar, that need to do a lot of\n// measurements in a row, can thus ensure that the set-up work is\n// only done once.\nfunction prepareMeasureForLine(cm, line) {\n  var lineN = lineNo(line);\n  var view = findViewForLine(cm, lineN);\n  if (view && !view.text) {\n    view = null;\n  } else if (view && view.changes) {\n    updateLineForChanges(cm, view, lineN, getDimensions(cm));\n    cm.curOp.forceUpdate = true;\n  }\n  if (!view)\n    { view = updateExternalMeasurement(cm, line); }\n\n  var info = mapFromLineView(view, line, lineN);\n  return {\n    line: line, view: view, rect: null,\n    map: info.map, cache: info.cache, before: info.before,\n    hasHeights: false\n  }\n}\n\n// Given a prepared measurement object, measures the position of an\n// actual character (or fetches it from the cache).\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n  if (prepared.before) { ch = -1; }\n  var key = ch + (bias || \"\"), found;\n  if (prepared.cache.hasOwnProperty(key)) {\n    found = prepared.cache[key];\n  } else {\n    if (!prepared.rect)\n      { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n    if (!prepared.hasHeights) {\n      ensureLineHeights(cm, prepared.view, prepared.rect);\n      prepared.hasHeights = true;\n    }\n    found = measureCharInner(cm, prepared, ch, bias);\n    if (!found.bogus) { prepared.cache[key] = found; }\n  }\n  return {left: found.left, right: found.right,\n          top: varHeight ? found.rtop : found.top,\n          bottom: varHeight ? found.rbottom : found.bottom}\n}\n\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\nfunction nodeAndOffsetInLineMap(map$$1, ch, bias) {\n  var node, start, end, collapse, mStart, mEnd;\n  // First, search the line map for the text node corresponding to,\n  // or closest to, the target character.\n  for (var i = 0; i < map$$1.length; i += 3) {\n    mStart = map$$1[i];\n    mEnd = map$$1[i + 1];\n    if (ch < mStart) {\n      start = 0; end = 1;\n      collapse = \"left\";\n    } else if (ch < mEnd) {\n      start = ch - mStart;\n      end = start + 1;\n    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n      end = mEnd - mStart;\n      start = end - 1;\n      if (ch >= mEnd) { collapse = \"right\"; }\n    }\n    if (start != null) {\n      node = map$$1[i + 2];\n      if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n        { collapse = bias; }\n      if (bias == \"left\" && start == 0)\n        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n          node = map$$1[(i -= 3) + 2];\n          collapse = \"left\";\n        } }\n      if (bias == \"right\" && start == mEnd - mStart)\n        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n          node = map$$1[(i += 3) + 2];\n          collapse = \"right\";\n        } }\n      break\n    }\n  }\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n}\n\nfunction getUsefulRect(rects, bias) {\n  var rect = nullRect;\n  if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n    if ((rect = rects[i]).left != rect.right) { break }\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n    if ((rect = rects[i$1]).left != rect.right) { break }\n  } }\n  return rect\n}\n\nfunction measureCharInner(cm, prepared, ch, bias) {\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n  var rect;\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n        { rect = node.parentNode.getBoundingClientRect(); }\n      else\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n      if (rect.left || rect.right || start == 0) { break }\n      end = start;\n      start = start - 1;\n      collapse = \"right\";\n    }\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n  } else { // If it is a widget, simply get the box for the whole widget.\n    if (start > 0) { collapse = bias = \"right\"; }\n    var rects;\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n      { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n    else\n      { rect = node.getBoundingClientRect(); }\n  }\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n    var rSpan = node.parentNode.getClientRects()[0];\n    if (rSpan)\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n    else\n      { rect = nullRect; }\n  }\n\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n  var mid = (rtop + rbot) / 2;\n  var heights = prepared.view.measure.heights;\n  var i = 0;\n  for (; i < heights.length - 1; i++)\n    { if (mid < heights[i]) { break } }\n  var top = i ? heights[i - 1] : 0, bot = heights[i];\n  var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                top: top, bottom: bot};\n  if (!rect.left && !rect.right) { result.bogus = true; }\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n  return result\n}\n\n// Work around problem with bounding client rects on ranges being\n// returned incorrectly when zoomed on IE10 and below.\nfunction maybeUpdateRectForZooming(measure, rect) {\n  if (!window.screen || screen.logicalXDPI == null ||\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n    { return rect }\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n}\n\nfunction clearLineMeasurementCacheFor(lineView) {\n  if (lineView.measure) {\n    lineView.measure.cache = {};\n    lineView.measure.heights = null;\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { lineView.measure.caches[i] = {}; } }\n  }\n}\n\nfunction clearLineMeasurementCache(cm) {\n  cm.display.externalMeasure = null;\n  removeChildren(cm.display.lineMeasure);\n  for (var i = 0; i < cm.display.view.length; i++)\n    { clearLineMeasurementCacheFor(cm.display.view[i]); }\n}\n\nfunction clearCaches(cm) {\n  clearLineMeasurementCache(cm);\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n  cm.display.lineNumChars = null;\n}\n\nfunction pageScrollX() {\n  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n  // which causes page_Offset and bounding client rects to use\n  // different reference viewports and invalidate our calculations.\n  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n  return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n}\nfunction pageScrollY() {\n  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n  return window.pageYOffset || (document.documentElement || document.body).scrollTop\n}\n\n// Converts a {top, bottom, left, right} box from line-local\n// coordinates into another coordinate system. Context may be one of\n// \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n// or \"page\".\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {\n    var size = widgetHeight(lineObj.widgets[i]);\n    rect.top += size; rect.bottom += size;\n  } } }\n  if (context == \"line\") { return rect }\n  if (!context) { context = \"local\"; }\n  var yOff = heightAtLine(lineObj);\n  if (context == \"local\") { yOff += paddingTop(cm.display); }\n  else { yOff -= cm.display.viewOffset; }\n  if (context == \"page\" || context == \"window\") {\n    var lOff = cm.display.lineSpace.getBoundingClientRect();\n    yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n    var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n    rect.left += xOff; rect.right += xOff;\n  }\n  rect.top += yOff; rect.bottom += yOff;\n  return rect\n}\n\n// Coverts a box from \"div\" coords to another coordinate system.\n// Context may be \"window\", \"page\", \"div\", or \"local\"./null.\nfunction fromCoordSystem(cm, coords, context) {\n  if (context == \"div\") { return coords }\n  var left = coords.left, top = coords.top;\n  // First move into \"page\" coordinate system\n  if (context == \"page\") {\n    left -= pageScrollX();\n    top -= pageScrollY();\n  } else if (context == \"local\" || !context) {\n    var localBox = cm.display.sizer.getBoundingClientRect();\n    left += localBox.left;\n    top += localBox.top;\n  }\n\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n}\n\nfunction charCoords(cm, pos, context, lineObj, bias) {\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n}\n\n// Returns a box for a given cursor position, which may have an\n// 'other' property containing the position of the secondary cursor\n// on a bidi boundary.\n// A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n// and after `char - 1` in writing order of `char - 1`\n// A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n// and before `char` in writing order of `char`\n// Examples (upper-case letters are RTL, lower-case are LTR):\n//     Pos(0, 1, ...)\n//     before   after\n// ab     a|b     a|b\n// aB     a|B     aB|\n// Ab     |Ab     A|b\n// AB     B|A     B|A\n// Every position after the last character on a line is considered to stick\n// to the last character on the line.\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n  lineObj = lineObj || getLine(cm.doc, pos.line);\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n  function get(ch, right) {\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n    if (right) { m.left = m.right; } else { m.right = m.left; }\n    return intoCoordSystem(cm, lineObj, m, context)\n  }\n  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n  if (ch >= lineObj.text.length) {\n    ch = lineObj.text.length;\n    sticky = \"before\";\n  } else if (ch <= 0) {\n    ch = 0;\n    sticky = \"after\";\n  }\n  if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n  function getBidi(ch, partPos, invert) {\n    var part = order[partPos], right = (part.level % 2) != 0;\n    return get(invert ? ch - 1 : ch, right != invert)\n  }\n  var partPos = getBidiPartAt(order, ch, sticky);\n  var other = bidiOther;\n  var val = getBidi(ch, partPos, sticky == \"before\");\n  if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n  return val\n}\n\n// Used to cheaply estimate the coordinates for a position. Used for\n// intermediate scroll updates.\nfunction estimateCoords(cm, pos) {\n  var left = 0;\n  pos = clipPos(cm.doc, pos);\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n  var lineObj = getLine(cm.doc, pos.line);\n  var top = heightAtLine(lineObj) + paddingTop(cm.display);\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\n}\n\n// Positions returned by coordsChar contain some extra information.\n// xRel is the relative x position of the input coordinates compared\n// to the found position (so xRel > 0 means the coordinates are to\n// the right of the character position, for example). When outside\n// is true, that means the coordinates lie outside the line's\n// vertical range.\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\n  var pos = Pos(line, ch, sticky);\n  pos.xRel = xRel;\n  if (outside) { pos.outside = true; }\n  return pos\n}\n\n// Compute the character position closest to the given coordinates.\n// Input must be lineSpace-local (\"div\" coordinate system).\nfunction coordsChar(cm, x, y) {\n  var doc = cm.doc;\n  y += cm.display.viewOffset;\n  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n  if (lineN > last)\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\n  if (x < 0) { x = 0; }\n\n  var lineObj = getLine(doc, lineN);\n  for (;;) {\n    var found = coordsCharInner(cm, lineObj, lineN, x, y);\n    var merged = collapsedSpanAtEnd(lineObj);\n    var mergedPos = merged && merged.find(0, true);\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n      { lineN = lineNo(lineObj = mergedPos.to.line); }\n    else\n      { return found }\n  }\n}\n\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n  var measure = function (ch) { return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \"line\"); };\n  var end = lineObj.text.length;\n  var begin = findFirst(function (ch) { return measure(ch - 1).bottom <= y; }, end, 0);\n  end = findFirst(function (ch) { return measure(ch).top > y; }, begin, end);\n  return {begin: begin, end: end}\n}\n\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n}\n\nfunction coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n  y -= heightAtLine(lineObj);\n  var begin = 0, end = lineObj.text.length;\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n  var pos;\n  var order = getOrder(lineObj, cm.doc.direction);\n  if (order) {\n    if (cm.options.lineWrapping) {\n      var assign;\n      ((assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, end = assign.end, assign));\n    }\n    pos = new Pos(lineNo$$1, begin);\n    var beginLeft = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure).left;\n    var dir = beginLeft < x ? 1 : -1;\n    var prevDiff, diff = beginLeft - x, prevPos;\n    do {\n      prevDiff = diff;\n      prevPos = pos;\n      pos = moveVisually(cm, lineObj, pos, dir);\n      if (pos == null || pos.ch < begin || end <= (pos.sticky == \"before\" ? pos.ch - 1 : pos.ch)) {\n        pos = prevPos;\n        break\n      }\n      diff = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure).left - x;\n    } while ((dir < 0) != (diff < 0) && (Math.abs(diff) <= Math.abs(prevDiff)))\n    if (Math.abs(diff) > Math.abs(prevDiff)) {\n      if ((diff < 0) == (prevDiff < 0)) { throw new Error(\"Broke out of infinite loop in coordsCharInner\") }\n      pos = prevPos;\n    }\n  } else {\n    var ch = findFirst(function (ch) {\n      var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \"line\");\n      if (box.top > y) {\n        // For the cursor stickiness\n        end = Math.min(ch, end);\n        return true\n      }\n      else if (box.bottom <= y) { return false }\n      else if (box.left > x) { return true }\n      else if (box.right < x) { return false }\n      else { return (x - box.left < box.right - x) }\n    }, begin, end);\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    pos = new Pos(lineNo$$1, ch, ch == end ? \"before\" : \"after\");\n  }\n  var coords = cursorCoords(cm, pos, \"line\", lineObj, preparedMeasure);\n  if (y < coords.top || coords.bottom < y) { pos.outside = true; }\n  pos.xRel = x < coords.left ? -1 : (x > coords.right ? 1 : 0);\n  return pos\n}\n\nvar measureText;\n// Compute the default text height.\nfunction textHeight(display) {\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n  if (measureText == null) {\n    measureText = elt(\"pre\");\n    // Measure a bunch of lines, for browsers that compute\n    // fractional heights.\n    for (var i = 0; i < 49; ++i) {\n      measureText.appendChild(document.createTextNode(\"x\"));\n      measureText.appendChild(elt(\"br\"));\n    }\n    measureText.appendChild(document.createTextNode(\"x\"));\n  }\n  removeChildrenAndAdd(display.measure, measureText);\n  var height = measureText.offsetHeight / 50;\n  if (height > 3) { display.cachedTextHeight = height; }\n  removeChildren(display.measure);\n  return height || 1\n}\n\n// Compute the default character width.\nfunction charWidth(display) {\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n  var anchor = elt(\"span\", \"xxxxxxxxxx\");\n  var pre = elt(\"pre\", [anchor]);\n  removeChildrenAndAdd(display.measure, pre);\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n  if (width > 2) { display.cachedCharWidth = width; }\n  return width || 10\n}\n\n// Do a bulk-read of the DOM positions and sizes needed to draw the\n// view, so that we don't interleave reading and writing to the DOM.\nfunction getDimensions(cm) {\n  var d = cm.display, left = {}, width = {};\n  var gutterLeft = d.gutters.clientLeft;\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n    width[cm.options.gutters[i]] = n.clientWidth;\n  }\n  return {fixedPos: compensateForHScroll(d),\n          gutterTotalWidth: d.gutters.offsetWidth,\n          gutterLeft: left,\n          gutterWidth: width,\n          wrapperWidth: d.wrapper.clientWidth}\n}\n\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n// but using getBoundingClientRect to get a sub-pixel-accurate\n// result.\nfunction compensateForHScroll(display) {\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n}\n\n// Returns a function that estimates the height of a line, to use as\n// first approximation until the line becomes visible (and is thus\n// properly measurable).\nfunction estimateHeight(cm) {\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n  return function (line) {\n    if (lineIsHidden(cm.doc, line)) { return 0 }\n\n    var widgetsHeight = 0;\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n    } }\n\n    if (wrapping)\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n    else\n      { return widgetsHeight + th }\n  }\n}\n\nfunction estimateLineHeights(cm) {\n  var doc = cm.doc, est = estimateHeight(cm);\n  doc.iter(function (line) {\n    var estHeight = est(line);\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  });\n}\n\n// Given a mouse event, find the corresponding position. If liberal\n// is false, it checks whether a gutter or scrollbar was clicked,\n// and returns null if it was. forRect is used by rectangular\n// selections, and tries to estimate a character position even for\n// coordinates beyond the right of the text.\nfunction posFromMouse(cm, e, liberal, forRect) {\n  var display = cm.display;\n  if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n  var x, y, space = display.lineSpace.getBoundingClientRect();\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n  try { x = e.clientX - space.left; y = e.clientY - space.top; }\n  catch (e) { return null }\n  var coords = coordsChar(cm, x, y), line;\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n  }\n  return coords\n}\n\n// Find the view element corresponding to a given line. Return null\n// when the line isn't visible.\nfunction findViewIndex(cm, n) {\n  if (n >= cm.display.viewTo) { return null }\n  n -= cm.display.viewFrom;\n  if (n < 0) { return null }\n  var view = cm.display.view;\n  for (var i = 0; i < view.length; i++) {\n    n -= view[i].size;\n    if (n < 0) { return i }\n  }\n}\n\nfunction updateSelection(cm) {\n  cm.display.input.showSelection(cm.display.input.prepareSelection());\n}\n\nfunction prepareSelection(cm, primary) {\n  var doc = cm.doc, result = {};\n  var curFragment = result.cursors = document.createDocumentFragment();\n  var selFragment = result.selection = document.createDocumentFragment();\n\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    if (primary === false && i == doc.sel.primIndex) { continue }\n    var range$$1 = doc.sel.ranges[i];\n    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\n    var collapsed = range$$1.empty();\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      { drawSelectionCursor(cm, range$$1.head, curFragment); }\n    if (!collapsed)\n      { drawSelectionRange(cm, range$$1, selFragment); }\n  }\n  return result\n}\n\n// Draws a cursor for the given range\nfunction drawSelectionCursor(cm, head, output) {\n  var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n  var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n  cursor.style.left = pos.left + \"px\";\n  cursor.style.top = pos.top + \"px\";\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n  if (pos.other) {\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n    otherCursor.style.display = \"\";\n    otherCursor.style.left = pos.other.left + \"px\";\n    otherCursor.style.top = pos.other.top + \"px\";\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n  }\n}\n\n// Draws the given range as a highlighted selection\nfunction drawSelectionRange(cm, range$$1, output) {\n  var display = cm.display, doc = cm.doc;\n  var fragment = document.createDocumentFragment();\n  var padding = paddingH(cm.display), leftSide = padding.left;\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\n  function add(left, top, width, bottom) {\n    if (top < 0) { top = 0; }\n    top = Math.round(top);\n    bottom = Math.round(bottom);\n    fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n  }\n\n  function drawForLine(line, fromArg, toArg) {\n    var lineObj = getLine(doc, line);\n    var lineLen = lineObj.text.length;\n    var start, end;\n    function coords(ch, bias) {\n      return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n    }\n\n    iterateBidiSections(getOrder(lineObj, doc.direction), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {\n      var leftPos = coords(from, \"left\"), rightPos, left, right;\n      if (from == to) {\n        rightPos = leftPos;\n        left = right = leftPos.left;\n      } else {\n        rightPos = coords(to - 1, \"right\");\n        if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n        left = leftPos.left;\n        right = rightPos.right;\n      }\n      if (fromArg == null && from == 0) { left = leftSide; }\n      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n        add(left, leftPos.top, null, leftPos.bottom);\n        left = leftSide;\n        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top); }\n      }\n      if (toArg == null && to == lineLen) { right = rightSide; }\n      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n        { start = leftPos; }\n      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n        { end = rightPos; }\n      if (left < leftSide + 1) { left = leftSide; }\n      add(left, rightPos.top, right - left, rightPos.bottom);\n    });\n    return {start: start, end: end}\n  }\n\n  var sFrom = range$$1.from(), sTo = range$$1.to();\n  if (sFrom.line == sTo.line) {\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n  } else {\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n    var singleVLine = visualLine(fromLine) == visualLine(toLine);\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n    if (singleVLine) {\n      if (leftEnd.top < rightStart.top - 2) {\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n      } else {\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n      }\n    }\n    if (leftEnd.bottom < rightStart.top)\n      { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n  }\n\n  output.appendChild(fragment);\n}\n\n// Cursor-blinking\nfunction restartBlink(cm) {\n  if (!cm.state.focused) { return }\n  var display = cm.display;\n  clearInterval(display.blinker);\n  var on = true;\n  display.cursorDiv.style.visibility = \"\";\n  if (cm.options.cursorBlinkRate > 0)\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n      cm.options.cursorBlinkRate); }\n  else if (cm.options.cursorBlinkRate < 0)\n    { display.cursorDiv.style.visibility = \"hidden\"; }\n}\n\nfunction ensureFocus(cm) {\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n}\n\nfunction delayBlurEvent(cm) {\n  cm.state.delayingBlurEvent = true;\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\n    cm.state.delayingBlurEvent = false;\n    onBlur(cm);\n  } }, 100);\n}\n\nfunction onFocus(cm, e) {\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n  if (cm.options.readOnly == \"nocursor\") { return }\n  if (!cm.state.focused) {\n    signal(cm, \"focus\", cm, e);\n    cm.state.focused = true;\n    addClass(cm.display.wrapper, \"CodeMirror-focused\");\n    // This test prevents this from firing when a context\n    // menu is closed (since the input reset would kill the\n    // select-all detection hack)\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n      cm.display.input.reset();\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n    }\n    cm.display.input.receivedFocus();\n  }\n  restartBlink(cm);\n}\nfunction onBlur(cm, e) {\n  if (cm.state.delayingBlurEvent) { return }\n\n  if (cm.state.focused) {\n    signal(cm, \"blur\", cm, e);\n    cm.state.focused = false;\n    rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n  }\n  clearInterval(cm.display.blinker);\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n}\n\n// Read the actual heights of the rendered lines, and update their\n// stored heights to match.\nfunction updateHeightsInViewport(cm) {\n  var display = cm.display;\n  var prevBottom = display.lineDiv.offsetTop;\n  for (var i = 0; i < display.view.length; i++) {\n    var cur = display.view[i], height = (void 0);\n    if (cur.hidden) { continue }\n    if (ie && ie_version < 8) {\n      var bot = cur.node.offsetTop + cur.node.offsetHeight;\n      height = bot - prevBottom;\n      prevBottom = bot;\n    } else {\n      var box = cur.node.getBoundingClientRect();\n      height = box.bottom - box.top;\n    }\n    var diff = cur.line.height - height;\n    if (height < 2) { height = textHeight(display); }\n    if (diff > .001 || diff < -.001) {\n      updateLineHeight(cur.line, height);\n      updateWidgetHeight(cur.line);\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n        { updateWidgetHeight(cur.rest[j]); } }\n    }\n  }\n}\n\n// Read and store the height of line widgets associated with the\n// given line.\nfunction updateWidgetHeight(line) {\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)\n    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }\n}\n\n// Compute the lines that are visible in a given viewport (defaults\n// the the current scroll position). viewport may contain top,\n// height, and ensure (see op.scrollToPos) properties.\nfunction visibleLines(display, doc, viewport) {\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n  top = Math.floor(top - paddingTop(display));\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n  // forces those lines into the viewport (if possible).\n  if (viewport && viewport.ensure) {\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n    if (ensureFrom < from) {\n      from = ensureFrom;\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n      to = ensureTo;\n    }\n  }\n  return {from: from, to: Math.max(to, from + 1)}\n}\n\n// Re-align line numbers and gutter marks to compensate for\n// horizontal scrolling.\nfunction alignHorizontally(cm) {\n  var display = cm.display, view = display.view;\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n  var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n    if (cm.options.fixedGutter) {\n      if (view[i].gutter)\n        { view[i].gutter.style.left = left; }\n      if (view[i].gutterBackground)\n        { view[i].gutterBackground.style.left = left; }\n    }\n    var align = view[i].alignable;\n    if (align) { for (var j = 0; j < align.length; j++)\n      { align[j].style.left = left; } }\n  } }\n  if (cm.options.fixedGutter)\n    { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n}\n\n// Used to ensure that the line number gutter is still the right\n// size for the current document size. Returns true when an update\n// is needed.\nfunction maybeUpdateLineNumberWidth(cm) {\n  if (!cm.options.lineNumbers) { return false }\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n  if (last.length != display.lineNumChars) {\n    var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                               \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n    display.lineGutter.style.width = \"\";\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n    display.lineNumWidth = display.lineNumInnerWidth + padding;\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n    display.lineGutter.style.width = display.lineNumWidth + \"px\";\n    updateGutterSpace(cm);\n    return true\n  }\n  return false\n}\n\n// SCROLLING THINGS INTO VIEW\n\n// If an editor sits on the top or bottom of the window, partially\n// scrolled out of view, this ensures that the cursor is visible.\nfunction maybeScrollWindow(cm, rect) {\n  if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n  if (rect.top + box.top < 0) { doScroll = true; }\n  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n  if (doScroll != null && !phantom) {\n    var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n    cm.display.lineSpace.appendChild(scrollNode);\n    scrollNode.scrollIntoView(doScroll);\n    cm.display.lineSpace.removeChild(scrollNode);\n  }\n}\n\n// Scroll a given position into view (immediately), verifying that\n// it actually became visible (as line heights are accurately\n// measured, the position of something may 'drift' during drawing).\nfunction scrollPosIntoView(cm, pos, end, margin) {\n  if (margin == null) { margin = 0; }\n  var rect;\n  for (var limit = 0; limit < 5; limit++) {\n    var changed = false;\n    var coords = cursorCoords(cm, pos);\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n    rect = {left: Math.min(coords.left, endCoords.left),\n            top: Math.min(coords.top, endCoords.top) - margin,\n            right: Math.max(coords.left, endCoords.left),\n            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n    var scrollPos = calculateScrollPos(cm, rect);\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n    if (scrollPos.scrollTop != null) {\n      updateScrollTop(cm, scrollPos.scrollTop);\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n    }\n    if (scrollPos.scrollLeft != null) {\n      setScrollLeft(cm, scrollPos.scrollLeft);\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n    }\n    if (!changed) { break }\n  }\n  return rect\n}\n\n// Scroll a given set of coordinates into view (immediately).\nfunction scrollIntoView(cm, rect) {\n  var scrollPos = calculateScrollPos(cm, rect);\n  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n}\n\n// Calculate a new scroll position needed to scroll the given\n// rectangle into view. Returns an object with scrollTop and\n// scrollLeft properties. When these are undefined, the\n// vertical/horizontal position does not need to be adjusted.\nfunction calculateScrollPos(cm, rect) {\n  var display = cm.display, snapMargin = textHeight(cm.display);\n  if (rect.top < 0) { rect.top = 0; }\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n  var screen = displayHeight(cm), result = {};\n  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n  var docBottom = cm.doc.height + paddingVert(display);\n  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n  if (rect.top < screentop) {\n    result.scrollTop = atTop ? 0 : rect.top;\n  } else if (rect.bottom > screentop + screen) {\n    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n    if (newTop != screentop) { result.scrollTop = newTop; }\n  }\n\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n  var tooWide = rect.right - rect.left > screenw;\n  if (tooWide) { rect.right = rect.left + screenw; }\n  if (rect.left < 10)\n    { result.scrollLeft = 0; }\n  else if (rect.left < screenleft)\n    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n  else if (rect.right > screenw + screenleft - 3)\n    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n  return result\n}\n\n// Store a relative adjustment to the scroll position in the current\n// operation (to be applied when the operation finishes).\nfunction addToScrollTop(cm, top) {\n  if (top == null) { return }\n  resolveScrollToPos(cm);\n  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n}\n\n// Make sure that at the end of the operation the current cursor is\n// shown.\nfunction ensureCursorVisible(cm) {\n  resolveScrollToPos(cm);\n  var cur = cm.getCursor(), from = cur, to = cur;\n  if (!cm.options.lineWrapping) {\n    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n    to = Pos(cur.line, cur.ch + 1);\n  }\n  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin};\n}\n\nfunction scrollToCoords(cm, x, y) {\n  if (x != null || y != null) { resolveScrollToPos(cm); }\n  if (x != null) { cm.curOp.scrollLeft = x; }\n  if (y != null) { cm.curOp.scrollTop = y; }\n}\n\nfunction scrollToRange(cm, range$$1) {\n  resolveScrollToPos(cm);\n  cm.curOp.scrollToPos = range$$1;\n}\n\n// When an operation has its scrollToPos property set, and another\n// scroll action is applied before the end of the operation, this\n// 'simulates' scrolling that position into view in a cheap way, so\n// that the effect of intermediate scroll commands is not ignored.\nfunction resolveScrollToPos(cm) {\n  var range$$1 = cm.curOp.scrollToPos;\n  if (range$$1) {\n    cm.curOp.scrollToPos = null;\n    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n    scrollToCoordsRange(cm, from, to, range$$1.margin);\n  }\n}\n\nfunction scrollToCoordsRange(cm, from, to, margin) {\n  var sPos = calculateScrollPos(cm, {\n    left: Math.min(from.left, to.left),\n    top: Math.min(from.top, to.top) - margin,\n    right: Math.max(from.right, to.right),\n    bottom: Math.max(from.bottom, to.bottom) + margin\n  });\n  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n}\n\n// Sync the scrollable area and scrollbars, ensure the viewport\n// covers the visible area.\nfunction updateScrollTop(cm, val) {\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n  if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n  setScrollTop(cm, val, true);\n  if (gecko) { updateDisplaySimple(cm); }\n  startWorker(cm, 100);\n}\n\nfunction setScrollTop(cm, val, forceScroll) {\n  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n  cm.doc.scrollTop = val;\n  cm.display.scrollbars.setScrollTop(val);\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n}\n\n// Sync scroller and scrollbar, ensure the gutter elements are\n// aligned.\nfunction setScrollLeft(cm, val, isScroller, forceScroll) {\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n  cm.doc.scrollLeft = val;\n  alignHorizontally(cm);\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n  cm.display.scrollbars.setScrollLeft(val);\n}\n\n// SCROLLBARS\n\n// Prepare DOM reads needed to update the scrollbars. Done in one\n// shot to minimize update/measure roundtrips.\nfunction measureForScrollbars(cm) {\n  var d = cm.display, gutterW = d.gutters.offsetWidth;\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n  return {\n    clientHeight: d.scroller.clientHeight,\n    viewHeight: d.wrapper.clientHeight,\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n    viewWidth: d.wrapper.clientWidth,\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\n    docHeight: docH,\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\n    nativeBarWidth: d.nativeBarWidth,\n    gutterWidth: gutterW\n  }\n}\n\nvar NativeScrollbars = function(place, scroll, cm) {\n  this.cm = cm;\n  var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n  var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n  place(vert); place(horiz);\n\n  on(vert, \"scroll\", function () {\n    if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n  });\n  on(horiz, \"scroll\", function () {\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n  });\n\n  this.checkedZeroWidth = false;\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n};\n\nNativeScrollbars.prototype.update = function (measure) {\n  var needsH = measure.scrollWidth > measure.clientWidth + 1;\n  var needsV = measure.scrollHeight > measure.clientHeight + 1;\n  var sWidth = measure.nativeBarWidth;\n\n  if (needsV) {\n    this.vert.style.display = \"block\";\n    this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n    // A bug in IE8 can cause this value to be negative, so guard it.\n    this.vert.firstChild.style.height =\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n  } else {\n    this.vert.style.display = \"\";\n    this.vert.firstChild.style.height = \"0\";\n  }\n\n  if (needsH) {\n    this.horiz.style.display = \"block\";\n    this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n    this.horiz.style.left = measure.barLeft + \"px\";\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n    this.horiz.firstChild.style.width =\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n  } else {\n    this.horiz.style.display = \"\";\n    this.horiz.firstChild.style.width = \"0\";\n  }\n\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n    if (sWidth == 0) { this.zeroWidthHack(); }\n    this.checkedZeroWidth = true;\n  }\n\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n};\n\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n};\n\nNativeScrollbars.prototype.setScrollTop = function (pos) {\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n};\n\nNativeScrollbars.prototype.zeroWidthHack = function () {\n  var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n  this.horiz.style.height = this.vert.style.width = w;\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n  this.disableHoriz = new Delayed;\n  this.disableVert = new Delayed;\n};\n\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n  bar.style.pointerEvents = \"auto\";\n  function maybeDisable() {\n    // To find out whether the scrollbar is still visible, we\n    // check whether the element under the pixel in the bottom\n    // right corner of the scrollbar box is the scrollbar box\n    // itself (when the bar is still visible) or its filler child\n    // (when the bar is hidden). If it is still visible, we keep\n    // it enabled, if it's hidden, we disable pointer events.\n    var box = bar.getBoundingClientRect();\n    var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n    if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n    else { delay.set(1000, maybeDisable); }\n  }\n  delay.set(1000, maybeDisable);\n};\n\nNativeScrollbars.prototype.clear = function () {\n  var parent = this.horiz.parentNode;\n  parent.removeChild(this.horiz);\n  parent.removeChild(this.vert);\n};\n\nvar NullScrollbars = function () {};\n\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\nNullScrollbars.prototype.setScrollLeft = function () {};\nNullScrollbars.prototype.setScrollTop = function () {};\nNullScrollbars.prototype.clear = function () {};\n\nfunction updateScrollbars(cm, measure) {\n  if (!measure) { measure = measureForScrollbars(cm); }\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n  updateScrollbarsInner(cm, measure);\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n      { updateHeightsInViewport(cm); }\n    updateScrollbarsInner(cm, measureForScrollbars(cm));\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n  }\n}\n\n// Re-synchronize the fake scrollbars with the actual size of the\n// content.\nfunction updateScrollbarsInner(cm, measure) {\n  var d = cm.display;\n  var sizes = d.scrollbars.update(measure);\n\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n  d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n  if (sizes.right && sizes.bottom) {\n    d.scrollbarFiller.style.display = \"block\";\n    d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n    d.scrollbarFiller.style.width = sizes.right + \"px\";\n  } else { d.scrollbarFiller.style.display = \"\"; }\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n    d.gutterFiller.style.display = \"block\";\n    d.gutterFiller.style.height = sizes.bottom + \"px\";\n    d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n  } else { d.gutterFiller.style.display = \"\"; }\n}\n\nvar scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\nfunction initScrollbars(cm) {\n  if (cm.display.scrollbars) {\n    cm.display.scrollbars.clear();\n    if (cm.display.scrollbars.addClass)\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n    // Prevent clicks in the scrollbars from killing focus\n    on(node, \"mousedown\", function () {\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n    });\n    node.setAttribute(\"cm-not-content\", \"true\");\n  }, function (pos, axis) {\n    if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n    else { updateScrollTop(cm, pos); }\n  }, cm);\n  if (cm.display.scrollbars.addClass)\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n}\n\n// Operations are used to wrap a series of changes to the editor\n// state in such a way that each change won't have to update the\n// cursor and display (which would be awkward, slow, and\n// error-prone). Instead, display updates are batched and then all\n// combined and executed at once.\n\nvar nextOpId = 0;\n// Start a new operation.\nfunction startOperation(cm) {\n  cm.curOp = {\n    cm: cm,\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\n    forceUpdate: false,      // Used to force a redraw\n    updateInput: null,       // Whether to reset the input textarea\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n    changeObjs: null,        // Accumulated changes, for firing change events\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n    selectionChanged: false, // Whether the selection needs to be redrawn\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n    scrollToPos: null,       // Used to scroll to a specific position\n    focus: false,\n    id: ++nextOpId           // Unique ID\n  };\n  pushOperation(cm.curOp);\n}\n\n// Finish an operation, updating the display and signalling delayed events\nfunction endOperation(cm) {\n  var op = cm.curOp;\n  finishOperation(op, function (group) {\n    for (var i = 0; i < group.ops.length; i++)\n      { group.ops[i].cm.curOp = null; }\n    endOperations(group);\n  });\n}\n\n// The DOM updates done when an operation finishes are batched so\n// that the minimum number of relayouts are required.\nfunction endOperations(group) {\n  var ops = group.ops;\n  for (var i = 0; i < ops.length; i++) // Read DOM\n    { endOperation_R1(ops[i]); }\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n    { endOperation_W1(ops[i$1]); }\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n    { endOperation_R2(ops[i$2]); }\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n    { endOperation_W2(ops[i$3]); }\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n    { endOperation_finish(ops[i$4]); }\n}\n\nfunction endOperation_R1(op) {\n  var cm = op.cm, display = cm.display;\n  maybeClipScrollbars(cm);\n  if (op.updateMaxLine) { findMaxLine(cm); }\n\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                       op.scrollToPos.to.line >= display.viewTo) ||\n    display.maxLineChanged && cm.options.lineWrapping;\n  op.update = op.mustUpdate &&\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n}\n\nfunction endOperation_W1(op) {\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n}\n\nfunction endOperation_R2(op) {\n  var cm = op.cm, display = cm.display;\n  if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n  op.barMeasure = measureForScrollbars(cm);\n\n  // If the max line changed since it was last measured, measure it,\n  // and ensure the document's width matches it.\n  // updateDisplay_W2 will use these properties to do the actual resizing\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n    cm.display.sizerWidth = op.adjustWidthTo;\n    op.barMeasure.scrollWidth =\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n  }\n\n  if (op.updatedDisplay || op.selectionChanged)\n    { op.preparedSelection = display.input.prepareSelection(op.focus); }\n}\n\nfunction endOperation_W2(op) {\n  var cm = op.cm;\n\n  if (op.adjustWidthTo != null) {\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n    cm.display.maxLineChanged = false;\n  }\n\n  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());\n  if (op.preparedSelection)\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\n    { updateScrollbars(cm, op.barMeasure); }\n  if (op.updatedDisplay)\n    { setDocumentHeight(cm, op.barMeasure); }\n\n  if (op.selectionChanged) { restartBlink(cm); }\n\n  if (cm.state.focused && op.updateInput)\n    { cm.display.input.reset(op.typing); }\n  if (takeFocus) { ensureFocus(op.cm); }\n}\n\nfunction endOperation_finish(op) {\n  var cm = op.cm, display = cm.display, doc = cm.doc;\n\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n  // Abort mouse wheel delta measurement, when scrolling explicitly\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n    { display.wheelStartX = display.wheelStartY = null; }\n\n  // Propagate the scroll position to the actual DOM scroller\n  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n  // If we need to scroll a specific position into view, do so.\n  if (op.scrollToPos) {\n    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n    maybeScrollWindow(cm, rect);\n  }\n\n  // Fire events for markers that are hidden/unidden by editing or\n  // undoing\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\n    { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n  if (display.wrapper.offsetHeight)\n    { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n  // Fire change events, and delayed event handlers\n  if (op.changeObjs)\n    { signal(cm, \"changes\", cm, op.changeObjs); }\n  if (op.update)\n    { op.update.finish(); }\n}\n\n// Run the given function in an operation\nfunction runInOp(cm, f) {\n  if (cm.curOp) { return f() }\n  startOperation(cm);\n  try { return f() }\n  finally { endOperation(cm); }\n}\n// Wraps a function in an operation. Returns the wrapped function.\nfunction operation(cm, f) {\n  return function() {\n    if (cm.curOp) { return f.apply(cm, arguments) }\n    startOperation(cm);\n    try { return f.apply(cm, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n// Used to add methods to editor and doc instances, wrapping them in\n// operations.\nfunction methodOp(f) {\n  return function() {\n    if (this.curOp) { return f.apply(this, arguments) }\n    startOperation(this);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(this); }\n  }\n}\nfunction docMethodOp(f) {\n  return function() {\n    var cm = this.cm;\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\n    startOperation(cm);\n    try { return f.apply(this, arguments) }\n    finally { endOperation(cm); }\n  }\n}\n\n// Updates the display.view data structure for a given change to the\n// document. From and to are in pre-change coordinates. Lendiff is\n// the amount of lines added or subtracted by the change. This is\n// used for changes that span multiple lines, or change the way\n// lines are divided into visual lines. regLineChange (below)\n// registers single-line changes.\nfunction regChange(cm, from, to, lendiff) {\n  if (from == null) { from = cm.doc.first; }\n  if (to == null) { to = cm.doc.first + cm.doc.size; }\n  if (!lendiff) { lendiff = 0; }\n\n  var display = cm.display;\n  if (lendiff && to < display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\n    { display.updateLineNumbers = from; }\n\n  cm.curOp.viewChanged = true;\n\n  if (from >= display.viewTo) { // Change after\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n      { resetView(cm); }\n  } else if (to <= display.viewFrom) { // Change before\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n      resetView(cm);\n    } else {\n      display.viewFrom += lendiff;\n      display.viewTo += lendiff;\n    }\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n    resetView(cm);\n  } else if (from <= display.viewFrom) { // Top overlap\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cut) {\n      display.view = display.view.slice(cut.index);\n      display.viewFrom = cut.lineN;\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  } else if (to >= display.viewTo) { // Bottom overlap\n    var cut$1 = viewCuttingPoint(cm, from, from, -1);\n    if (cut$1) {\n      display.view = display.view.slice(0, cut$1.index);\n      display.viewTo = cut$1.lineN;\n    } else {\n      resetView(cm);\n    }\n  } else { // Gap in the middle\n    var cutTop = viewCuttingPoint(cm, from, from, -1);\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n    if (cutTop && cutBot) {\n      display.view = display.view.slice(0, cutTop.index)\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n        .concat(display.view.slice(cutBot.index));\n      display.viewTo += lendiff;\n    } else {\n      resetView(cm);\n    }\n  }\n\n  var ext = display.externalMeasured;\n  if (ext) {\n    if (to < ext.lineN)\n      { ext.lineN += lendiff; }\n    else if (from < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n  }\n}\n\n// Register a change to a single line. Type must be one of \"text\",\n// \"gutter\", \"class\", \"widget\"\nfunction regLineChange(cm, line, type) {\n  cm.curOp.viewChanged = true;\n  var display = cm.display, ext = cm.display.externalMeasured;\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n    { display.externalMeasured = null; }\n\n  if (line < display.viewFrom || line >= display.viewTo) { return }\n  var lineView = display.view[findViewIndex(cm, line)];\n  if (lineView.node == null) { return }\n  var arr = lineView.changes || (lineView.changes = []);\n  if (indexOf(arr, type) == -1) { arr.push(type); }\n}\n\n// Clear the view.\nfunction resetView(cm) {\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n  cm.display.view = [];\n  cm.display.viewOffset = 0;\n}\n\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n    { return {index: index, lineN: newN} }\n  var n = cm.display.viewFrom;\n  for (var i = 0; i < index; i++)\n    { n += view[i].size; }\n  if (n != oldN) {\n    if (dir > 0) {\n      if (index == view.length - 1) { return null }\n      diff = (n + view[index].size) - oldN;\n      index++;\n    } else {\n      diff = n - oldN;\n    }\n    oldN += diff; newN += diff;\n  }\n  while (visualLineNo(cm.doc, newN) != newN) {\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n    index += dir;\n  }\n  return {index: index, lineN: newN}\n}\n\n// Force the view to cover a given range, adding empty view element\n// or clipping off existing ones as needed.\nfunction adjustView(cm, from, to) {\n  var display = cm.display, view = display.view;\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n    display.view = buildViewArray(cm, from, to);\n    display.viewFrom = from;\n  } else {\n    if (display.viewFrom > from)\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n    else if (display.viewFrom < from)\n      { display.view = display.view.slice(findViewIndex(cm, from)); }\n    display.viewFrom = from;\n    if (display.viewTo < to)\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n    else if (display.viewTo > to)\n      { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n  }\n  display.viewTo = to;\n}\n\n// Count the number of lines in the view whose DOM representation is\n// out of date (or nonexistent).\nfunction countDirtyView(cm) {\n  var view = cm.display.view, dirty = 0;\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n  }\n  return dirty\n}\n\n// HIGHLIGHT WORKER\n\nfunction startWorker(cm, time) {\n  if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n}\n\nfunction highlightWorker(cm) {\n  var doc = cm.doc;\n  if (doc.frontier < doc.first) { doc.frontier = doc.first; }\n  if (doc.frontier >= cm.display.viewTo) { return }\n  var end = +new Date + cm.options.workTime;\n  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n  var changedLines = [];\n\n  doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n    if (doc.frontier >= cm.display.viewFrom) { // Visible\n      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n      line.styles = highlighted.styles;\n      var oldCls = line.styleClasses, newCls = highlighted.classes;\n      if (newCls) { line.styleClasses = newCls; }\n      else if (oldCls) { line.styleClasses = null; }\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n      if (ischange) { changedLines.push(doc.frontier); }\n      line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n    } else {\n      if (line.text.length <= cm.options.maxHighlightLength)\n        { processLine(cm, line.text, state); }\n      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n    }\n    ++doc.frontier;\n    if (+new Date > end) {\n      startWorker(cm, cm.options.workDelay);\n      return true\n    }\n  });\n  if (changedLines.length) { runInOp(cm, function () {\n    for (var i = 0; i < changedLines.length; i++)\n      { regLineChange(cm, changedLines[i], \"text\"); }\n  }); }\n}\n\n// DISPLAY DRAWING\n\nvar DisplayUpdate = function(cm, viewport, force) {\n  var display = cm.display;\n\n  this.viewport = viewport;\n  // Store some values that we'll need later (but don't want to force a relayout for)\n  this.visible = visibleLines(display, cm.doc, viewport);\n  this.editorIsHidden = !display.wrapper.offsetWidth;\n  this.wrapperHeight = display.wrapper.clientHeight;\n  this.wrapperWidth = display.wrapper.clientWidth;\n  this.oldDisplayWidth = displayWidth(cm);\n  this.force = force;\n  this.dims = getDimensions(cm);\n  this.events = [];\n};\n\nDisplayUpdate.prototype.signal = function (emitter, type) {\n  if (hasHandler(emitter, type))\n    { this.events.push(arguments); }\n};\nDisplayUpdate.prototype.finish = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.events.length; i++)\n    { signal.apply(null, this$1.events[i]); }\n};\n\nfunction maybeClipScrollbars(cm) {\n  var display = cm.display;\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n    display.heightForcer.style.height = scrollGap(cm) + \"px\";\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n    display.scrollbarsClipped = true;\n  }\n}\n\nfunction selectionSnapshot(cm) {\n  if (cm.hasFocus()) { return null }\n  var active = activeElt();\n  if (!active || !contains(cm.display.lineDiv, active)) { return null }\n  var result = {activeElt: active};\n  if (window.getSelection) {\n    var sel = window.getSelection();\n    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n      result.anchorNode = sel.anchorNode;\n      result.anchorOffset = sel.anchorOffset;\n      result.focusNode = sel.focusNode;\n      result.focusOffset = sel.focusOffset;\n    }\n  }\n  return result\n}\n\nfunction restoreSelection(snapshot) {\n  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n  snapshot.activeElt.focus();\n  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n    var sel = window.getSelection(), range$$1 = document.createRange();\n    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n    range$$1.collapse(false);\n    sel.removeAllRanges();\n    sel.addRange(range$$1);\n    sel.extend(snapshot.focusNode, snapshot.focusOffset);\n  }\n}\n\n// Does the actual updating of the line display. Bails out\n// (returning false) when there is nothing to be done and forced is\n// false.\nfunction updateDisplayIfNeeded(cm, update) {\n  var display = cm.display, doc = cm.doc;\n\n  if (update.editorIsHidden) {\n    resetView(cm);\n    return false\n  }\n\n  // Bail out if the visible area is already rendered and nothing changed.\n  if (!update.force &&\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n      display.renderedView == display.view && countDirtyView(cm) == 0)\n    { return false }\n\n  if (maybeUpdateLineNumberWidth(cm)) {\n    resetView(cm);\n    update.dims = getDimensions(cm);\n  }\n\n  // Compute a suitable new viewport (from & to)\n  var end = doc.first + doc.size;\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n  if (sawCollapsedSpans) {\n    from = visualLineNo(cm.doc, from);\n    to = visualLineEndNo(cm.doc, to);\n  }\n\n  var different = from != display.viewFrom || to != display.viewTo ||\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n  adjustView(cm, from, to);\n\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n  // Position the mover div to align with the current scroll position\n  cm.display.mover.style.top = display.viewOffset + \"px\";\n\n  var toUpdate = countDirtyView(cm);\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n    { return false }\n\n  // For big changes, we hide the enclosing element during the\n  // update, since that speeds up the operations on most browsers.\n  var selSnapshot = selectionSnapshot(cm);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n  patchDisplay(cm, display.updateLineNumbers, update.dims);\n  if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n  display.renderedView = display.view;\n  // There might have been a widget with a focused element that got\n  // hidden or updated, if so re-focus it.\n  restoreSelection(selSnapshot);\n\n  // Prevent selection and cursors from interfering with the scroll\n  // width and height.\n  removeChildren(display.cursorDiv);\n  removeChildren(display.selectionDiv);\n  display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n  if (different) {\n    display.lastWrapHeight = update.wrapperHeight;\n    display.lastWrapWidth = update.wrapperWidth;\n    startWorker(cm, 400);\n  }\n\n  display.updateLineNumbers = null;\n\n  return true\n}\n\nfunction postUpdateDisplay(cm, update) {\n  var viewport = update.viewport;\n\n  for (var first = true;; first = false) {\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n      // Clip forced viewport to actual scrollable area.\n      if (viewport && viewport.top != null)\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n      // Updated line heights might result in the drawn area not\n      // actually covering the viewport. Keep looping until it does.\n      update.visible = visibleLines(cm.display, cm.doc, viewport);\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n        { break }\n    }\n    if (!updateDisplayIfNeeded(cm, update)) { break }\n    updateHeightsInViewport(cm);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n  }\n\n  update.signal(cm, \"update\", cm);\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n    update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n  }\n}\n\nfunction updateDisplaySimple(cm, viewport) {\n  var update = new DisplayUpdate(cm, viewport);\n  if (updateDisplayIfNeeded(cm, update)) {\n    updateHeightsInViewport(cm);\n    postUpdateDisplay(cm, update);\n    var barMeasure = measureForScrollbars(cm);\n    updateSelection(cm);\n    updateScrollbars(cm, barMeasure);\n    setDocumentHeight(cm, barMeasure);\n    update.finish();\n  }\n}\n\n// Sync the actual display DOM structure with display.view, removing\n// nodes for lines that are no longer in view, and creating the ones\n// that are not there yet, and updating the ones that are out of\n// date.\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\n  var display = cm.display, lineNumbers = cm.options.lineNumbers;\n  var container = display.lineDiv, cur = container.firstChild;\n\n  function rm(node) {\n    var next = node.nextSibling;\n    // Works around a throw-scroll bug in OS X Webkit\n    if (webkit && mac && cm.display.currentWheelTarget == node)\n      { node.style.display = \"none\"; }\n    else\n      { node.parentNode.removeChild(node); }\n    return next\n  }\n\n  var view = display.view, lineN = display.viewFrom;\n  // Loop over the elements in the view, syncing cur (the DOM nodes\n  // in display.lineDiv) with the view as we go.\n  for (var i = 0; i < view.length; i++) {\n    var lineView = view[i];\n    if (lineView.hidden) {\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n      var node = buildLineElement(cm, lineView, lineN, dims);\n      container.insertBefore(node, cur);\n    } else { // Already drawn\n      while (cur != lineView.node) { cur = rm(cur); }\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\n        updateNumbersFrom <= lineN && lineView.lineNumber;\n      if (lineView.changes) {\n        if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n        updateLineForChanges(cm, lineView, lineN, dims);\n      }\n      if (updateNumber) {\n        removeChildren(lineView.lineNumber);\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n      }\n      cur = lineView.node.nextSibling;\n    }\n    lineN += lineView.size;\n  }\n  while (cur) { cur = rm(cur); }\n}\n\nfunction updateGutterSpace(cm) {\n  var width = cm.display.gutters.offsetWidth;\n  cm.display.sizer.style.marginLeft = width + \"px\";\n}\n\nfunction setDocumentHeight(cm, measure) {\n  cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n  cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n}\n\n// Rebuild the gutter elements, ensure the margin to the left of the\n// code matches their width.\nfunction updateGutters(cm) {\n  var gutters = cm.display.gutters, specs = cm.options.gutters;\n  removeChildren(gutters);\n  var i = 0;\n  for (; i < specs.length; ++i) {\n    var gutterClass = specs[i];\n    var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n    if (gutterClass == \"CodeMirror-linenumbers\") {\n      cm.display.lineGutter = gElt;\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n    }\n  }\n  gutters.style.display = i ? \"\" : \"none\";\n  updateGutterSpace(cm);\n}\n\n// Make sure the gutters options contains the element\n// \"CodeMirror-linenumbers\" when the lineNumbers option is true.\nfunction setGuttersForLineNumbers(options) {\n  var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n  if (found == -1 && options.lineNumbers) {\n    options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n  } else if (found > -1 && !options.lineNumbers) {\n    options.gutters = options.gutters.slice(0);\n    options.gutters.splice(found, 1);\n  }\n}\n\n// Since the delta values reported on mouse wheel events are\n// unstandardized between browsers and even browser versions, and\n// generally horribly unpredictable, this code starts by measuring\n// the scroll effect that the first few mouse wheel events have,\n// and, from that, detects the way it can convert deltas to pixel\n// offsets afterwards.\n//\n// The reason we want to know the amount a wheel event will scroll\n// is that it gives us a chance to update the display before the\n// actual scrolling happens, reducing flickering.\n\nvar wheelSamples = 0;\nvar wheelPixelsPerUnit = null;\n// Fill in a browser-detected starting value on browsers where we\n// know one. These don't have to be accurate -- the result of them\n// being wrong would just be a slight flicker on the first wheel\n// scroll (if it is large enough).\nif (ie) { wheelPixelsPerUnit = -.53; }\nelse if (gecko) { wheelPixelsPerUnit = 15; }\nelse if (chrome) { wheelPixelsPerUnit = -.7; }\nelse if (safari) { wheelPixelsPerUnit = -1/3; }\n\nfunction wheelEventDelta(e) {\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n  else if (dy == null) { dy = e.wheelDelta; }\n  return {x: dx, y: dy}\n}\nfunction wheelEventPixels(e) {\n  var delta = wheelEventDelta(e);\n  delta.x *= wheelPixelsPerUnit;\n  delta.y *= wheelPixelsPerUnit;\n  return delta\n}\n\nfunction onScrollWheel(cm, e) {\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n  var display = cm.display, scroll = display.scroller;\n  // Quit if there's nothing to scroll here\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n  // Webkit browsers on OS X abort momentum scrolls when the target\n  // of the scroll event is removed from the scrollable element.\n  // This hack (see related code in patchDisplay) makes sure the\n  // element is kept around.\n  if (dy && mac && webkit) {\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n      for (var i = 0; i < view.length; i++) {\n        if (view[i].node == cur) {\n          cm.display.currentWheelTarget = cur;\n          break outer\n        }\n      }\n    }\n  }\n\n  // On some browsers, horizontal scrolling will cause redraws to\n  // happen before the gutter has been realigned, causing it to\n  // wriggle around in a most unseemly way. When we have an\n  // estimated pixels/delta value, we just handle horizontal\n  // scrolling entirely here. It'll be slightly off from native, but\n  // better than glitching out.\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n    if (dy && canScrollY)\n      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n    // Only prevent default scrolling if vertical scrolling is\n    // actually possible. Otherwise, it causes vertical scroll\n    // jitter on OSX trackpads when deltaX is small and deltaY\n    // is large (issue #3579)\n    if (!dy || (dy && canScrollY))\n      { e_preventDefault(e); }\n    display.wheelStartX = null; // Abort measurement, if in progress\n    return\n  }\n\n  // 'Project' the visible viewport to cover the area that is being\n  // scrolled into view (if we know enough to estimate it).\n  if (dy && wheelPixelsPerUnit != null) {\n    var pixels = dy * wheelPixelsPerUnit;\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n    updateDisplaySimple(cm, {top: top, bottom: bot});\n  }\n\n  if (wheelSamples < 20) {\n    if (display.wheelStartX == null) {\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n      display.wheelDX = dx; display.wheelDY = dy;\n      setTimeout(function () {\n        if (display.wheelStartX == null) { return }\n        var movedX = scroll.scrollLeft - display.wheelStartX;\n        var movedY = scroll.scrollTop - display.wheelStartY;\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n          (movedX && display.wheelDX && movedX / display.wheelDX);\n        display.wheelStartX = display.wheelStartY = null;\n        if (!sample) { return }\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n        ++wheelSamples;\n      }, 200);\n    } else {\n      display.wheelDX += dx; display.wheelDY += dy;\n    }\n  }\n}\n\n// Selection objects are immutable. A new one is created every time\n// the selection changes. A selection is one or more non-overlapping\n// (and non-touching) ranges, sorted, and an integer that indicates\n// which one is the primary selection (the one that's scrolled into\n// view, that getCursor returns, etc).\nvar Selection = function(ranges, primIndex) {\n  this.ranges = ranges;\n  this.primIndex = primIndex;\n};\n\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\nSelection.prototype.equals = function (other) {\n    var this$1 = this;\n\n  if (other == this) { return true }\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var here = this$1.ranges[i], there = other.ranges[i];\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n  }\n  return true\n};\n\nSelection.prototype.deepCopy = function () {\n    var this$1 = this;\n\n  var out = [];\n  for (var i = 0; i < this.ranges.length; i++)\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n  return new Selection(out, this.primIndex)\n};\n\nSelection.prototype.somethingSelected = function () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.ranges.length; i++)\n    { if (!this$1.ranges[i].empty()) { return true } }\n  return false\n};\n\nSelection.prototype.contains = function (pos, end) {\n    var this$1 = this;\n\n  if (!end) { end = pos; }\n  for (var i = 0; i < this.ranges.length; i++) {\n    var range = this$1.ranges[i];\n    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n      { return i }\n  }\n  return -1\n};\n\nvar Range = function(anchor, head) {\n  this.anchor = anchor; this.head = head;\n};\n\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n// Take an unsorted, potentially overlapping set of ranges, and\n// build a selection out of it. 'Consumes' ranges array (modifying\n// it).\nfunction normalizeSelection(ranges, primIndex) {\n  var prim = ranges[primIndex];\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n  primIndex = indexOf(ranges, prim);\n  for (var i = 1; i < ranges.length; i++) {\n    var cur = ranges[i], prev = ranges[i - 1];\n    if (cmp(prev.to(), cur.from()) >= 0) {\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n      if (i <= primIndex) { --primIndex; }\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n    }\n  }\n  return new Selection(ranges, primIndex)\n}\n\nfunction simpleSelection(anchor, head) {\n  return new Selection([new Range(anchor, head || anchor)], 0)\n}\n\n// Compute the position of the end of a change (its 'to' property\n// refers to the pre-change end).\nfunction changeEnd(change) {\n  if (!change.text) { return change.to }\n  return Pos(change.from.line + change.text.length - 1,\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n}\n\n// Adjust a position to refer to the post-change position of the\n// same text, or the end of the change if the change covers it.\nfunction adjustForChange(pos, change) {\n  if (cmp(pos, change.from) < 0) { return pos }\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n  return Pos(line, ch)\n}\n\nfunction computeSelAfterChange(doc, change) {\n  var out = [];\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\n    var range = doc.sel.ranges[i];\n    out.push(new Range(adjustForChange(range.anchor, change),\n                       adjustForChange(range.head, change)));\n  }\n  return normalizeSelection(out, doc.sel.primIndex)\n}\n\nfunction offsetPos(pos, old, nw) {\n  if (pos.line == old.line)\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n  else\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n}\n\n// Used by replaceSelections to allow moving the selection to the\n// start or around the replaced test. Hint may be \"start\" or \"around\".\nfunction computeReplacedSel(doc, changes, hint) {\n  var out = [];\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    var from = offsetPos(change.from, oldPrev, newPrev);\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n    oldPrev = change.to;\n    newPrev = to;\n    if (hint == \"around\") {\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n      out[i] = new Range(inv ? to : from, inv ? from : to);\n    } else {\n      out[i] = new Range(from, from);\n    }\n  }\n  return new Selection(out, doc.sel.primIndex)\n}\n\n// Used to get the editor into a consistent state again when options change.\n\nfunction loadMode(cm) {\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n  resetModeState(cm);\n}\n\nfunction resetModeState(cm) {\n  cm.doc.iter(function (line) {\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n  });\n  cm.doc.frontier = cm.doc.first;\n  startWorker(cm, 100);\n  cm.state.modeGen++;\n  if (cm.curOp) { regChange(cm); }\n}\n\n// DOCUMENT DATA STRUCTURE\n\n// By default, updates that start and end at the beginning of a line\n// are treated specially, in order to make the association of line\n// widgets and marker elements with the text behave more intuitive.\nfunction isWholeLineUpdate(doc, change) {\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n}\n\n// Perform a change on the document data structure.\nfunction updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n  function update(line, text, spans) {\n    updateLine(line, text, spans, estimateHeight$$1);\n    signalLater(line, \"change\", line, change);\n  }\n  function linesFor(start, end) {\n    var result = [];\n    for (var i = start; i < end; ++i)\n      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n    return result\n  }\n\n  var from = change.from, to = change.to, text = change.text;\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n  // Adjust the line structure\n  if (change.full) {\n    doc.insert(0, linesFor(0, text.length));\n    doc.remove(text.length, doc.size - text.length);\n  } else if (isWholeLineUpdate(doc, change)) {\n    // This is a whole-line replace. Treated specially to make\n    // sure line objects move the way they are supposed to.\n    var added = linesFor(0, text.length - 1);\n    update(lastLine, lastLine.text, lastSpans);\n    if (nlines) { doc.remove(from.line, nlines); }\n    if (added.length) { doc.insert(from.line, added); }\n  } else if (firstLine == lastLine) {\n    if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n    } else {\n      var added$1 = linesFor(1, text.length - 1);\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      doc.insert(from.line + 1, added$1);\n    }\n  } else if (text.length == 1) {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n    doc.remove(from.line + 1, nlines);\n  } else {\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n    var added$2 = linesFor(1, text.length - 1);\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n    doc.insert(from.line + 1, added$2);\n  }\n\n  signalLater(doc, \"change\", doc, change);\n}\n\n// Call f for all linked documents.\nfunction linkedDocs(doc, f, sharedHistOnly) {\n  function propagate(doc, skip, sharedHist) {\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n      var rel = doc.linked[i];\n      if (rel.doc == skip) { continue }\n      var shared = sharedHist && rel.sharedHist;\n      if (sharedHistOnly && !shared) { continue }\n      f(rel.doc, shared);\n      propagate(rel.doc, doc, shared);\n    } }\n  }\n  propagate(doc, null, true);\n}\n\n// Attach a document to an editor.\nfunction attachDoc(cm, doc) {\n  if (doc.cm) { throw new Error(\"This document is already in use.\") }\n  cm.doc = doc;\n  doc.cm = cm;\n  estimateLineHeights(cm);\n  loadMode(cm);\n  setDirectionClass(cm);\n  if (!cm.options.lineWrapping) { findMaxLine(cm); }\n  cm.options.mode = doc.modeOption;\n  regChange(cm);\n}\n\nfunction setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n}\n\nfunction directionChanged(cm) {\n  runInOp(cm, function () {\n    setDirectionClass(cm);\n    regChange(cm);\n  });\n}\n\nfunction History(startGen) {\n  // Arrays of change events and selections. Doing something adds an\n  // event to done and clears undo. Undoing moves events from done\n  // to undone, redoing moves them in the other direction.\n  this.done = []; this.undone = [];\n  this.undoDepth = Infinity;\n  // Used to track when changes can be merged into a single undo\n  // event\n  this.lastModTime = this.lastSelTime = 0;\n  this.lastOp = this.lastSelOp = null;\n  this.lastOrigin = this.lastSelOrigin = null;\n  // Used by the isClean() method\n  this.generation = this.maxGeneration = startGen || 1;\n}\n\n// Create a history change event from an updateDoc-style change\n// object.\nfunction historyChangeFromChange(doc, change) {\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n  return histChange\n}\n\n// Pop all selection events off the end of a history array. Stop at\n// a change event.\nfunction clearSelectionEvents(array) {\n  while (array.length) {\n    var last = lst(array);\n    if (last.ranges) { array.pop(); }\n    else { break }\n  }\n}\n\n// Find the top change event in the history. Pop off selection\n// events that are in the way.\nfunction lastChangeEvent(hist, force) {\n  if (force) {\n    clearSelectionEvents(hist.done);\n    return lst(hist.done)\n  } else if (hist.done.length && !lst(hist.done).ranges) {\n    return lst(hist.done)\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n    hist.done.pop();\n    return lst(hist.done)\n  }\n}\n\n// Register a change in the history. Merges changes that are within\n// a single operation, or are close together with an origin that\n// allows merging (starting with \"+\") into a single event.\nfunction addChangeToHistory(doc, change, selAfter, opId) {\n  var hist = doc.history;\n  hist.undone.length = 0;\n  var time = +new Date, cur;\n  var last;\n\n  if ((hist.lastOp == opId ||\n       hist.lastOrigin == change.origin && change.origin &&\n       ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n        change.origin.charAt(0) == \"*\")) &&\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n    // Merge this change into the last event\n    last = lst(cur.changes);\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n      // Optimized case for simple insertion -- don't want to add\n      // new changesets for every character typed\n      last.to = changeEnd(change);\n    } else {\n      // Add new sub-event\n      cur.changes.push(historyChangeFromChange(doc, change));\n    }\n  } else {\n    // Can not be merged, start a new event.\n    var before = lst(hist.done);\n    if (!before || !before.ranges)\n      { pushSelectionToHistory(doc.sel, hist.done); }\n    cur = {changes: [historyChangeFromChange(doc, change)],\n           generation: hist.generation};\n    hist.done.push(cur);\n    while (hist.done.length > hist.undoDepth) {\n      hist.done.shift();\n      if (!hist.done[0].ranges) { hist.done.shift(); }\n    }\n  }\n  hist.done.push(selAfter);\n  hist.generation = ++hist.maxGeneration;\n  hist.lastModTime = hist.lastSelTime = time;\n  hist.lastOp = hist.lastSelOp = opId;\n  hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n  if (!last) { signal(doc, \"historyAdded\"); }\n}\n\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\n  var ch = origin.charAt(0);\n  return ch == \"*\" ||\n    ch == \"+\" &&\n    prev.ranges.length == sel.ranges.length &&\n    prev.somethingSelected() == sel.somethingSelected() &&\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n}\n\n// Called whenever the selection changes, sets the new selection as\n// the pending selection in the history, and pushes the old pending\n// selection into the 'done' array when it was significantly\n// different (in number of selected ranges, emptiness, or time).\nfunction addSelectionToHistory(doc, sel, opId, options) {\n  var hist = doc.history, origin = options && options.origin;\n\n  // A new event is started when the previous origin does not match\n  // the current, or the origins don't allow matching. Origins\n  // starting with * are always merged, those starting with + are\n  // merged when similar and close together in time.\n  if (opId == hist.lastSelOp ||\n      (origin && hist.lastSelOrigin == origin &&\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n    { hist.done[hist.done.length - 1] = sel; }\n  else\n    { pushSelectionToHistory(sel, hist.done); }\n\n  hist.lastSelTime = +new Date;\n  hist.lastSelOrigin = origin;\n  hist.lastSelOp = opId;\n  if (options && options.clearRedo !== false)\n    { clearSelectionEvents(hist.undone); }\n}\n\nfunction pushSelectionToHistory(sel, dest) {\n  var top = lst(dest);\n  if (!(top && top.ranges && top.equals(sel)))\n    { dest.push(sel); }\n}\n\n// Used to store marked span information in the history.\nfunction attachLocalSpans(doc, change, from, to) {\n  var existing = change[\"spans_\" + doc.id], n = 0;\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n    if (line.markedSpans)\n      { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n    ++n;\n  });\n}\n\n// When un/re-doing restores text containing marked spans, those\n// that have been explicitly cleared should not be restored.\nfunction removeClearedSpans(spans) {\n  if (!spans) { return null }\n  var out;\n  for (var i = 0; i < spans.length; ++i) {\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n    else if (out) { out.push(spans[i]); }\n  }\n  return !out ? spans : out.length ? out : null\n}\n\n// Retrieve and filter the old marked spans stored in a change event.\nfunction getOldSpans(doc, change) {\n  var found = change[\"spans_\" + doc.id];\n  if (!found) { return null }\n  var nw = [];\n  for (var i = 0; i < change.text.length; ++i)\n    { nw.push(removeClearedSpans(found[i])); }\n  return nw\n}\n\n// Used for un/re-doing changes from the history. Combines the\n// result of computing the existing spans with the set of spans that\n// existed in the history (so that deleting around a span and then\n// undoing brings back the span).\nfunction mergeOldSpans(doc, change) {\n  var old = getOldSpans(doc, change);\n  var stretched = stretchSpansOverChange(doc, change);\n  if (!old) { return stretched }\n  if (!stretched) { return old }\n\n  for (var i = 0; i < old.length; ++i) {\n    var oldCur = old[i], stretchCur = stretched[i];\n    if (oldCur && stretchCur) {\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\n        var span = stretchCur[j];\n        for (var k = 0; k < oldCur.length; ++k)\n          { if (oldCur[k].marker == span.marker) { continue spans } }\n        oldCur.push(span);\n      }\n    } else if (stretchCur) {\n      old[i] = stretchCur;\n    }\n  }\n  return old\n}\n\n// Used both to provide a JSON-safe object in .getHistory, and, when\n// detaching a document, to split the history in two\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\n  var copy = [];\n  for (var i = 0; i < events.length; ++i) {\n    var event = events[i];\n    if (event.ranges) {\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n      continue\n    }\n    var changes = event.changes, newChanges = [];\n    copy.push({changes: newChanges});\n    for (var j = 0; j < changes.length; ++j) {\n      var change = changes[j], m = (void 0);\n      newChanges.push({from: change.from, to: change.to, text: change.text});\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n        if (indexOf(newGroup, Number(m[1])) > -1) {\n          lst(newChanges)[prop] = change[prop];\n          delete change[prop];\n        }\n      } } }\n    }\n  }\n  return copy\n}\n\n// The 'scroll' parameter given to many of these indicated whether\n// the new cursor position should be scrolled into view after\n// modifying the selection.\n\n// If shift is held or the extend flag is set, extends a range to\n// include a given position (and optionally a second position).\n// Otherwise, simply returns the range between the given positions.\n// Used for cursor motion and such.\nfunction extendRange(doc, range, head, other) {\n  if (doc.cm && doc.cm.display.shift || doc.extend) {\n    var anchor = range.anchor;\n    if (other) {\n      var posBefore = cmp(head, anchor) < 0;\n      if (posBefore != (cmp(other, anchor) < 0)) {\n        anchor = head;\n        head = other;\n      } else if (posBefore != (cmp(head, other) < 0)) {\n        head = other;\n      }\n    }\n    return new Range(anchor, head)\n  } else {\n    return new Range(other || head, head)\n  }\n}\n\n// Extend the primary selection range, discard the rest.\nfunction extendSelection(doc, head, other, options) {\n  setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n}\n\n// Extend all selections (pos is an array of selections with length\n// equal the number of selections)\nfunction extendSelections(doc, heads, options) {\n  var out = [];\n  for (var i = 0; i < doc.sel.ranges.length; i++)\n    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null); }\n  var newSel = normalizeSelection(out, doc.sel.primIndex);\n  setSelection(doc, newSel, options);\n}\n\n// Updates a single range in the selection.\nfunction replaceOneSelection(doc, i, range, options) {\n  var ranges = doc.sel.ranges.slice(0);\n  ranges[i] = range;\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n}\n\n// Reset the selection to a single range.\nfunction setSimpleSelection(doc, anchor, head, options) {\n  setSelection(doc, simpleSelection(anchor, head), options);\n}\n\n// Give beforeSelectionChange handlers a change to influence a\n// selection update.\nfunction filterSelectionChange(doc, sel, options) {\n  var obj = {\n    ranges: sel.ranges,\n    update: function(ranges) {\n      var this$1 = this;\n\n      this.ranges = [];\n      for (var i = 0; i < ranges.length; i++)\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                   clipPos(doc, ranges[i].head)); }\n    },\n    origin: options && options.origin\n  };\n  signal(doc, \"beforeSelectionChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\n  else { return sel }\n}\n\nfunction setSelectionReplaceHistory(doc, sel, options) {\n  var done = doc.history.done, last = lst(done);\n  if (last && last.ranges) {\n    done[done.length - 1] = sel;\n    setSelectionNoUndo(doc, sel, options);\n  } else {\n    setSelection(doc, sel, options);\n  }\n}\n\n// Set a new selection.\nfunction setSelection(doc, sel, options) {\n  setSelectionNoUndo(doc, sel, options);\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n}\n\nfunction setSelectionNoUndo(doc, sel, options) {\n  if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n    { sel = filterSelectionChange(doc, sel, options); }\n\n  var bias = options && options.bias ||\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n  if (!(options && options.scroll === false) && doc.cm)\n    { ensureCursorVisible(doc.cm); }\n}\n\nfunction setSelectionInner(doc, sel) {\n  if (sel.equals(doc.sel)) { return }\n\n  doc.sel = sel;\n\n  if (doc.cm) {\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n    signalCursorActivity(doc.cm);\n  }\n  signalLater(doc, \"cursorActivity\", doc);\n}\n\n// Verify that the selection does not partially select any atomic\n// marked ranges.\nfunction reCheckSelection(doc) {\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n}\n\n// Return a selection that does not partially select any atomic\n// ranges.\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\n  var out;\n  for (var i = 0; i < sel.ranges.length; i++) {\n    var range = sel.ranges[i];\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n    if (out || newAnchor != range.anchor || newHead != range.head) {\n      if (!out) { out = sel.ranges.slice(0, i); }\n      out[i] = new Range(newAnchor, newHead);\n    }\n  }\n  return out ? normalizeSelection(out, sel.primIndex) : sel\n}\n\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n  var line = getLine(doc, pos.line);\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n    var sp = line.markedSpans[i], m = sp.marker;\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n      if (mayClear) {\n        signal(m, \"beforeCursorEnter\");\n        if (m.explicitlyCleared) {\n          if (!line.markedSpans) { break }\n          else {--i; continue}\n        }\n      }\n      if (!m.atomic) { continue }\n\n      if (oldPos) {\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n      }\n\n      var far = m.find(dir < 0 ? -1 : 1);\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n    }\n  } }\n  return pos\n}\n\n// Ensure a given position is not inside an atomic range.\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\n  var dir = bias || 1;\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n  if (!found) {\n    doc.cantEdit = true;\n    return Pos(doc.first, 0)\n  }\n  return found\n}\n\nfunction movePos(doc, pos, dir, line) {\n  if (dir < 0 && pos.ch == 0) {\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n    else { return null }\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n    else { return null }\n  } else {\n    return new Pos(pos.line, pos.ch + dir)\n  }\n}\n\nfunction selectAll(cm) {\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n}\n\n// UPDATING\n\n// Allow \"beforeChange\" event handlers to influence a change\nfunction filterChange(doc, change, update) {\n  var obj = {\n    canceled: false,\n    from: change.from,\n    to: change.to,\n    text: change.text,\n    origin: change.origin,\n    cancel: function () { return obj.canceled = true; }\n  };\n  if (update) { obj.update = function (from, to, text, origin) {\n    if (from) { obj.from = clipPos(doc, from); }\n    if (to) { obj.to = clipPos(doc, to); }\n    if (text) { obj.text = text; }\n    if (origin !== undefined) { obj.origin = origin; }\n  }; }\n  signal(doc, \"beforeChange\", doc, obj);\n  if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n  if (obj.canceled) { return null }\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n}\n\n// Apply a change to a document, and add it to the document's\n// history, and propagating it to all linked documents.\nfunction makeChange(doc, change, ignoreReadOnly) {\n  if (doc.cm) {\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n    if (doc.cm.state.suppressEdits) { return }\n  }\n\n  if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n    change = filterChange(doc, change, true);\n    if (!change) { return }\n  }\n\n  // Possibly split or suppress the update based on the presence\n  // of read-only spans in its range.\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n  if (split) {\n    for (var i = split.length - 1; i >= 0; --i)\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text}); }\n  } else {\n    makeChangeInner(doc, change);\n  }\n}\n\nfunction makeChangeInner(doc, change) {\n  if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n  var selAfter = computeSelAfterChange(doc, change);\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n  var rebased = [];\n\n  linkedDocs(doc, function (doc, sharedHist) {\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n      rebaseHist(doc.history, change);\n      rebased.push(doc.history);\n    }\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n  });\n}\n\n// Revert a change stored in a document's history.\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\n\n  var hist = doc.history, event, selAfter = doc.sel;\n  var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n  // Verify that there is a useable event (so that ctrl-z won't\n  // needlessly clear selection events)\n  var i = 0;\n  for (; i < source.length; i++) {\n    event = source[i];\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n      { break }\n  }\n  if (i == source.length) { return }\n  hist.lastOrigin = hist.lastSelOrigin = null;\n\n  for (;;) {\n    event = source.pop();\n    if (event.ranges) {\n      pushSelectionToHistory(event, dest);\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\n        setSelection(doc, event, {clearRedo: false});\n        return\n      }\n      selAfter = event;\n    }\n    else { break }\n  }\n\n  // Build up a reverse change object to add to the opposite history\n  // stack (redo when undoing, and vice versa).\n  var antiChanges = [];\n  pushSelectionToHistory(selAfter, dest);\n  dest.push({changes: antiChanges, generation: hist.generation});\n  hist.generation = event.generation || ++hist.maxGeneration;\n\n  var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n  var loop = function ( i ) {\n    var change = event.changes[i];\n    change.origin = type;\n    if (filter && !filterChange(doc, change, false)) {\n      source.length = 0;\n      return {}\n    }\n\n    antiChanges.push(historyChangeFromChange(doc, change));\n\n    var after = i ? computeSelAfterChange(doc, change) : lst(source);\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n    var rebased = [];\n\n    // Propagate to the linked documents\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n    });\n  };\n\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n    var returned = loop( i$1 );\n\n    if ( returned ) return returned.v;\n  }\n}\n\n// Sub-views need their line numbers shifted when text is added\n// above or below them in the parent document.\nfunction shiftDoc(doc, distance) {\n  if (distance == 0) { return }\n  doc.first += distance;\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n    Pos(range.anchor.line + distance, range.anchor.ch),\n    Pos(range.head.line + distance, range.head.ch)\n  ); }), doc.sel.primIndex);\n  if (doc.cm) {\n    regChange(doc.cm, doc.first, doc.first - distance, distance);\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n      { regLineChange(doc.cm, l, \"gutter\"); }\n  }\n}\n\n// More lower-level change function, handling only a single document\n// (not linked ones).\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\n  if (doc.cm && !doc.cm.curOp)\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n  if (change.to.line < doc.first) {\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n    return\n  }\n  if (change.from.line > doc.lastLine()) { return }\n\n  // Clip the change to the size of this doc\n  if (change.from.line < doc.first) {\n    var shift = change.text.length - 1 - (doc.first - change.from.line);\n    shiftDoc(doc, shift);\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n              text: [lst(change.text)], origin: change.origin};\n  }\n  var last = doc.lastLine();\n  if (change.to.line > last) {\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n              text: [change.text[0]], origin: change.origin};\n  }\n\n  change.removed = getBetween(doc, change.from, change.to);\n\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n  else { updateDoc(doc, change, spans); }\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n}\n\n// Handle the interaction of a change to a document with the editor\n// that this document is part of.\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n  var recomputeMaxLength = false, checkWidthStart = from.line;\n  if (!cm.options.lineWrapping) {\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\n      if (line == display.maxLine) {\n        recomputeMaxLength = true;\n        return true\n      }\n    });\n  }\n\n  if (doc.sel.contains(change.from, change.to) > -1)\n    { signalCursorActivity(cm); }\n\n  updateDoc(doc, change, spans, estimateHeight(cm));\n\n  if (!cm.options.lineWrapping) {\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n      var len = lineLength(line);\n      if (len > display.maxLineLength) {\n        display.maxLine = line;\n        display.maxLineLength = len;\n        display.maxLineChanged = true;\n        recomputeMaxLength = false;\n      }\n    });\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n  }\n\n  // Adjust frontier, schedule worker\n  doc.frontier = Math.min(doc.frontier, from.line);\n  startWorker(cm, 400);\n\n  var lendiff = change.text.length - (to.line - from.line) - 1;\n  // Remember that these lines changed, for updating the display\n  if (change.full)\n    { regChange(cm); }\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n    { regLineChange(cm, from.line, \"text\"); }\n  else\n    { regChange(cm, from.line, to.line + 1, lendiff); }\n\n  var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n  if (changeHandler || changesHandler) {\n    var obj = {\n      from: from, to: to,\n      text: change.text,\n      removed: change.removed,\n      origin: change.origin\n    };\n    if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n  }\n  cm.display.selForContextMenu = null;\n}\n\nfunction replaceRange(doc, code, from, to, origin) {\n  if (!to) { to = from; }\n  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n  if (typeof code == \"string\") { code = doc.splitLines(code); }\n  makeChange(doc, {from: from, to: to, text: code, origin: origin});\n}\n\n// Rebasing/resetting history to deal with externally-sourced changes\n\nfunction rebaseHistSelSingle(pos, from, to, diff) {\n  if (to < pos.line) {\n    pos.line += diff;\n  } else if (from < pos.line) {\n    pos.line = from;\n    pos.ch = 0;\n  }\n}\n\n// Tries to rebase an array of history events given a change in the\n// document. If the change touches the same lines as the event, the\n// event, and everything 'behind' it, is discarded. If the change is\n// before the event, the event's positions are updated. Uses a\n// copy-on-write scheme for the positions, to avoid having to\n// reallocate them all on every rebase, but also avoid problems with\n// shared position objects being unsafely updated.\nfunction rebaseHistArray(array, from, to, diff) {\n  for (var i = 0; i < array.length; ++i) {\n    var sub = array[i], ok = true;\n    if (sub.ranges) {\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n      for (var j = 0; j < sub.ranges.length; j++) {\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n      }\n      continue\n    }\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n      var cur = sub.changes[j$1];\n      if (to < cur.from.line) {\n        cur.from = Pos(cur.from.line + diff, cur.from.ch);\n        cur.to = Pos(cur.to.line + diff, cur.to.ch);\n      } else if (from <= cur.to.line) {\n        ok = false;\n        break\n      }\n    }\n    if (!ok) {\n      array.splice(0, i + 1);\n      i = 0;\n    }\n  }\n}\n\nfunction rebaseHist(hist, change) {\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n  rebaseHistArray(hist.done, from, to, diff);\n  rebaseHistArray(hist.undone, from, to, diff);\n}\n\n// Utility for applying a change to a line by handle or number,\n// returning the number and optionally registering the line as\n// changed.\nfunction changeLine(doc, handle, changeType, op) {\n  var no = handle, line = handle;\n  if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n  else { no = lineNo(handle); }\n  if (no == null) { return null }\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n  return line\n}\n\n// The document is represented as a BTree consisting of leaves, with\n// chunk of lines in them, and branches, with up to ten leaves or\n// other branch nodes below them. The top node is always a branch\n// node, and is the document object itself (meaning it has\n// additional methods and properties).\n//\n// All nodes have parent links. The tree is used both to go from\n// line numbers to line objects, and to go from objects to numbers.\n// It also indexes by height, and is used to convert between height\n// and line object, and to find the total height of the document.\n//\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\nvar LeafChunk = function(lines) {\n  var this$1 = this;\n\n  this.lines = lines;\n  this.parent = null;\n  var height = 0;\n  for (var i = 0; i < lines.length; ++i) {\n    lines[i].parent = this$1;\n    height += lines[i].height;\n  }\n  this.height = height;\n};\n\nLeafChunk.prototype.chunkSize = function () { return this.lines.length };\n\n// Remove the n lines at offset 'at'.\nLeafChunk.prototype.removeInner = function (at, n) {\n    var this$1 = this;\n\n  for (var i = at, e = at + n; i < e; ++i) {\n    var line = this$1.lines[i];\n    this$1.height -= line.height;\n    cleanUpLine(line);\n    signalLater(line, \"delete\");\n  }\n  this.lines.splice(at, n);\n};\n\n// Helper used to collapse a small branch into a single leaf.\nLeafChunk.prototype.collapse = function (lines) {\n  lines.push.apply(lines, this.lines);\n};\n\n// Insert the given array of lines at offset 'at', count them as\n// having the given height.\nLeafChunk.prototype.insertInner = function (at, lines, height) {\n    var this$1 = this;\n\n  this.height += height;\n  this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n  for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\n};\n\n// Used to iterate over a part of the tree.\nLeafChunk.prototype.iterN = function (at, n, op) {\n    var this$1 = this;\n\n  for (var e = at + n; at < e; ++at)\n    { if (op(this$1.lines[at])) { return true } }\n};\n\nvar BranchChunk = function(children) {\n  var this$1 = this;\n\n  this.children = children;\n  var size = 0, height = 0;\n  for (var i = 0; i < children.length; ++i) {\n    var ch = children[i];\n    size += ch.chunkSize(); height += ch.height;\n    ch.parent = this$1;\n  }\n  this.size = size;\n  this.height = height;\n  this.parent = null;\n};\n\nBranchChunk.prototype.chunkSize = function () { return this.size };\n\nBranchChunk.prototype.removeInner = function (at, n) {\n    var this$1 = this;\n\n  this.size -= n;\n  for (var i = 0; i < this.children.length; ++i) {\n    var child = this$1.children[i], sz = child.chunkSize();\n    if (at < sz) {\n      var rm = Math.min(n, sz - at), oldHeight = child.height;\n      child.removeInner(at, rm);\n      this$1.height -= oldHeight - child.height;\n      if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n      if ((n -= rm) == 0) { break }\n      at = 0;\n    } else { at -= sz; }\n  }\n  // If the result is smaller than 25 lines, ensure that it is a\n  // single leaf node.\n  if (this.size - n < 25 &&\n      (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n    var lines = [];\n    this.collapse(lines);\n    this.children = [new LeafChunk(lines)];\n    this.children[0].parent = this;\n  }\n};\n\nBranchChunk.prototype.collapse = function (lines) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\n};\n\nBranchChunk.prototype.insertInner = function (at, lines, height) {\n    var this$1 = this;\n\n  this.size += lines.length;\n  this.height += height;\n  for (var i = 0; i < this.children.length; ++i) {\n    var child = this$1.children[i], sz = child.chunkSize();\n    if (at <= sz) {\n      child.insertInner(at, lines, height);\n      if (child.lines && child.lines.length > 50) {\n        // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n        // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n        var remaining = child.lines.length % 25 + 25;\n        for (var pos = remaining; pos < child.lines.length;) {\n          var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n          child.height -= leaf.height;\n          this$1.children.splice(++i, 0, leaf);\n          leaf.parent = this$1;\n        }\n        child.lines = child.lines.slice(0, remaining);\n        this$1.maybeSpill();\n      }\n      break\n    }\n    at -= sz;\n  }\n};\n\n// When a node has grown, check whether it should be split.\nBranchChunk.prototype.maybeSpill = function () {\n  if (this.children.length <= 10) { return }\n  var me = this;\n  do {\n    var spilled = me.children.splice(me.children.length - 5, 5);\n    var sibling = new BranchChunk(spilled);\n    if (!me.parent) { // Become the parent node\n      var copy = new BranchChunk(me.children);\n      copy.parent = me;\n      me.children = [copy, sibling];\n      me = copy;\n   } else {\n      me.size -= sibling.size;\n      me.height -= sibling.height;\n      var myIndex = indexOf(me.parent.children, me);\n      me.parent.children.splice(myIndex + 1, 0, sibling);\n    }\n    sibling.parent = me.parent;\n  } while (me.children.length > 10)\n  me.parent.maybeSpill();\n};\n\nBranchChunk.prototype.iterN = function (at, n, op) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.children.length; ++i) {\n    var child = this$1.children[i], sz = child.chunkSize();\n    if (at < sz) {\n      var used = Math.min(n, sz - at);\n      if (child.iterN(at, used, op)) { return true }\n      if ((n -= used) == 0) { break }\n      at = 0;\n    } else { at -= sz; }\n  }\n};\n\n// Line widgets are block elements displayed above or below a line.\n\nvar LineWidget = function(doc, node, options) {\n  var this$1 = this;\n\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n    { this$1[opt] = options[opt]; } } }\n  this.doc = doc;\n  this.node = node;\n};\n\nLineWidget.prototype.clear = function () {\n    var this$1 = this;\n\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n  if (no == null || !ws) { return }\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n  if (!ws.length) { line.widgets = null; }\n  var height = widgetHeight(this);\n  updateLineHeight(line, Math.max(0, line.height - height));\n  if (cm) {\n    runInOp(cm, function () {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n    signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n  }\n};\n\nLineWidget.prototype.changed = function () {\n    var this$1 = this;\n\n  var oldH = this.height, cm = this.doc.cm, line = this.line;\n  this.height = null;\n  var diff = widgetHeight(this) - oldH;\n  if (!diff) { return }\n  updateLineHeight(line, line.height + diff);\n  if (cm) {\n    runInOp(cm, function () {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n      signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n    });\n  }\n};\neventMixin(LineWidget);\n\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n    { addToScrollTop(cm, diff); }\n}\n\nfunction addLineWidget(doc, handle, node, options) {\n  var widget = new LineWidget(doc, node, options);\n  var cm = doc.cm;\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n  changeLine(doc, handle, \"widget\", function (line) {\n    var widgets = line.widgets || (line.widgets = []);\n    if (widget.insertAt == null) { widgets.push(widget); }\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n    widget.line = line;\n    if (cm && !lineIsHidden(doc, line)) {\n      var aboveVisible = heightAtLine(line) < doc.scrollTop;\n      updateLineHeight(line, line.height + widgetHeight(widget));\n      if (aboveVisible) { addToScrollTop(cm, widget.height); }\n      cm.curOp.forceUpdate = true;\n    }\n    return true\n  });\n  signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n  return widget\n}\n\n// TEXTMARKERS\n\n// Created with markText and setBookmark methods. A TextMarker is a\n// handle that can be used to clear or find a marked position in the\n// document. Line objects hold arrays (markedSpans) containing\n// {from, to, marker} object pointing to such marker objects, and\n// indicating that such a marker is present on that line. Multiple\n// lines may point to the same marker when it spans across lines.\n// The spans will have null for their from/to properties when the\n// marker continues beyond the start/end of the line. Markers have\n// links back to the lines they currently touch.\n\n// Collapsed markers have unique ids, in order to be able to order\n// them, which is needed for uniquely determining an outer marker\n// when they overlap (they may nest, but not partially overlap).\nvar nextMarkerId = 0;\n\nvar TextMarker = function(doc, type) {\n  this.lines = [];\n  this.type = type;\n  this.doc = doc;\n  this.id = ++nextMarkerId;\n};\n\n// Clear the marker.\nTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  var cm = this.doc.cm, withOp = cm && !cm.curOp;\n  if (withOp) { startOperation(cm); }\n  if (hasHandler(this, \"clear\")) {\n    var found = this.find();\n    if (found) { signalLater(this, \"clear\", found.from, found.to); }\n  }\n  var min = null, max = null;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n    else if (cm) {\n      if (span.to != null) { max = lineNo(line); }\n      if (span.from != null) { min = lineNo(line); }\n    }\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\n      { updateLineHeight(line, textHeight(cm.display)); }\n  }\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n    if (len > cm.display.maxLineLength) {\n      cm.display.maxLine = visual;\n      cm.display.maxLineLength = len;\n      cm.display.maxLineChanged = true;\n    }\n  } }\n\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n  this.lines.length = 0;\n  this.explicitlyCleared = true;\n  if (this.atomic && this.doc.cantEdit) {\n    this.doc.cantEdit = false;\n    if (cm) { reCheckSelection(cm.doc); }\n  }\n  if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n  if (withOp) { endOperation(cm); }\n  if (this.parent) { this.parent.clear(); }\n};\n\n// Find the position of the marker in the document. Returns a {from,\n// to} object by default. Side can be passed to get a specific side\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n// Pos objects returned contain a line object, rather than a line\n// number (used to prevent looking up the same line twice).\nTextMarker.prototype.find = function (side, lineObj) {\n    var this$1 = this;\n\n  if (side == null && this.type == \"bookmark\") { side = 1; }\n  var from, to;\n  for (var i = 0; i < this.lines.length; ++i) {\n    var line = this$1.lines[i];\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\n    if (span.from != null) {\n      from = Pos(lineObj ? line : lineNo(line), span.from);\n      if (side == -1) { return from }\n    }\n    if (span.to != null) {\n      to = Pos(lineObj ? line : lineNo(line), span.to);\n      if (side == 1) { return to }\n    }\n  }\n  return from && {from: from, to: to}\n};\n\n// Signals that the marker's widget changed, and surrounding layout\n// should be recomputed.\nTextMarker.prototype.changed = function () {\n    var this$1 = this;\n\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n  if (!pos || !cm) { return }\n  runInOp(cm, function () {\n    var line = pos.line, lineN = lineNo(pos.line);\n    var view = findViewForLine(cm, lineN);\n    if (view) {\n      clearLineMeasurementCacheFor(view);\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n    }\n    cm.curOp.updateMaxLine = true;\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n      var oldHeight = widget.height;\n      widget.height = null;\n      var dHeight = widgetHeight(widget) - oldHeight;\n      if (dHeight)\n        { updateLineHeight(line, line.height + dHeight); }\n    }\n    signalLater(cm, \"markerChanged\", cm, this$1);\n  });\n};\n\nTextMarker.prototype.attachLine = function (line) {\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n  }\n  this.lines.push(line);\n};\n\nTextMarker.prototype.detachLine = function (line) {\n  this.lines.splice(indexOf(this.lines, line), 1);\n  if (!this.lines.length && this.doc.cm) {\n    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n  }\n};\neventMixin(TextMarker);\n\n// Create a marker, wire it up to the right lines, and\nfunction markText(doc, from, to, options, type) {\n  // Shared markers (across linked documents) are handled separately\n  // (markTextShared will call out to this again, once per\n  // document).\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n  // Ensure we are in an operation.\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n  var marker = new TextMarker(doc, type), diff = cmp(from, to);\n  if (options) { copyObj(options, marker, false); }\n  // Don't connect empty markers unless clearWhenEmpty is false\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n    { return marker }\n  if (marker.replacedWith) {\n    // Showing up as a widget implies collapsed (widget replaces text)\n    marker.collapsed = true;\n    marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n  }\n  if (marker.collapsed) {\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n      { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n    seeCollapsedSpans();\n  }\n\n  if (marker.addToHistory)\n    { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n  var curLine = from.line, cm = doc.cm, updateMaxLine;\n  doc.iter(curLine, to.line + 1, function (line) {\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n      { updateMaxLine = true; }\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n    addMarkedSpan(line, new MarkedSpan(marker,\n                                       curLine == from.line ? from.ch : null,\n                                       curLine == to.line ? to.ch : null));\n    ++curLine;\n  });\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n  }); }\n\n  if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n  if (marker.readOnly) {\n    seeReadOnlySpans();\n    if (doc.history.done.length || doc.history.undone.length)\n      { doc.clearHistory(); }\n  }\n  if (marker.collapsed) {\n    marker.id = ++nextMarkerId;\n    marker.atomic = true;\n  }\n  if (cm) {\n    // Sync editor state\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n    if (marker.collapsed)\n      { regChange(cm, from.line, to.line + 1); }\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n    if (marker.atomic) { reCheckSelection(cm.doc); }\n    signalLater(cm, \"markerAdded\", cm, marker);\n  }\n  return marker\n}\n\n// SHARED TEXTMARKERS\n\n// A shared marker spans multiple linked documents. It is\n// implemented as a meta-marker-object controlling multiple normal\n// markers.\nvar SharedTextMarker = function(markers, primary) {\n  var this$1 = this;\n\n  this.markers = markers;\n  this.primary = primary;\n  for (var i = 0; i < markers.length; ++i)\n    { markers[i].parent = this$1; }\n};\n\nSharedTextMarker.prototype.clear = function () {\n    var this$1 = this;\n\n  if (this.explicitlyCleared) { return }\n  this.explicitlyCleared = true;\n  for (var i = 0; i < this.markers.length; ++i)\n    { this$1.markers[i].clear(); }\n  signalLater(this, \"clear\");\n};\n\nSharedTextMarker.prototype.find = function (side, lineObj) {\n  return this.primary.find(side, lineObj)\n};\neventMixin(SharedTextMarker);\n\nfunction markTextShared(doc, from, to, options, type) {\n  options = copyObj(options);\n  options.shared = false;\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n  var widget = options.widgetNode;\n  linkedDocs(doc, function (doc) {\n    if (widget) { options.widgetNode = widget.cloneNode(true); }\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n    for (var i = 0; i < doc.linked.length; ++i)\n      { if (doc.linked[i].isParent) { return } }\n    primary = lst(markers);\n  });\n  return new SharedTextMarker(markers, primary)\n}\n\nfunction findSharedMarkers(doc) {\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n}\n\nfunction copySharedMarkers(doc, markers) {\n  for (var i = 0; i < markers.length; i++) {\n    var marker = markers[i], pos = marker.find();\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n    if (cmp(mFrom, mTo)) {\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n      marker.markers.push(subMark);\n      subMark.parent = marker;\n    }\n  }\n}\n\nfunction detachSharedMarkers(markers) {\n  var loop = function ( i ) {\n    var marker = markers[i], linked = [marker.primary.doc];\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n    for (var j = 0; j < marker.markers.length; j++) {\n      var subMarker = marker.markers[j];\n      if (indexOf(linked, subMarker.doc) == -1) {\n        subMarker.parent = null;\n        marker.markers.splice(j--, 1);\n      }\n    }\n  };\n\n  for (var i = 0; i < markers.length; i++) loop( i );\n}\n\nvar nextDocId = 0;\nvar Doc = function(text, mode, firstLine, lineSep, direction) {\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n  if (firstLine == null) { firstLine = 0; }\n\n  BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n  this.first = firstLine;\n  this.scrollTop = this.scrollLeft = 0;\n  this.cantEdit = false;\n  this.cleanGeneration = 1;\n  this.frontier = firstLine;\n  var start = Pos(firstLine, 0);\n  this.sel = simpleSelection(start);\n  this.history = new History(null);\n  this.id = ++nextDocId;\n  this.modeOption = mode;\n  this.lineSep = lineSep;\n  this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n  this.extend = false;\n\n  if (typeof text == \"string\") { text = this.splitLines(text); }\n  updateDoc(this, {from: start, to: start, text: text});\n  setSelection(this, simpleSelection(start), sel_dontScroll);\n};\n\nDoc.prototype = createObj(BranchChunk.prototype, {\n  constructor: Doc,\n  // Iterate over the document. Supports two forms -- with only one\n  // argument, it calls that for each line in the document. With\n  // three, it iterates over the range given by the first two (with\n  // the second being non-inclusive).\n  iter: function(from, to, op) {\n    if (op) { this.iterN(from - this.first, to - from, op); }\n    else { this.iterN(this.first, this.first + this.size, from); }\n  },\n\n  // Non-public interface for adding and removing lines.\n  insert: function(at, lines) {\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n    this.insertInner(at - this.first, lines, height);\n  },\n  remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n  // From here, the methods are part of the public interface. Most\n  // are also available from CodeMirror (editor) instances.\n\n  getValue: function(lineSep) {\n    var lines = getLines(this, this.first, this.first + this.size);\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n  setValue: docMethodOp(function(code) {\n    var top = Pos(this.first, 0), last = this.first + this.size - 1;\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                      text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n    if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n    setSelection(this, simpleSelection(top), sel_dontScroll);\n  }),\n  replaceRange: function(code, from, to, origin) {\n    from = clipPos(this, from);\n    to = to ? clipPos(this, to) : from;\n    replaceRange(this, code, from, to, origin);\n  },\n  getRange: function(from, to, lineSep) {\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n    if (lineSep === false) { return lines }\n    return lines.join(lineSep || this.lineSeparator())\n  },\n\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n  getLineNumber: function(line) {return lineNo(line)},\n\n  getLineHandleVisualStart: function(line) {\n    if (typeof line == \"number\") { line = getLine(this, line); }\n    return visualLine(line)\n  },\n\n  lineCount: function() {return this.size},\n  firstLine: function() {return this.first},\n  lastLine: function() {return this.first + this.size - 1},\n\n  clipPos: function(pos) {return clipPos(this, pos)},\n\n  getCursor: function(start) {\n    var range$$1 = this.sel.primary(), pos;\n    if (start == null || start == \"head\") { pos = range$$1.head; }\n    else if (start == \"anchor\") { pos = range$$1.anchor; }\n    else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n    else { pos = range$$1.from(); }\n    return pos\n  },\n  listSelections: function() { return this.sel.ranges },\n  somethingSelected: function() {return this.sel.somethingSelected()},\n\n  setCursor: docMethodOp(function(line, ch, options) {\n    setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n  }),\n  setSelection: docMethodOp(function(anchor, head, options) {\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n  }),\n  extendSelection: docMethodOp(function(head, other, options) {\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n  }),\n  extendSelections: docMethodOp(function(heads, options) {\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  extendSelectionsBy: docMethodOp(function(f, options) {\n    var heads = map(this.sel.ranges, f);\n    extendSelections(this, clipPosArray(this, heads), options);\n  }),\n  setSelections: docMethodOp(function(ranges, primary, options) {\n    var this$1 = this;\n\n    if (!ranges.length) { return }\n    var out = [];\n    for (var i = 0; i < ranges.length; i++)\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                         clipPos(this$1, ranges[i].head)); }\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n    setSelection(this, normalizeSelection(out, primary), options);\n  }),\n  addSelection: docMethodOp(function(anchor, head, options) {\n    var ranges = this.sel.ranges.slice(0);\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n  }),\n\n  getSelection: function(lineSep) {\n    var this$1 = this;\n\n    var ranges = this.sel.ranges, lines;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      lines = lines ? lines.concat(sel) : sel;\n    }\n    if (lineSep === false) { return lines }\n    else { return lines.join(lineSep || this.lineSeparator()) }\n  },\n  getSelections: function(lineSep) {\n    var this$1 = this;\n\n    var parts = [], ranges = this.sel.ranges;\n    for (var i = 0; i < ranges.length; i++) {\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n      parts[i] = sel;\n    }\n    return parts\n  },\n  replaceSelection: function(code, collapse, origin) {\n    var dup = [];\n    for (var i = 0; i < this.sel.ranges.length; i++)\n      { dup[i] = code; }\n    this.replaceSelections(dup, collapse, origin || \"+input\");\n  },\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\n    var this$1 = this;\n\n    var changes = [], sel = this.sel;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range$$1 = sel.ranges[i];\n      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n    }\n    var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n      { makeChange(this$1, changes[i$1]); }\n    if (newSel) { setSelectionReplaceHistory(this, newSel); }\n    else if (this.cm) { ensureCursorVisible(this.cm); }\n  }),\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n  setExtending: function(val) {this.extend = val;},\n  getExtending: function() {return this.extend},\n\n  historySize: function() {\n    var hist = this.history, done = 0, undone = 0;\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n    return {undo: done, redo: undone}\n  },\n  clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n  markClean: function() {\n    this.cleanGeneration = this.changeGeneration(true);\n  },\n  changeGeneration: function(forceSplit) {\n    if (forceSplit)\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n    return this.history.generation\n  },\n  isClean: function (gen) {\n    return this.history.generation == (gen || this.cleanGeneration)\n  },\n\n  getHistory: function() {\n    return {done: copyHistoryArray(this.history.done),\n            undone: copyHistoryArray(this.history.undone)}\n  },\n  setHistory: function(histData) {\n    var hist = this.history = new History(this.history.maxGeneration);\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n  },\n\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\n    return changeLine(this, line, \"gutter\", function (line) {\n      var markers = line.gutterMarkers || (line.gutterMarkers = {});\n      markers[gutterID] = value;\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n      return true\n    })\n  }),\n\n  clearGutter: docMethodOp(function(gutterID) {\n    var this$1 = this;\n\n    this.iter(function (line) {\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n        changeLine(this$1, line, \"gutter\", function () {\n          line.gutterMarkers[gutterID] = null;\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n          return true\n        });\n      }\n    });\n  }),\n\n  lineInfo: function(line) {\n    var n;\n    if (typeof line == \"number\") {\n      if (!isLine(this, line)) { return null }\n      n = line;\n      line = getLine(this, line);\n      if (!line) { return null }\n    } else {\n      n = lineNo(line);\n      if (n == null) { return null }\n    }\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n            widgets: line.widgets}\n  },\n\n  addLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      if (!line[prop]) { line[prop] = cls; }\n      else if (classTest(cls).test(line[prop])) { return false }\n      else { line[prop] += \" \" + cls; }\n      return true\n    })\n  }),\n  removeLineClass: docMethodOp(function(handle, where, cls) {\n    return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n      var prop = where == \"text\" ? \"textClass\"\n               : where == \"background\" ? \"bgClass\"\n               : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n      var cur = line[prop];\n      if (!cur) { return false }\n      else if (cls == null) { line[prop] = null; }\n      else {\n        var found = cur.match(classTest(cls));\n        if (!found) { return false }\n        var end = found.index + found[0].length;\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n      }\n      return true\n    })\n  }),\n\n  addLineWidget: docMethodOp(function(handle, node, options) {\n    return addLineWidget(this, handle, node, options)\n  }),\n  removeLineWidget: function(widget) { widget.clear(); },\n\n  markText: function(from, to, options) {\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n  },\n  setBookmark: function(pos, options) {\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                    insertLeft: options && options.insertLeft,\n                    clearWhenEmpty: false, shared: options && options.shared,\n                    handleMouseEvents: options && options.handleMouseEvents};\n    pos = clipPos(this, pos);\n    return markText(this, pos, pos, realOpts, \"bookmark\")\n  },\n  findMarksAt: function(pos) {\n    pos = clipPos(this, pos);\n    var markers = [], spans = getLine(this, pos.line).markedSpans;\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if ((span.from == null || span.from <= pos.ch) &&\n          (span.to == null || span.to >= pos.ch))\n        { markers.push(span.marker.parent || span.marker); }\n    } }\n    return markers\n  },\n  findMarks: function(from, to, filter) {\n    from = clipPos(this, from); to = clipPos(this, to);\n    var found = [], lineNo$$1 = from.line;\n    this.iter(from.line, to.line + 1, function (line) {\n      var spans = line.markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; i++) {\n        var span = spans[i];\n        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\n              span.from == null && lineNo$$1 != from.line ||\n              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\n            (!filter || filter(span.marker)))\n          { found.push(span.marker.parent || span.marker); }\n      } }\n      ++lineNo$$1;\n    });\n    return found\n  },\n  getAllMarks: function() {\n    var markers = [];\n    this.iter(function (line) {\n      var sps = line.markedSpans;\n      if (sps) { for (var i = 0; i < sps.length; ++i)\n        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n    });\n    return markers\n  },\n\n  posFromIndex: function(off) {\n    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n    this.iter(function (line) {\n      var sz = line.text.length + sepSize;\n      if (sz > off) { ch = off; return true }\n      off -= sz;\n      ++lineNo$$1;\n    });\n    return clipPos(this, Pos(lineNo$$1, ch))\n  },\n  indexFromPos: function (coords) {\n    coords = clipPos(this, coords);\n    var index = coords.ch;\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\n    var sepSize = this.lineSeparator().length;\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n      index += line.text.length + sepSize;\n    });\n    return index\n  },\n\n  copy: function(copyHistory) {\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                      this.modeOption, this.first, this.lineSep, this.direction);\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n    doc.sel = this.sel;\n    doc.extend = false;\n    if (copyHistory) {\n      doc.history.undoDepth = this.history.undoDepth;\n      doc.setHistory(this.getHistory());\n    }\n    return doc\n  },\n\n  linkedDoc: function(options) {\n    if (!options) { options = {}; }\n    var from = this.first, to = this.first + this.size;\n    if (options.from != null && options.from > from) { from = options.from; }\n    if (options.to != null && options.to < to) { to = options.to; }\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n    if (options.sharedHist) { copy.history = this.history\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n    copySharedMarkers(copy, findSharedMarkers(this));\n    return copy\n  },\n  unlinkDoc: function(other) {\n    var this$1 = this;\n\n    if (other instanceof CodeMirror$1) { other = other.doc; }\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n      var link = this$1.linked[i];\n      if (link.doc != other) { continue }\n      this$1.linked.splice(i, 1);\n      other.unlinkDoc(this$1);\n      detachSharedMarkers(findSharedMarkers(this$1));\n      break\n    } }\n    // If the histories were shared, split them again\n    if (other.history == this.history) {\n      var splitIds = [other.id];\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n      other.history = new History(null);\n      other.history.done = copyHistoryArray(this.history.done, splitIds);\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n    }\n  },\n  iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n  getMode: function() {return this.mode},\n  getEditor: function() {return this.cm},\n\n  splitLines: function(str) {\n    if (this.lineSep) { return str.split(this.lineSep) }\n    return splitLinesAuto(str)\n  },\n  lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n  setDirection: docMethodOp(function (dir) {\n    if (dir != \"rtl\") { dir = \"ltr\"; }\n    if (dir == this.direction) { return }\n    this.direction = dir;\n    this.iter(function (line) { return line.order = null; });\n    if (this.cm) { directionChanged(this.cm); }\n  })\n});\n\n// Public alias.\nDoc.prototype.eachLine = Doc.prototype.iter;\n\n// Kludge to work around strange IE behavior where it'll sometimes\n// re-fire a series of drag-related events right after the drop (#1551)\nvar lastDrop = 0;\n\nfunction onDrop(e) {\n  var cm = this;\n  clearDragCursor(cm);\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n    { return }\n  e_preventDefault(e);\n  if (ie) { lastDrop = +new Date; }\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n  if (!pos || cm.isReadOnly()) { return }\n  // Might be a file drop, in which case we simply extract the text\n  // and insert it.\n  if (files && files.length && window.FileReader && window.File) {\n    var n = files.length, text = Array(n), read = 0;\n    var loadFile = function (file, i) {\n      if (cm.options.allowDropFileTypes &&\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n        { return }\n\n      var reader = new FileReader;\n      reader.onload = operation(cm, function () {\n        var content = reader.result;\n        if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n        text[i] = content;\n        if (++read == n) {\n          pos = clipPos(cm.doc, pos);\n          var change = {from: pos, to: pos,\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                        origin: \"paste\"};\n          makeChange(cm.doc, change);\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n        }\n      });\n      reader.readAsText(file);\n    };\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\n  } else { // Normal drop\n    // Don't do a replace if the drop happened inside of the selected text.\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n      cm.state.draggingText(e);\n      // Ensure the editor is re-focused\n      setTimeout(function () { return cm.display.input.focus(); }, 20);\n      return\n    }\n    try {\n      var text$1 = e.dataTransfer.getData(\"Text\");\n      if (text$1) {\n        var selected;\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\n          { selected = cm.listSelections(); }\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n          { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n        cm.replaceSelection(text$1, \"around\", \"paste\");\n        cm.display.input.focus();\n      }\n    }\n    catch(e){}\n  }\n}\n\nfunction onDragStart(cm, e) {\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n  e.dataTransfer.setData(\"Text\", cm.getSelection());\n  e.dataTransfer.effectAllowed = \"copyMove\";\n\n  // Use dummy image instead of default browsers image.\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n  if (e.dataTransfer.setDragImage && !safari) {\n    var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n    img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    if (presto) {\n      img.width = img.height = 1;\n      cm.display.wrapper.appendChild(img);\n      // Force a relayout, or Opera won't use our image for some obscure reason\n      img._top = img.offsetTop;\n    }\n    e.dataTransfer.setDragImage(img, 0, 0);\n    if (presto) { img.parentNode.removeChild(img); }\n  }\n}\n\nfunction onDragOver(cm, e) {\n  var pos = posFromMouse(cm, e);\n  if (!pos) { return }\n  var frag = document.createDocumentFragment();\n  drawSelectionCursor(cm, pos, frag);\n  if (!cm.display.dragCursor) {\n    cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n  }\n  removeChildrenAndAdd(cm.display.dragCursor, frag);\n}\n\nfunction clearDragCursor(cm) {\n  if (cm.display.dragCursor) {\n    cm.display.lineSpace.removeChild(cm.display.dragCursor);\n    cm.display.dragCursor = null;\n  }\n}\n\n// These must be handled carefully, because naively registering a\n// handler for each editor will cause the editors to never be\n// garbage collected.\n\nfunction forEachCodeMirror(f) {\n  if (!document.body.getElementsByClassName) { return }\n  var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n  for (var i = 0; i < byClass.length; i++) {\n    var cm = byClass[i].CodeMirror;\n    if (cm) { f(cm); }\n  }\n}\n\nvar globalsRegistered = false;\nfunction ensureGlobalHandlers() {\n  if (globalsRegistered) { return }\n  registerGlobalHandlers();\n  globalsRegistered = true;\n}\nfunction registerGlobalHandlers() {\n  // When the window resizes, we need to refresh active editors.\n  var resizeTimer;\n  on(window, \"resize\", function () {\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n      resizeTimer = null;\n      forEachCodeMirror(onResize);\n    }, 100); }\n  });\n  // When the window loses focus, we want to show the editor as blurred\n  on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n}\n// Called when the window resizes\nfunction onResize(cm) {\n  var d = cm.display;\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n    { return }\n  // Might be a text scaling operation, clear size caches.\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n  d.scrollbarsClipped = false;\n  cm.setSize();\n}\n\nvar keyNames = {\n  3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n  106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n};\n\n// Number keys\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n// Alphabetic keys\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n// Function keys\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\nvar keyMap = {};\n\nkeyMap.basic = {\n  \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n  \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n  \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n  \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n  \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n  \"Esc\": \"singleSelection\"\n};\n// Note that the save and find-related commands aren't defined by\n// default. User code or addons can define them. Unknown commands\n// are simply ignored.\nkeyMap.pcDefault = {\n  \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n  \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n  \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n  \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n  \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n  \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n  \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n  fallthrough: \"basic\"\n};\n// Very basic readline/emacs-style bindings, which are standard on Mac.\nkeyMap.emacsy = {\n  \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n  \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n  \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n  \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n  \"Ctrl-O\": \"openLine\"\n};\nkeyMap.macDefault = {\n  \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n  \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n  \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n  \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n  \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n  \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n  \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n  fallthrough: [\"basic\", \"emacsy\"]\n};\nkeyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n// KEYMAP DISPATCH\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/);\n  name = parts[parts.length - 1];\n  var alt, ctrl, shift, cmd;\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n    else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n  }\n  if (alt) { name = \"Alt-\" + name; }\n  if (ctrl) { name = \"Ctrl-\" + name; }\n  if (cmd) { name = \"Cmd-\" + name; }\n  if (shift) { name = \"Shift-\" + name; }\n  return name\n}\n\n// This is a kludge to keep keymaps mostly working as raw objects\n// (backwards compatibility) while at the same time support features\n// like normalization and multi-stroke key bindings. It compiles a\n// new normalized keymap, and then updates the old object to reflect\n// this.\nfunction normalizeKeyMap(keymap) {\n  var copy = {};\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n    var value = keymap[keyname];\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n    if (value == \"...\") { delete keymap[keyname]; continue }\n\n    var keys = map(keyname.split(\" \"), normalizeKeyName);\n    for (var i = 0; i < keys.length; i++) {\n      var val = (void 0), name = (void 0);\n      if (i == keys.length - 1) {\n        name = keys.join(\" \");\n        val = value;\n      } else {\n        name = keys.slice(0, i + 1).join(\" \");\n        val = \"...\";\n      }\n      var prev = copy[name];\n      if (!prev) { copy[name] = val; }\n      else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n    }\n    delete keymap[keyname];\n  } }\n  for (var prop in copy) { keymap[prop] = copy[prop]; }\n  return keymap\n}\n\nfunction lookupKey(key, map$$1, handle, context) {\n  map$$1 = getKeyMap(map$$1);\n  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n  if (found === false) { return \"nothing\" }\n  if (found === \"...\") { return \"multi\" }\n  if (found != null && handle(found)) { return \"handled\" }\n\n  if (map$$1.fallthrough) {\n    if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n      { return lookupKey(key, map$$1.fallthrough, handle, context) }\n    for (var i = 0; i < map$$1.fallthrough.length; i++) {\n      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n      if (result) { return result }\n    }\n  }\n}\n\n// Modifier key presses don't count as 'real' key presses for the\n// purpose of keymap fallthrough.\nfunction isModifierKey(value) {\n  var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n  return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n}\n\n// Look up the name of a key as indicated by an event object.\nfunction keyName(event, noShift) {\n  if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n  var base = keyNames[event.keyCode], name = base;\n  if (name == null || event.altGraphKey) { return false }\n  if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\n  if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n  return name\n}\n\nfunction getKeyMap(val) {\n  return typeof val == \"string\" ? keyMap[val] : val\n}\n\n// Helper for deleting text near the selection(s), used to implement\n// backspace, delete, and similar functionality.\nfunction deleteNearSelection(cm, compute) {\n  var ranges = cm.doc.sel.ranges, kill = [];\n  // Build up a set of ranges to kill first, merging overlapping\n  // ranges.\n  for (var i = 0; i < ranges.length; i++) {\n    var toKill = compute(ranges[i]);\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n      var replaced = kill.pop();\n      if (cmp(replaced.from, toKill.from) < 0) {\n        toKill.from = replaced.from;\n        break\n      }\n    }\n    kill.push(toKill);\n  }\n  // Next, remove those actual ranges.\n  runInOp(cm, function () {\n    for (var i = kill.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n    ensureCursorVisible(cm);\n  });\n}\n\n// Commands are parameter-less actions that can be performed on an\n// editor, mostly used for keybindings.\nvar commands = {\n  selectAll: selectAll,\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n    if (range.empty()) {\n      var len = getLine(cm.doc, range.head.line).text.length;\n      if (range.head.ch == len && range.head.line < cm.lastLine())\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n      else\n        { return {from: range.head, to: Pos(range.head.line, len)} }\n    } else {\n      return {from: range.from(), to: range.to()}\n    }\n  }); },\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0),\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n  }); }); },\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n    from: Pos(range.from().line, 0), to: range.from()\n  }); }); },\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n    return {from: leftPos, to: range.from()}\n  }); },\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n    return {from: range.from(), to: rightPos }\n  }); },\n  undo: function (cm) { return cm.undo(); },\n  redo: function (cm) { return cm.redo(); },\n  undoSelection: function (cm) { return cm.undoSelection(); },\n  redoSelection: function (cm) { return cm.redoSelection(); },\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n    {origin: \"+move\", bias: 1}\n  ); },\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n    {origin: \"+move\", bias: -1}\n  ); },\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    return cm.coordsChar({left: 0, top: top}, \"div\")\n  }, sel_move); },\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n    var top = cm.charCoords(range.head, \"div\").top + 5;\n    var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n    if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n    return pos\n  }, sel_move); },\n  goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n  goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n  goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n  goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n  goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n  goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n  goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n  goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n  goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n  goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n  goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n  goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n  delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n  delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n  delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n  delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n  delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n  indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n  indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n  indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n  insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n  insertSoftTab: function (cm) {\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n    for (var i = 0; i < ranges.length; i++) {\n      var pos = ranges[i].from();\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n      spaces.push(spaceStr(tabSize - col % tabSize));\n    }\n    cm.replaceSelections(spaces);\n  },\n  defaultTab: function (cm) {\n    if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n    else { cm.execCommand(\"insertTab\"); }\n  },\n  // Swap the two chars left and right of each selection's head.\n  // Move cursor behind the two swapped characters afterwards.\n  //\n  // Doesn't consider line feeds a character.\n  // Doesn't scan more than one line above to find a character.\n  // Doesn't do anything on an empty line.\n  // Doesn't do anything with non-empty selections.\n  transposeChars: function (cm) { return runInOp(cm, function () {\n    var ranges = cm.listSelections(), newSel = [];\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) { continue }\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n      if (line) {\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n        if (cur.ch > 0) {\n          cur = new Pos(cur.line, cur.ch + 1);\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                          Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n        } else if (cur.line > cm.doc.first) {\n          var prev = getLine(cm.doc, cur.line - 1).text;\n          if (prev) {\n            cur = new Pos(cur.line, 1);\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                            prev.charAt(prev.length - 1),\n                            Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n          }\n        }\n      }\n      newSel.push(new Range(cur, cur));\n    }\n    cm.setSelections(newSel);\n  }); },\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\n    var sels = cm.listSelections();\n    for (var i = sels.length - 1; i >= 0; i--)\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n    sels = cm.listSelections();\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\n      { cm.indentLine(sels[i$1].from().line, null, true); }\n    ensureCursorVisible(cm);\n  }); },\n  openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n};\n\n\nfunction lineStart(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLine(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, visual, lineN, 1)\n}\nfunction lineEnd(cm, lineN) {\n  var line = getLine(cm.doc, lineN);\n  var visual = visualLineEnd(line);\n  if (visual != line) { lineN = lineNo(visual); }\n  return endOfLine(true, cm, line, lineN, -1)\n}\nfunction lineStartSmart(cm, pos) {\n  var start = lineStart(cm, pos.line);\n  var line = getLine(cm.doc, start.line);\n  var order = getOrder(line, cm.doc.direction);\n  if (!order || order[0].level == 0) {\n    var firstNonWS = Math.max(0, line.text.search(/\\S/));\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n  }\n  return start\n}\n\n// Run a handler that was bound to a key.\nfunction doHandleBinding(cm, bound, dropShift) {\n  if (typeof bound == \"string\") {\n    bound = commands[bound];\n    if (!bound) { return false }\n  }\n  // Ensure previous input has been read, so that the handler sees a\n  // consistent view of the document\n  cm.display.input.ensurePolled();\n  var prevShift = cm.display.shift, done = false;\n  try {\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n    if (dropShift) { cm.display.shift = false; }\n    done = bound(cm) != Pass;\n  } finally {\n    cm.display.shift = prevShift;\n    cm.state.suppressEdits = false;\n  }\n  return done\n}\n\nfunction lookupKeyForEditor(cm, name, handle) {\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n    if (result) { return result }\n  }\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n    || lookupKey(name, cm.options.keyMap, handle, cm)\n}\n\nvar stopSeq = new Delayed;\nfunction dispatchKey(cm, name, e, handle) {\n  var seq = cm.state.keySeq;\n  if (seq) {\n    if (isModifierKey(name)) { return \"handled\" }\n    stopSeq.set(50, function () {\n      if (cm.state.keySeq == seq) {\n        cm.state.keySeq = null;\n        cm.display.input.reset();\n      }\n    });\n    name = seq + \" \" + name;\n  }\n  var result = lookupKeyForEditor(cm, name, handle);\n\n  if (result == \"multi\")\n    { cm.state.keySeq = name; }\n  if (result == \"handled\")\n    { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n  if (result == \"handled\" || result == \"multi\") {\n    e_preventDefault(e);\n    restartBlink(cm);\n  }\n\n  if (seq && !result && /\\'$/.test(name)) {\n    e_preventDefault(e);\n    return true\n  }\n  return !!result\n}\n\n// Handle a key from the keydown event.\nfunction handleKeyBinding(cm, e) {\n  var name = keyName(e, true);\n  if (!name) { return false }\n\n  if (e.shiftKey && !cm.state.keySeq) {\n    // First try to resolve full name (including 'Shift-'). Failing\n    // that, see if there is a cursor-motion command (starting with\n    // 'go') bound to the keyname without 'Shift-'.\n    return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n        || dispatchKey(cm, name, e, function (b) {\n             if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n               { return doHandleBinding(cm, b) }\n           })\n  } else {\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n  }\n}\n\n// Handle a key from the keypress event\nfunction handleCharBinding(cm, e, ch) {\n  return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n}\n\nvar lastStoppedKey = null;\nfunction onKeyDown(e) {\n  var cm = this;\n  cm.curOp.focus = activeElt();\n  if (signalDOMEvent(cm, e)) { return }\n  // IE does strange things with escape.\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n  var code = e.keyCode;\n  cm.display.shift = code == 16 || e.shiftKey;\n  var handled = handleKeyBinding(cm, e);\n  if (presto) {\n    lastStoppedKey = handled ? code : null;\n    // Opera has no cut event... we try to at least catch the key combo\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n      { cm.replaceSelection(\"\", null, \"cut\"); }\n  }\n\n  // Turn mouse into crosshair when Alt is held on Mac.\n  if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n    { showCrossHair(cm); }\n}\n\nfunction showCrossHair(cm) {\n  var lineDiv = cm.display.lineDiv;\n  addClass(lineDiv, \"CodeMirror-crosshair\");\n\n  function up(e) {\n    if (e.keyCode == 18 || !e.altKey) {\n      rmClass(lineDiv, \"CodeMirror-crosshair\");\n      off(document, \"keyup\", up);\n      off(document, \"mouseover\", up);\n    }\n  }\n  on(document, \"keyup\", up);\n  on(document, \"mouseover\", up);\n}\n\nfunction onKeyUp(e) {\n  if (e.keyCode == 16) { this.doc.sel.shift = false; }\n  signalDOMEvent(this, e);\n}\n\nfunction onKeyPress(e) {\n  var cm = this;\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n  var keyCode = e.keyCode, charCode = e.charCode;\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n  // Some browsers fire keypress events for backspace\n  if (ch == \"\\x08\") { return }\n  if (handleCharBinding(cm, e, ch)) { return }\n  cm.display.input.onKeyPress(e);\n}\n\n// A mouse down can be a single click, double click, triple click,\n// start of selection drag, start of text drag, new cursor\n// (ctrl-click), rectangle drag (alt-drag), or xwin\n// middle-click-paste. Or it might be a click on something we should\n// not interfere with, such as a scrollbar or widget.\nfunction onMouseDown(e) {\n  var cm = this, display = cm.display;\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n  display.input.ensurePolled();\n  display.shift = e.shiftKey;\n\n  if (eventInWidget(display, e)) {\n    if (!webkit) {\n      // Briefly turn off draggability, to allow widgets to do\n      // normal dragging things.\n      display.scroller.draggable = false;\n      setTimeout(function () { return display.scroller.draggable = true; }, 100);\n    }\n    return\n  }\n  if (clickInGutter(cm, e)) { return }\n  var start = posFromMouse(cm, e);\n  window.focus();\n\n  switch (e_button(e)) {\n  case 1:\n    // #3261: make sure, that we're not starting a second selection\n    if (cm.state.selectingText)\n      { cm.state.selectingText(e); }\n    else if (start)\n      { leftButtonDown(cm, e, start); }\n    else if (e_target(e) == display.scroller)\n      { e_preventDefault(e); }\n    break\n  case 2:\n    if (webkit) { cm.state.lastMiddleDown = +new Date; }\n    if (start) { extendSelection(cm.doc, start); }\n    setTimeout(function () { return display.input.focus(); }, 20);\n    e_preventDefault(e);\n    break\n  case 3:\n    if (captureRightClick) { onContextMenu(cm, e); }\n    else { delayBlurEvent(cm); }\n    break\n  }\n}\n\nvar lastClick;\nvar lastDoubleClick;\nfunction leftButtonDown(cm, e, start) {\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n  else { cm.curOp.focus = activeElt(); }\n\n  var now = +new Date, type;\n  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n    type = \"triple\";\n  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n    type = \"double\";\n    lastDoubleClick = {time: now, pos: start};\n  } else {\n    type = \"single\";\n    lastClick = {time: now, pos: start};\n  }\n\n  var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n      type == \"single\" && (contained = sel.contains(start)) > -1 &&\n      (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n      (cmp(contained.to(), start) > 0 || start.xRel < 0))\n    { leftButtonStartDrag(cm, e, start, modifier); }\n  else\n    { leftButtonSelect(cm, e, start, type, modifier); }\n}\n\n// Start a text drag. When it ends, see if any dragging actually\n// happen, and treat as a click if it didn't.\nfunction leftButtonStartDrag(cm, e, start, modifier) {\n  var display = cm.display, moved = false;\n  var dragEnd = operation(cm, function (e) {\n    if (webkit) { display.scroller.draggable = false; }\n    cm.state.draggingText = false;\n    off(document, \"mouseup\", dragEnd);\n    off(document, \"mousemove\", mouseMove);\n    off(display.scroller, \"dragstart\", dragStart);\n    off(display.scroller, \"drop\", dragEnd);\n    if (!moved) {\n      e_preventDefault(e);\n      if (!modifier)\n        { extendSelection(cm.doc, start); }\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n      if (webkit || ie && ie_version == 9)\n        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }\n      else\n        { display.input.focus(); }\n    }\n  });\n  var mouseMove = function(e2) {\n    moved = moved || Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) >= 10;\n  };\n  var dragStart = function () { return moved = true; };\n  // Let the drag handler handle this.\n  if (webkit) { display.scroller.draggable = true; }\n  cm.state.draggingText = dragEnd;\n  dragEnd.copy = mac ? e.altKey : e.ctrlKey;\n  // IE's approach to draggable\n  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  on(document, \"mouseup\", dragEnd);\n  on(document, \"mousemove\", mouseMove);\n  on(display.scroller, \"dragstart\", dragStart);\n  on(display.scroller, \"drop\", dragEnd);\n\n  delayBlurEvent(cm);\n  setTimeout(function () { return display.input.focus(); }, 20);\n}\n\n// Normal selection, as opposed to text dragging.\nfunction leftButtonSelect(cm, e, start, type, addNew) {\n  var display = cm.display, doc = cm.doc;\n  e_preventDefault(e);\n\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n  if (addNew && !e.shiftKey) {\n    ourIndex = doc.sel.contains(start);\n    if (ourIndex > -1)\n      { ourRange = ranges[ourIndex]; }\n    else\n      { ourRange = new Range(start, start); }\n  } else {\n    ourRange = doc.sel.primary();\n    ourIndex = doc.sel.primIndex;\n  }\n\n  if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\n    type = \"rect\";\n    if (!addNew) { ourRange = new Range(start, start); }\n    start = posFromMouse(cm, e, true, true);\n    ourIndex = -1;\n  } else if (type == \"double\") {\n    var word = cm.findWordAt(start);\n    if (cm.display.shift || doc.extend)\n      { ourRange = extendRange(doc, ourRange, word.anchor, word.head); }\n    else\n      { ourRange = word; }\n  } else if (type == \"triple\") {\n    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n    if (cm.display.shift || doc.extend)\n      { ourRange = extendRange(doc, ourRange, line.anchor, line.head); }\n    else\n      { ourRange = line; }\n  } else {\n    ourRange = extendRange(doc, ourRange, start);\n  }\n\n  if (!addNew) {\n    ourIndex = 0;\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n    startSel = doc.sel;\n  } else if (ourIndex == -1) {\n    ourIndex = ranges.length;\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                 {scroll: false, origin: \"*mouse\"});\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                 {scroll: false, origin: \"*mouse\"});\n    startSel = doc.sel;\n  } else {\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n  }\n\n  var lastPos = start;\n  function extendTo(pos) {\n    if (cmp(lastPos, pos) == 0) { return }\n    lastPos = pos;\n\n    if (type == \"rect\") {\n      var ranges = [], tabSize = cm.options.tabSize;\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n           line <= end; line++) {\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n        if (left == right)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n        else if (text.length > leftPos)\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n      }\n      if (!ranges.length) { ranges.push(new Range(start, start)); }\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                   {origin: \"*mouse\", scroll: false});\n      cm.scrollIntoView(pos);\n    } else {\n      var oldRange = ourRange;\n      var anchor = oldRange.anchor, head = pos;\n      if (type != \"single\") {\n        var range$$1;\n        if (type == \"double\")\n          { range$$1 = cm.findWordAt(pos); }\n        else\n          { range$$1 = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))); }\n        if (cmp(range$$1.anchor, anchor) > 0) {\n          head = range$$1.head;\n          anchor = minPos(oldRange.from(), range$$1.anchor);\n        } else {\n          head = range$$1.anchor;\n          anchor = maxPos(oldRange.to(), range$$1.head);\n        }\n      }\n      var ranges$1 = startSel.ranges.slice(0);\n      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head);\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);\n    }\n  }\n\n  var editorSize = display.wrapper.getBoundingClientRect();\n  // Used to ensure timeout re-tries don't fire when another extend\n  // happened in the meantime (clearTimeout isn't reliable -- at\n  // least on Chrome, the timeouts still happen even when cleared,\n  // if the clear happens after their scheduled firing time).\n  var counter = 0;\n\n  function extend(e) {\n    var curCount = ++counter;\n    var cur = posFromMouse(cm, e, true, type == \"rect\");\n    if (!cur) { return }\n    if (cmp(cur, lastPos) != 0) {\n      cm.curOp.focus = activeElt();\n      extendTo(cur);\n      var visible = visibleLines(display, doc);\n      if (cur.line >= visible.to || cur.line < visible.from)\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n    } else {\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n      if (outside) { setTimeout(operation(cm, function () {\n        if (counter != curCount) { return }\n        display.scroller.scrollTop += outside;\n        extend(e);\n      }), 50); }\n    }\n  }\n\n  function done(e) {\n    cm.state.selectingText = false;\n    counter = Infinity;\n    e_preventDefault(e);\n    display.input.focus();\n    off(document, \"mousemove\", move);\n    off(document, \"mouseup\", up);\n    doc.history.lastSelOrigin = null;\n  }\n\n  var move = operation(cm, function (e) {\n    if (!e_button(e)) { done(e); }\n    else { extend(e); }\n  });\n  var up = operation(cm, done);\n  cm.state.selectingText = up;\n  on(document, \"mousemove\", move);\n  on(document, \"mouseup\", up);\n}\n\n\n// Determines whether an event happened in the gutter, and fires the\n// handlers for the corresponding event.\nfunction gutterEvent(cm, e, type, prevent) {\n  var mX, mY;\n  try { mX = e.clientX; mY = e.clientY; }\n  catch(e) { return false }\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n  if (prevent) { e_preventDefault(e); }\n\n  var display = cm.display;\n  var lineBox = display.lineDiv.getBoundingClientRect();\n\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n  mY -= lineBox.top - display.viewOffset;\n\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\n    var g = display.gutters.childNodes[i];\n    if (g && g.getBoundingClientRect().right >= mX) {\n      var line = lineAtHeight(cm.doc, mY);\n      var gutter = cm.options.gutters[i];\n      signal(cm, type, cm, line, gutter, e);\n      return e_defaultPrevented(e)\n    }\n  }\n}\n\nfunction clickInGutter(cm, e) {\n  return gutterEvent(cm, e, \"gutterClick\", true)\n}\n\n// CONTEXT MENU HANDLING\n\n// To make the context menu work, we need to briefly unhide the\n// textarea (making it as unobtrusive as possible) to let the\n// right-click take effect on it.\nfunction onContextMenu(cm, e) {\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n  if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n  cm.display.input.onContextMenu(e);\n}\n\nfunction contextMenuInGutter(cm, e) {\n  if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n  return gutterEvent(cm, e, \"gutterContextMenu\", false)\n}\n\nfunction themeChanged(cm) {\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n    cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n  clearCaches(cm);\n}\n\nvar Init = {toString: function(){return \"CodeMirror.Init\"}};\n\nvar defaults = {};\nvar optionHandlers = {};\n\nfunction defineOptions(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) { optionHandlers[name] =\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n  }\n\n  CodeMirror.defineOption = option;\n\n  // Passed to option handlers when there is no old value.\n  CodeMirror.Init = Init;\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n  option(\"mode\", null, function (cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function (cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function (cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) { return }\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function (line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) { break }\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n  });\n  option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != Init) { cm.refresh(); }\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n  }, true);\n  option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function (cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function (cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != Init && getKeyMap(old);\n    if (prev && prev.detach) { prev.detach(cm, next); }\n    if (next.attach) { next.attach(cm, prev || null); }\n  });\n  option(\"extraKeys\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function (cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n  option(\"scrollbarStyle\", \"native\", function (cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function (cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n\n  option(\"readOnly\", false, function (cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n    }\n    cm.display.input.readOnlyChanged(val);\n  });\n  option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function (cm, val) {\n    if (!val) { cm.display.input.resetPosition(); }\n  });\n\n  option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n  option(\"autofocus\", null);\n  option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n}\n\nfunction guttersChanged(cm) {\n  updateGutters(cm);\n  regChange(cm);\n  alignHorizontally(cm);\n}\n\nfunction dragDropChanged(cm, value, old) {\n  var wasOn = old && old != Init;\n  if (!value != !wasOn) {\n    var funcs = cm.display.dragFunctions;\n    var toggle = value ? on : off;\n    toggle(cm.display.scroller, \"dragstart\", funcs.start);\n    toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n    toggle(cm.display.scroller, \"dragover\", funcs.over);\n    toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n    toggle(cm.display.scroller, \"drop\", funcs.drop);\n  }\n}\n\nfunction wrappingChanged(cm) {\n  if (cm.options.lineWrapping) {\n    addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    cm.display.sizer.style.minWidth = \"\";\n    cm.display.sizerWidth = null;\n  } else {\n    rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n    findMaxLine(cm);\n  }\n  estimateLineHeights(cm);\n  regChange(cm);\n  clearCaches(cm);\n  setTimeout(function () { return updateScrollbars(cm); }, 100);\n}\n\n// A CodeMirror instance represents an editor. This is the object\n// that user code is usually dealing with.\n\nfunction CodeMirror$1(place, options) {\n  var this$1 = this;\n\n  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }\n\n  this.options = options = options ? copyObj(options) : {};\n  // Determine effective options based on given values and defaults.\n  copyObj(defaults, options, false);\n  setGuttersForLineNumbers(options);\n\n  var doc = options.value;\n  if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n  this.doc = doc;\n\n  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);\n  var display = this.display = new Display(place, doc, input);\n  display.wrapper.CodeMirror = this;\n  updateGutters(this);\n  themeChanged(this);\n  if (options.lineWrapping)\n    { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n  initScrollbars(this);\n\n  this.state = {\n    keyMaps: [],  // stores maps added by addKeyMap\n    overlays: [], // highlighting overlays, as added by addOverlay\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n    overwrite: false,\n    delayingBlurEvent: false,\n    focused: false,\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n    selectingText: false,\n    draggingText: false,\n    highlight: new Delayed(), // stores highlight worker timeout\n    keySeq: null,  // Unfinished key sequence\n    specialChars: null\n  };\n\n  if (options.autofocus && !mobile) { display.input.focus(); }\n\n  // Override magic textarea content restore that IE sometimes does\n  // on our hidden textarea on reload\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n  registerEventHandlers(this);\n  ensureGlobalHandlers();\n\n  startOperation(this);\n  this.curOp.forceUpdate = true;\n  attachDoc(this, doc);\n\n  if ((options.autofocus && !mobile) || this.hasFocus())\n    { setTimeout(bind(onFocus, this), 20); }\n  else\n    { onBlur(this); }\n\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n    { optionHandlers[opt](this$1, options[opt], Init); } }\n  maybeUpdateLineNumberWidth(this);\n  if (options.finishInit) { options.finishInit(this); }\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\n  endOperation(this);\n  // Suppress optimizelegibility in Webkit, since it breaks text\n  // measuring on line wrapping boundaries.\n  if (webkit && options.lineWrapping &&\n      getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n    { display.lineDiv.style.textRendering = \"auto\"; }\n}\n\n// The default configuration options.\nCodeMirror$1.defaults = defaults;\n// Functions to run when options are changed.\nCodeMirror$1.optionHandlers = optionHandlers;\n\n// Attach the necessary event handlers when initializing the editor\nfunction registerEventHandlers(cm) {\n  var d = cm.display;\n  on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n  // Older IE's will not fire a second mousedown for a double click\n  if (ie && ie_version < 11)\n    { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n      if (signalDOMEvent(cm, e)) { return }\n      var pos = posFromMouse(cm, e);\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n      e_preventDefault(e);\n      var word = cm.findWordAt(pos);\n      extendSelection(cm.doc, word.anchor, word.head);\n    })); }\n  else\n    { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n  // Some browsers fire contextmenu *after* opening the menu, at\n  // which point we can't mess with it anymore. Context menu is\n  // handled in onMouseDown for these browsers.\n  if (!captureRightClick) { on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); }); }\n\n  // Used to suppress mouse event handling when a touch happens\n  var touchFinished, prevTouch = {end: 0};\n  function finishTouch() {\n    if (d.activeTouch) {\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n      prevTouch = d.activeTouch;\n      prevTouch.end = +new Date;\n    }\n  }\n  function isMouseLikeTouchEvent(e) {\n    if (e.touches.length != 1) { return false }\n    var touch = e.touches[0];\n    return touch.radiusX <= 1 && touch.radiusY <= 1\n  }\n  function farAway(touch, other) {\n    if (other.left == null) { return true }\n    var dx = other.left - touch.left, dy = other.top - touch.top;\n    return dx * dx + dy * dy > 20 * 20\n  }\n  on(d.scroller, \"touchstart\", function (e) {\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\n      d.input.ensurePolled();\n      clearTimeout(touchFinished);\n      var now = +new Date;\n      d.activeTouch = {start: now, moved: false,\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null};\n      if (e.touches.length == 1) {\n        d.activeTouch.left = e.touches[0].pageX;\n        d.activeTouch.top = e.touches[0].pageY;\n      }\n    }\n  });\n  on(d.scroller, \"touchmove\", function () {\n    if (d.activeTouch) { d.activeTouch.moved = true; }\n  });\n  on(d.scroller, \"touchend\", function (e) {\n    var touch = d.activeTouch;\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\n        !touch.moved && new Date - touch.start < 300) {\n      var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n        { range = new Range(pos, pos); }\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n        { range = cm.findWordAt(pos); }\n      else // Triple tap\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n      cm.setSelection(range.anchor, range.head);\n      cm.focus();\n      e_preventDefault(e);\n    }\n    finishTouch();\n  });\n  on(d.scroller, \"touchcancel\", finishTouch);\n\n  // Sync scrolling between fake scrollbars and real scrollable\n  // area, ensure viewport is updated when scrolling.\n  on(d.scroller, \"scroll\", function () {\n    if (d.scroller.clientHeight) {\n      updateScrollTop(cm, d.scroller.scrollTop);\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\n      signal(cm, \"scroll\", cm);\n    }\n  });\n\n  // Listen to wheel events in order to try and update the viewport on time.\n  on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n  on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n  // Prevent wrapper from ever scrolling\n  on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n  d.dragFunctions = {\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n    start: function (e) { return onDragStart(cm, e); },\n    drop: operation(cm, onDrop),\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n  };\n\n  var inp = d.input.getField();\n  on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n  on(inp, \"keydown\", operation(cm, onKeyDown));\n  on(inp, \"keypress\", operation(cm, onKeyPress));\n  on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n  on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n}\n\nvar initHooks = [];\nCodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };\n\n// Indent the given line. The how parameter can be \"smart\",\n// \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n// (typically set to true for forced single-line indents), empty\n// lines are not indented, and places where the mode returns Pass\n// are left alone.\nfunction indentLine(cm, n, how, aggressive) {\n  var doc = cm.doc, state;\n  if (how == null) { how = \"add\"; }\n  if (how == \"smart\") {\n    // Fall back to \"prev\" when the mode doesn't have an indentation\n    // method.\n    if (!doc.mode.indent) { how = \"prev\"; }\n    else { state = getStateBefore(cm, n); }\n  }\n\n  var tabSize = cm.options.tabSize;\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n  if (line.stateAfter) { line.stateAfter = null; }\n  var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n  if (!aggressive && !/\\S/.test(line.text)) {\n    indentation = 0;\n    how = \"not\";\n  } else if (how == \"smart\") {\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n    if (indentation == Pass || indentation > 150) {\n      if (!aggressive) { return }\n      how = \"prev\";\n    }\n  }\n  if (how == \"prev\") {\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n    else { indentation = 0; }\n  } else if (how == \"add\") {\n    indentation = curSpace + cm.options.indentUnit;\n  } else if (how == \"subtract\") {\n    indentation = curSpace - cm.options.indentUnit;\n  } else if (typeof how == \"number\") {\n    indentation = curSpace + how;\n  }\n  indentation = Math.max(0, indentation);\n\n  var indentString = \"\", pos = 0;\n  if (cm.options.indentWithTabs)\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n  if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n  if (indentString != curSpaceString) {\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    line.stateAfter = null;\n    return true\n  } else {\n    // Ensure that, if the cursor was in the whitespace at the start\n    // of the line, it is moved to the end of that space.\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n      var range = doc.sel.ranges[i$1];\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\n        var pos$1 = Pos(n, curSpaceString.length);\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n        break\n      }\n    }\n  }\n}\n\n// This will be set to a {lineWise: bool, text: [string]} object, so\n// that, when pasting, we know what kind of selections the copied\n// text was made out of.\nvar lastCopied = null;\n\nfunction setLastCopied(newLastCopied) {\n  lastCopied = newLastCopied;\n}\n\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\n  var doc = cm.doc;\n  cm.display.shift = false;\n  if (!sel) { sel = doc.sel; }\n\n  var paste = cm.state.pasteIncoming || origin == \"paste\";\n  var textLines = splitLinesAuto(inserted), multiPaste = null;\n  // When pasing N lines into N selections, insert one line per selection\n  if (paste && sel.ranges.length > 1) {\n    if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n      if (sel.ranges.length % lastCopied.text.length == 0) {\n        multiPaste = [];\n        for (var i = 0; i < lastCopied.text.length; i++)\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n      }\n    } else if (textLines.length == sel.ranges.length) {\n      multiPaste = map(textLines, function (l) { return [l]; });\n    }\n  }\n\n  var updateInput;\n  // Normal behavior is to insert the new text into every selection\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n    var range$$1 = sel.ranges[i$1];\n    var from = range$$1.from(), to = range$$1.to();\n    if (range$$1.empty()) {\n      if (deleted && deleted > 0) // Handle deletion\n        { from = Pos(from.line, from.ch - deleted); }\n      else if (cm.state.overwrite && !paste) // Handle overwrite\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n        { from = to = Pos(from.line, 0); }\n    }\n    updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                       origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n    makeChange(cm.doc, changeEvent);\n    signalLater(cm, \"inputRead\", cm, changeEvent);\n  }\n  if (inserted && !paste)\n    { triggerElectric(cm, inserted); }\n\n  ensureCursorVisible(cm);\n  cm.curOp.updateInput = updateInput;\n  cm.curOp.typing = true;\n  cm.state.pasteIncoming = cm.state.cutIncoming = false;\n}\n\nfunction handlePaste(e, cm) {\n  var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n  if (pasted) {\n    e.preventDefault();\n    if (!cm.isReadOnly() && !cm.options.disableInput)\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n    return true\n  }\n}\n\nfunction triggerElectric(cm, inserted) {\n  // When an 'electric' character is inserted, immediately trigger a reindent\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n  var sel = cm.doc.sel;\n\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\n    var range$$1 = sel.ranges[i];\n    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n    var mode = cm.getModeAt(range$$1.head);\n    var indented = false;\n    if (mode.electricChars) {\n      for (var j = 0; j < mode.electricChars.length; j++)\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n          indented = indentLine(cm, range$$1.head.line, \"smart\");\n          break\n        } }\n    } else if (mode.electricInput) {\n      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n        { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n    }\n    if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n  }\n}\n\nfunction copyableRanges(cm) {\n  var text = [], ranges = [];\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n    var line = cm.doc.sel.ranges[i].head.line;\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n    ranges.push(lineRange);\n    text.push(cm.getRange(lineRange.anchor, lineRange.head));\n  }\n  return {text: text, ranges: ranges}\n}\n\nfunction disableBrowserMagic(field, spellcheck) {\n  field.setAttribute(\"autocorrect\", \"off\");\n  field.setAttribute(\"autocapitalize\", \"off\");\n  field.setAttribute(\"spellcheck\", !!spellcheck);\n}\n\nfunction hiddenTextarea() {\n  var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n  var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n  // The textarea is kept positioned near the cursor to prevent the\n  // fact that it'll be scrolled into view on input from scrolling\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\n  // very slow. So make the area wide instead.\n  if (webkit) { te.style.width = \"1000px\"; }\n  else { te.setAttribute(\"wrap\", \"off\"); }\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\n  if (ios) { te.style.border = \"1px solid black\"; }\n  disableBrowserMagic(te);\n  return div\n}\n\n// The publicly visible API. Note that methodOp(f) means\n// 'wrap f in an operation, performed on its `this` parameter'.\n\n// This is not the complete set of editor methods. Most of the\n// methods defined on the Doc type are also injected into\n// CodeMirror.prototype, for backwards compatibility and\n// convenience.\n\nvar addEditorMethods = function(CodeMirror) {\n  var optionHandlers = CodeMirror.optionHandlers;\n\n  var helpers = CodeMirror.helpers = {};\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") { return }\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        { operation(this, optionHandlers[option])(this, value, old); }\n      signal(this, \"optionChange\", this, option);\n    },\n\n    getOption: function(option) {return this.options[option]},\n    getDoc: function() {return this.doc},\n\n    addKeyMap: function(map$$1, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n    },\n    removeKeyMap: function(map$$1) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n          maps.splice(i, 1);\n          return true\n        } }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n      insertSorted(this.state.overlays,\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                    priority: (options && options.priority) || 0},\n                   function (overlay) { return overlay.priority; });\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var this$1 = this;\n\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this$1.state.modeGen++;\n          regChange(this$1);\n          return\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n        else { dir = dir ? \"add\" : \"subtract\"; }\n      }\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n    }),\n    indentSelection: methodOp(function(how) {\n      var this$1 = this;\n\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range$$1 = ranges[i];\n        if (!range$$1.empty()) {\n          var from = range$$1.from(), to = range$$1.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            { indentLine(this$1, j, how); }\n          var newRanges = this$1.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n        } else if (range$$1.head.line > end) {\n          indentLine(this$1, range$$1.head.line, how, true);\n          end = range$$1.head.line;\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise)\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true)\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) { type = styles[2]; }\n      else { for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n        else { type = styles[mid * 2 + 2]; break }\n      } }\n      var cut = type ? type.indexOf(\"overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) { return mode }\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0]\n    },\n\n    getHelpers: function(pos, type) {\n      var this$1 = this;\n\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) { return found }\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) { found.push(help[mode[type]]); }\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) { found.push(val); }\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n        var cur = help._global[i$1];\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\n          { found.push(cur.val); }\n      }\n      return found\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise)\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range$$1 = this.doc.sel.primary();\n      if (start == null) { pos = range$$1.head; }\n      else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n      else { pos = start ? range$$1.from() : range$$1.to(); }\n      return cursorCoords(this, pos, mode || \"page\")\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top)\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\n    },\n    heightAtLine: function(line, mode, includeWidgets) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) { line = this.doc.first; }\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display) },\n    defaultCharWidth: function() { return charWidth(this.display) },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          { top = pos.top - node.offsetHeight; }\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          { top = pos.bottom; }\n        if (left + node.offsetWidth > hspace)\n          { left = hspace - node.offsetWidth; }\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") { left = 0; }\n        else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        { return commands[cmd].call(null, this) }\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var this$1 = this;\n\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        cur = findPosH(this$1.doc, cur, dir, unit, visually);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      this.extendSelectionsBy(function (range$$1) {\n        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n        else\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        { doc.replaceSelection(\"\", null, \"+delete\"); }\n      else\n        { deleteNearSelection(this, function (range$$1) {\n          var other = findPosH(doc, range$$1.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n        }); }\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var this$1 = this;\n\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      var cur = clipPos(this.doc, from);\n      for (var i = 0; i < amount; ++i) {\n        var coords = cursorCoords(this$1, cur, \"div\");\n        if (x == null) { x = coords.left; }\n        else { coords.left = x; }\n        cur = findPosV(this$1, coords, dir, unit);\n        if (cur.hitSide) { break }\n      }\n      return cur\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var this$1 = this;\n\n      var doc = this.doc, goals = [];\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function (range$$1) {\n        if (collapse)\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\n        var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n        goals.push(headPos.left);\n        var pos = findPosV(this$1, headPos, dir, unit);\n        if (unit == \"page\" && range$$1 == doc.sel.primary())\n          { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n        return pos\n      }, sel_move);\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n        { doc.sel.ranges[i].goalColumn = goals[i]; } }\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function (ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n          : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n        while (start > 0 && check(line.charAt(start - 1))) { --start; }\n        while (end < line.length && check(line.charAt(end))) { ++end; }\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) { return }\n      if (this.state.overwrite = !this.state.overwrite)\n        { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n      else\n        { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n    },\n\n    scrollIntoView: methodOp(function(range$$1, margin) {\n      if (range$$1 == null) {\n        range$$1 = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) { margin = this.options.cursorScrollMargin; }\n      } else if (typeof range$$1 == \"number\") {\n        range$$1 = {from: Pos(range$$1, 0), to: null};\n      } else if (range$$1.from == null) {\n        range$$1 = {from: range$$1, to: null};\n      }\n      if (!range$$1.to) { range$$1.to = range$$1.from; }\n      range$$1.margin = margin || 0;\n\n      if (range$$1.from.line != null) {\n        scrollToRange(this, range$$1);\n      } else {\n        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var this$1 = this;\n\n      var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n      if (width != null) { this.display.wrapper.style.width = interpret(width); }\n      if (height != null) { this.display.wrapper.style.height = interpret(height); }\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n      var lineNo$$1 = this.display.viewFrom;\n      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n        ++lineNo$$1;\n      });\n      this.curOp.forceUpdate = true;\n      signal(this, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f)},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        { estimateLineHeights(this); }\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old\n    }),\n\n    getInputField: function(){return this.display.input.getField()},\n    getWrapperElement: function(){return this.display.wrapper},\n    getScrollerElement: function(){return this.display.scroller},\n    getGutterElement: function(){return this.display.gutters}\n  };\n  eventMixin(CodeMirror);\n\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n};\n\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\n// right), unit can be \"char\", \"column\" (like char, but doesn't\n// cross line boundaries), \"word\" (across next word), or \"group\" (to\n// the start of next group of word or non-word-non-whitespace\n// chars). The visually param controls whether, in right-to-left\n// text, direction 1 means to move towards the next index in the\n// string, or towards the character to the right of the current\n// position. The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosH(doc, pos, dir, unit, visually) {\n  var oldPos = pos;\n  var origDir = dir;\n  var lineObj = getLine(doc, pos.line);\n  function findNextLine() {\n    var l = pos.line + dir;\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\n    pos = new Pos(l, pos.ch, pos.sticky);\n    return lineObj = getLine(doc, l)\n  }\n  function moveOnce(boundToLine) {\n    var next;\n    if (visually) {\n      next = moveVisually(doc.cm, lineObj, pos, dir);\n    } else {\n      next = moveLogically(lineObj, pos, dir);\n    }\n    if (next == null) {\n      if (!boundToLine && findNextLine())\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n      else\n        { return false }\n    } else {\n      pos = next;\n    }\n    return true\n  }\n\n  if (unit == \"char\") {\n    moveOnce();\n  } else if (unit == \"column\") {\n    moveOnce(true);\n  } else if (unit == \"word\" || unit == \"group\") {\n    var sawType = null, group = unit == \"group\";\n    var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n    for (var first = true;; first = false) {\n      if (dir < 0 && !moveOnce(!first)) { break }\n      var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n      var type = isWordChar(cur, helper) ? \"w\"\n        : group && cur == \"\\n\" ? \"n\"\n        : !group || /\\s/.test(cur) ? null\n        : \"p\";\n      if (group && !first && !type) { type = \"s\"; }\n      if (sawType && sawType != type) {\n        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n        break\n      }\n\n      if (type) { sawType = type; }\n      if (dir > 0 && !moveOnce(!first)) { break }\n    }\n  }\n  var result = skipAtomic(doc, pos, oldPos, origDir, true);\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n  return result\n}\n\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\n// \"page\" or \"line\". The resulting position will have a hitSide=true\n// property if it reached the end of the document.\nfunction findPosV(cm, pos, dir, unit) {\n  var doc = cm.doc, x = pos.left, y;\n  if (unit == \"page\") {\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n  } else if (unit == \"line\") {\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n  }\n  var target;\n  for (;;) {\n    target = coordsChar(cm, x, y);\n    if (!target.outside) { break }\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n    y += dir * 5;\n  }\n  return target\n}\n\n// CONTENTEDITABLE INPUT STYLE\n\nvar ContentEditableInput = function(cm) {\n  this.cm = cm;\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n  this.polling = new Delayed();\n  this.composing = null;\n  this.gracePeriod = false;\n  this.readDOMTimeout = null;\n};\n\nContentEditableInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = input.cm;\n  var div = input.div = display.lineDiv;\n  disableBrowserMagic(div, cm.options.spellcheck);\n\n  on(div, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n  });\n\n  on(div, \"compositionstart\", function (e) {\n    this$1.composing = {data: e.data, done: false};\n  });\n  on(div, \"compositionupdate\", function (e) {\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n  });\n  on(div, \"compositionend\", function (e) {\n    if (this$1.composing) {\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n      this$1.composing.done = true;\n    }\n  });\n\n  on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n  on(div, \"input\", function () {\n    if (!this$1.composing) { this$1.readFromDOMSoon(); }\n  });\n\n  function onCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n      if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.operation(function () {\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n          cm.replaceSelection(\"\", null, \"cut\");\n        });\n      }\n    }\n    if (e.clipboardData) {\n      e.clipboardData.clearData();\n      var content = lastCopied.text.join(\"\\n\");\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\n      e.clipboardData.setData(\"Text\", content);\n      if (e.clipboardData.getData(\"Text\") == content) {\n        e.preventDefault();\n        return\n      }\n    }\n    // Old-fashioned briefly-focus-a-textarea hack\n    var kludge = hiddenTextarea(), te = kludge.firstChild;\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n    te.value = lastCopied.text.join(\"\\n\");\n    var hadFocus = document.activeElement;\n    selectInput(te);\n    setTimeout(function () {\n      cm.display.lineSpace.removeChild(kludge);\n      hadFocus.focus();\n      if (hadFocus == div) { input.showPrimarySelection(); }\n    }, 50);\n  }\n  on(div, \"copy\", onCopyCut);\n  on(div, \"cut\", onCopyCut);\n};\n\nContentEditableInput.prototype.prepareSelection = function () {\n  var result = prepareSelection(this.cm, false);\n  result.focus = this.cm.state.focused;\n  return result\n};\n\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n  if (!info || !this.cm.display.view.length) { return }\n  if (info.focus || takeFocus) { this.showPrimarySelection(); }\n  this.showMultipleSelections(info);\n};\n\nContentEditableInput.prototype.showPrimarySelection = function () {\n  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n  var from = prim.from(), to = prim.to();\n\n  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n      cmp(minPos(curAnchor, curFocus), from) == 0 &&\n      cmp(maxPos(curAnchor, curFocus), to) == 0)\n    { return }\n\n  var view = cm.display.view;\n  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n      {node: view[0].measure.map[2], offset: 0};\n  var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n  if (!end) {\n    var measure = view[view.length - 1].measure;\n    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n  }\n\n  if (!start || !end) {\n    sel.removeAllRanges();\n    return\n  }\n\n  var old = sel.rangeCount && sel.getRangeAt(0), rng;\n  try { rng = range(start.node, start.offset, end.offset, end.node); }\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n  if (rng) {\n    if (!gecko && cm.state.focused) {\n      sel.collapse(start.node, start.offset);\n      if (!rng.collapsed) {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n    } else {\n      sel.removeAllRanges();\n      sel.addRange(rng);\n    }\n    if (old && sel.anchorNode == null) { sel.addRange(old); }\n    else if (gecko) { this.startGracePeriod(); }\n  }\n  this.rememberSelection();\n};\n\nContentEditableInput.prototype.startGracePeriod = function () {\n    var this$1 = this;\n\n  clearTimeout(this.gracePeriod);\n  this.gracePeriod = setTimeout(function () {\n    this$1.gracePeriod = false;\n    if (this$1.selectionChanged())\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n  }, 20);\n};\n\nContentEditableInput.prototype.showMultipleSelections = function (info) {\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n};\n\nContentEditableInput.prototype.rememberSelection = function () {\n  var sel = window.getSelection();\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n};\n\nContentEditableInput.prototype.selectionInEditor = function () {\n  var sel = window.getSelection();\n  if (!sel.rangeCount) { return false }\n  var node = sel.getRangeAt(0).commonAncestorContainer;\n  return contains(this.div, node)\n};\n\nContentEditableInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\") {\n    if (!this.selectionInEditor())\n      { this.showSelection(this.prepareSelection(), true); }\n    this.div.focus();\n  }\n};\nContentEditableInput.prototype.blur = function () { this.div.blur(); };\nContentEditableInput.prototype.getField = function () { return this.div };\n\nContentEditableInput.prototype.supportsTouch = function () { return true };\n\nContentEditableInput.prototype.receivedFocus = function () {\n  var input = this;\n  if (this.selectionInEditor())\n    { this.pollSelection(); }\n  else\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n  function poll() {\n    if (input.cm.state.focused) {\n      input.pollSelection();\n      input.polling.set(input.cm.options.pollInterval, poll);\n    }\n  }\n  this.polling.set(this.cm.options.pollInterval, poll);\n};\n\nContentEditableInput.prototype.selectionChanged = function () {\n  var sel = window.getSelection();\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n};\n\nContentEditableInput.prototype.pollSelection = function () {\n  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n  var sel = window.getSelection(), cm = this.cm;\n  // On Android Chrome (version 56, at least), backspacing into an\n  // uneditable block element will put the cursor in that element,\n  // and then, because it's not editable, hide the virtual keyboard.\n  // Because Android doesn't allow us to actually detect backspace\n  // presses in a sane way, this code checks for when that happens\n  // and simulates a backspace press in this case.\n  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n    this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n    this.blur();\n    this.focus();\n    return\n  }\n  if (this.composing) { return }\n  this.rememberSelection();\n  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n  var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n  if (anchor && head) { runInOp(cm, function () {\n    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n  }); }\n};\n\nContentEditableInput.prototype.pollContent = function () {\n  if (this.readDOMTimeout != null) {\n    clearTimeout(this.readDOMTimeout);\n    this.readDOMTimeout = null;\n  }\n\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n  var from = sel.from(), to = sel.to();\n  if (from.ch == 0 && from.line > cm.firstLine())\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n    { to = Pos(to.line + 1, 0); }\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n  var fromIndex, fromLine, fromNode;\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n    fromLine = lineNo(display.view[0].line);\n    fromNode = display.view[0].node;\n  } else {\n    fromLine = lineNo(display.view[fromIndex].line);\n    fromNode = display.view[fromIndex - 1].node.nextSibling;\n  }\n  var toIndex = findViewIndex(cm, to.line);\n  var toLine, toNode;\n  if (toIndex == display.view.length - 1) {\n    toLine = display.viewTo - 1;\n    toNode = display.lineDiv.lastChild;\n  } else {\n    toLine = lineNo(display.view[toIndex + 1].line) - 1;\n    toNode = display.view[toIndex + 1].node.previousSibling;\n  }\n\n  if (!fromNode) { return false }\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n  while (newText.length > 1 && oldText.length > 1) {\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n    else { break }\n  }\n\n  var cutFront = 0, cutEnd = 0;\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n    { ++cutFront; }\n  var newBot = lst(newText), oldBot = lst(oldText);\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0));\n  while (cutEnd < maxCutEnd &&\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n    { ++cutEnd; }\n  // Try to move start of change to start of selection if ambiguous\n  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n    while (cutFront && cutFront > from.ch &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n      cutFront--;\n      cutEnd++;\n    }\n  }\n\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n  newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n  var chFrom = Pos(fromLine, cutFront);\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n    replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n    return true\n  }\n};\n\nContentEditableInput.prototype.ensurePolled = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.reset = function () {\n  this.forceCompositionEnd();\n};\nContentEditableInput.prototype.forceCompositionEnd = function () {\n  if (!this.composing) { return }\n  clearTimeout(this.readDOMTimeout);\n  this.composing = null;\n  this.updateFromDOM();\n  this.div.blur();\n  this.div.focus();\n};\nContentEditableInput.prototype.readFromDOMSoon = function () {\n    var this$1 = this;\n\n  if (this.readDOMTimeout != null) { return }\n  this.readDOMTimeout = setTimeout(function () {\n    this$1.readDOMTimeout = null;\n    if (this$1.composing) {\n      if (this$1.composing.done) { this$1.composing = null; }\n      else { return }\n    }\n    this$1.updateFromDOM();\n  }, 80);\n};\n\nContentEditableInput.prototype.updateFromDOM = function () {\n    var this$1 = this;\n\n  if (this.cm.isReadOnly() || !this.pollContent())\n    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n};\n\nContentEditableInput.prototype.setUneditable = function (node) {\n  node.contentEditable = \"false\";\n};\n\nContentEditableInput.prototype.onKeyPress = function (e) {\n  if (e.charCode == 0) { return }\n  e.preventDefault();\n  if (!this.cm.isReadOnly())\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n};\n\nContentEditableInput.prototype.readOnlyChanged = function (val) {\n  this.div.contentEditable = String(val != \"nocursor\");\n};\n\nContentEditableInput.prototype.onContextMenu = function () {};\nContentEditableInput.prototype.resetPosition = function () {};\n\nContentEditableInput.prototype.needsContentAttribute = true;\n\nfunction posToDOM(cm, pos) {\n  var view = findViewForLine(cm, pos.line);\n  if (!view || view.hidden) { return null }\n  var line = getLine(cm.doc, pos.line);\n  var info = mapFromLineView(view, line, pos.line);\n\n  var order = getOrder(line, cm.doc.direction), side = \"left\";\n  if (order) {\n    var partPos = getBidiPartAt(order, pos.ch);\n    side = partPos % 2 ? \"right\" : \"left\";\n  }\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n  result.offset = result.collapse == \"right\" ? result.end : result.start;\n  return result\n}\n\nfunction isInGutter(node) {\n  for (var scan = node; scan; scan = scan.parentNode)\n    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n  return false\n}\n\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\n  var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n  function close() {\n    if (closing) {\n      text += lineSep;\n      closing = false;\n    }\n  }\n  function addText(str) {\n    if (str) {\n      close();\n      text += str;\n    }\n  }\n  function walk(node) {\n    if (node.nodeType == 1) {\n      var cmText = node.getAttribute(\"cm-text\");\n      if (cmText != null) {\n        addText(cmText || node.textContent.replace(/\\u200b/g, \"\"));\n        return\n      }\n      var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n      if (markerID) {\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n        if (found.length && (range$$1 = found[0].find()))\n          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n        return\n      }\n      if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);\n      if (isBlock) { close(); }\n      for (var i = 0; i < node.childNodes.length; i++)\n        { walk(node.childNodes[i]); }\n      if (isBlock) { closing = true; }\n    } else if (node.nodeType == 3) {\n      addText(node.nodeValue);\n    }\n  }\n  for (;;) {\n    walk(from);\n    if (from == to) { break }\n    from = from.nextSibling;\n  }\n  return text\n}\n\nfunction domToPos(cm, node, offset) {\n  var lineNode;\n  if (node == cm.display.lineDiv) {\n    lineNode = cm.display.lineDiv.childNodes[offset];\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n    node = null; offset = 0;\n  } else {\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n    }\n  }\n  for (var i = 0; i < cm.display.view.length; i++) {\n    var lineView = cm.display.view[i];\n    if (lineView.node == lineNode)\n      { return locateNodeInLineView(lineView, node, offset) }\n  }\n}\n\nfunction locateNodeInLineView(lineView, node, offset) {\n  var wrapper = lineView.text.firstChild, bad = false;\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n  if (node == wrapper) {\n    bad = true;\n    node = wrapper.childNodes[offset];\n    offset = 0;\n    if (!node) {\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n      return badPos(Pos(lineNo(line), line.text.length), bad)\n    }\n  }\n\n  var textNode = node.nodeType == 3 ? node : null, topNode = node;\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n    textNode = node.firstChild;\n    if (offset) { offset = textNode.nodeValue.length; }\n  }\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n  var measure = lineView.measure, maps = measure.maps;\n\n  function find(textNode, topNode, offset) {\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\n      var map$$1 = i < 0 ? measure.map : maps[i];\n      for (var j = 0; j < map$$1.length; j += 3) {\n        var curNode = map$$1[j + 2];\n        if (curNode == textNode || curNode == topNode) {\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n          var ch = map$$1[j] + offset;\n          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n          return Pos(line, ch)\n        }\n      }\n    }\n  }\n  var found = find(textNode, topNode, offset);\n  if (found) { return badPos(found, bad) }\n\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n    found = find(after, after.firstChild, 0);\n    if (found)\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\n    else\n      { dist += after.textContent.length; }\n  }\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n    found = find(before, before.firstChild, -1);\n    if (found)\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n    else\n      { dist$1 += before.textContent.length; }\n  }\n}\n\n// TEXTAREA INPUT STYLE\n\nvar TextareaInput = function(cm) {\n  this.cm = cm;\n  // See input.poll and input.reset\n  this.prevInput = \"\";\n\n  // Flag that indicates whether we expect input to appear real soon\n  // now (after some event like 'keypress' or 'input') and are\n  // polling intensively.\n  this.pollingFast = false;\n  // Self-resetting timeout for the poller\n  this.polling = new Delayed();\n  // Tracks when input.reset has punted to just putting a short\n  // string into the textarea instead of the full selection.\n  this.inaccurateSelection = false;\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n  this.hasSelection = false;\n  this.composing = null;\n};\n\nTextareaInput.prototype.init = function (display) {\n    var this$1 = this;\n\n  var input = this, cm = this.cm;\n\n  // Wraps and hides input textarea\n  var div = this.wrapper = hiddenTextarea();\n  // The semihidden textarea that is focused when the editor is\n  // focused, and receives input.\n  var te = this.textarea = div.firstChild;\n  display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n  if (ios) { te.style.width = \"0px\"; }\n\n  on(te, \"input\", function () {\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n    input.poll();\n  });\n\n  on(te, \"paste\", function (e) {\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n    cm.state.pasteIncoming = true;\n    input.fastPoll();\n  });\n\n  function prepareCopyCut(e) {\n    if (signalDOMEvent(cm, e)) { return }\n    if (cm.somethingSelected()) {\n      setLastCopied({lineWise: false, text: cm.getSelections()});\n      if (input.inaccurateSelection) {\n        input.prevInput = \"\";\n        input.inaccurateSelection = false;\n        te.value = lastCopied.text.join(\"\\n\");\n        selectInput(te);\n      }\n    } else if (!cm.options.lineWiseCopyCut) {\n      return\n    } else {\n      var ranges = copyableRanges(cm);\n      setLastCopied({lineWise: true, text: ranges.text});\n      if (e.type == \"cut\") {\n        cm.setSelections(ranges.ranges, null, sel_dontScroll);\n      } else {\n        input.prevInput = \"\";\n        te.value = ranges.text.join(\"\\n\");\n        selectInput(te);\n      }\n    }\n    if (e.type == \"cut\") { cm.state.cutIncoming = true; }\n  }\n  on(te, \"cut\", prepareCopyCut);\n  on(te, \"copy\", prepareCopyCut);\n\n  on(display.scroller, \"paste\", function (e) {\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n    cm.state.pasteIncoming = true;\n    input.focus();\n  });\n\n  // Prevent normal selection in the editor (we handle our own)\n  on(display.lineSpace, \"selectstart\", function (e) {\n    if (!eventInWidget(display, e)) { e_preventDefault(e); }\n  });\n\n  on(te, \"compositionstart\", function () {\n    var start = cm.getCursor(\"from\");\n    if (input.composing) { input.composing.range.clear(); }\n    input.composing = {\n      start: start,\n      range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n    };\n  });\n  on(te, \"compositionend\", function () {\n    if (input.composing) {\n      input.poll();\n      input.composing.range.clear();\n      input.composing = null;\n    }\n  });\n};\n\nTextareaInput.prototype.prepareSelection = function () {\n  // Redraw the selection and/or cursor\n  var cm = this.cm, display = cm.display, doc = cm.doc;\n  var result = prepareSelection(cm);\n\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\n  if (cm.options.moveInputWithCursor) {\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                        headPos.top + lineOff.top - wrapOff.top));\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                         headPos.left + lineOff.left - wrapOff.left));\n  }\n\n  return result\n};\n\nTextareaInput.prototype.showSelection = function (drawn) {\n  var cm = this.cm, display = cm.display;\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n  if (drawn.teTop != null) {\n    this.wrapper.style.top = drawn.teTop + \"px\";\n    this.wrapper.style.left = drawn.teLeft + \"px\";\n  }\n};\n\n// Reset the input to correspond to the selection (or to be empty,\n// when not typing and nothing is selected)\nTextareaInput.prototype.reset = function (typing) {\n  if (this.contextMenuPending || this.composing) { return }\n  var minimal, selected, cm = this.cm, doc = cm.doc;\n  if (cm.somethingSelected()) {\n    this.prevInput = \"\";\n    var range$$1 = doc.sel.primary();\n    minimal = hasCopyEvent &&\n      (range$$1.to().line - range$$1.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n    var content = minimal ? \"-\" : selected || cm.getSelection();\n    this.textarea.value = content;\n    if (cm.state.focused) { selectInput(this.textarea); }\n    if (ie && ie_version >= 9) { this.hasSelection = content; }\n  } else if (!typing) {\n    this.prevInput = this.textarea.value = \"\";\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n  }\n  this.inaccurateSelection = minimal;\n};\n\nTextareaInput.prototype.getField = function () { return this.textarea };\n\nTextareaInput.prototype.supportsTouch = function () { return false };\n\nTextareaInput.prototype.focus = function () {\n  if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n    try { this.textarea.focus(); }\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n  }\n};\n\nTextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\nTextareaInput.prototype.resetPosition = function () {\n  this.wrapper.style.top = this.wrapper.style.left = 0;\n};\n\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n// Poll for input changes, using the normal rate of polling. This\n// runs as long as the editor is focused.\nTextareaInput.prototype.slowPoll = function () {\n    var this$1 = this;\n\n  if (this.pollingFast) { return }\n  this.polling.set(this.cm.options.pollInterval, function () {\n    this$1.poll();\n    if (this$1.cm.state.focused) { this$1.slowPoll(); }\n  });\n};\n\n// When an event has just come in that is likely to add or change\n// something in the input textarea, we poll faster, to ensure that\n// the change appears on the screen quickly.\nTextareaInput.prototype.fastPoll = function () {\n  var missed = false, input = this;\n  input.pollingFast = true;\n  function p() {\n    var changed = input.poll();\n    if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n    else {input.pollingFast = false; input.slowPoll();}\n  }\n  input.polling.set(20, p);\n};\n\n// Read input from the textarea, and update the document to match.\n// When something is selected, it is present in the textarea, and\n// selected (unless it is huge, in which case a placeholder is\n// used). When nothing is selected, the cursor sits after previously\n// seen text (can be empty), which is stored in prevInput (we must\n// not reset the textarea when typing, because that breaks IME).\nTextareaInput.prototype.poll = function () {\n    var this$1 = this;\n\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n  // Since this is called a *lot*, try to bail out as cheaply as\n  // possible when it is clear that nothing happened. hasSelection\n  // will be the case when there is a lot of text in the textarea,\n  // in which case reading its value would be expensive.\n  if (this.contextMenuPending || !cm.state.focused ||\n      (hasSelection(input) && !prevInput && !this.composing) ||\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n    { return false }\n\n  var text = input.value;\n  // If nothing changed, bail.\n  if (text == prevInput && !cm.somethingSelected()) { return false }\n  // Work around nonsensical selection resetting in IE9/10, and\n  // inexplicable appearance of private area unicode characters on\n  // some key combos in Mac (#2689).\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\n      mac && /[\\uf700-\\uf7ff]/.test(text)) {\n    cm.display.input.reset();\n    return false\n  }\n\n  if (cm.doc.sel == cm.display.selForContextMenu) {\n    var first = text.charCodeAt(0);\n    if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n  }\n  // Find the part of the input that is actually new\n  var same = 0, l = Math.min(prevInput.length, text.length);\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n  runInOp(cm, function () {\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\n                   null, this$1.composing ? \"*compose\" : null);\n\n    // Don't leave long text in the textarea, since it makes further polling slow\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n    else { this$1.prevInput = text; }\n\n    if (this$1.composing) {\n      this$1.composing.range.clear();\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                         {className: \"CodeMirror-composing\"});\n    }\n  });\n  return true\n};\n\nTextareaInput.prototype.ensurePolled = function () {\n  if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n};\n\nTextareaInput.prototype.onKeyPress = function () {\n  if (ie && ie_version >= 9) { this.hasSelection = null; }\n  this.fastPoll();\n};\n\nTextareaInput.prototype.onContextMenu = function (e) {\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n  if (!pos || presto) { return } // Opera is difficult.\n\n  // Reset the current text selection only if the click is done outside of the selection\n  // and 'resetSelectionOnContextMenu' option is true.\n  var reset = cm.options.resetSelectionOnContextMenu;\n  if (reset && cm.doc.sel.contains(pos) == -1)\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n  input.wrapper.style.cssText = \"position: absolute\";\n  var wrapperBox = input.wrapper.getBoundingClientRect();\n  te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n  var oldScrollY;\n  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n  display.input.focus();\n  if (webkit) { window.scrollTo(null, oldScrollY); }\n  display.input.reset();\n  // Adds \"Select all\" to context menu in FF\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n  input.contextMenuPending = true;\n  display.selForContextMenu = cm.doc.sel;\n  clearTimeout(display.detectingSelectAll);\n\n  // Select-all will be greyed out if there's nothing to select, so\n  // this adds a zero-width space so that we can later check whether\n  // it got selected.\n  function prepareSelectAllHack() {\n    if (te.selectionStart != null) {\n      var selected = cm.somethingSelected();\n      var extval = \"\\u200b\" + (selected ? te.value : \"\");\n      te.value = \"\\u21da\"; // Used to catch context-menu undo\n      te.value = extval;\n      input.prevInput = selected ? \"\" : \"\\u200b\";\n      te.selectionStart = 1; te.selectionEnd = extval.length;\n      // Re-set this, in case some other handler touched the\n      // selection in the meantime.\n      display.selForContextMenu = cm.doc.sel;\n    }\n  }\n  function rehide() {\n    input.contextMenuPending = false;\n    input.wrapper.style.cssText = oldWrapperCSS;\n    te.style.cssText = oldCSS;\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n    // Try to detect the user choosing select-all\n    if (te.selectionStart != null) {\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n      var i = 0, poll = function () {\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n            te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n          operation(cm, selectAll)(cm);\n        } else if (i++ < 10) {\n          display.detectingSelectAll = setTimeout(poll, 500);\n        } else {\n          display.selForContextMenu = null;\n          display.input.reset();\n        }\n      };\n      display.detectingSelectAll = setTimeout(poll, 200);\n    }\n  }\n\n  if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n  if (captureRightClick) {\n    e_stop(e);\n    var mouseup = function () {\n      off(window, \"mouseup\", mouseup);\n      setTimeout(rehide, 20);\n    };\n    on(window, \"mouseup\", mouseup);\n  } else {\n    setTimeout(rehide, 50);\n  }\n};\n\nTextareaInput.prototype.readOnlyChanged = function (val) {\n  if (!val) { this.reset(); }\n};\n\nTextareaInput.prototype.setUneditable = function () {};\n\nTextareaInput.prototype.needsContentAttribute = false;\n\nfunction fromTextArea(textarea, options) {\n  options = options ? copyObj(options) : {};\n  options.value = textarea.value;\n  if (!options.tabindex && textarea.tabIndex)\n    { options.tabindex = textarea.tabIndex; }\n  if (!options.placeholder && textarea.placeholder)\n    { options.placeholder = textarea.placeholder; }\n  // Set autofocus to true if this textarea is focused, or if it has\n  // autofocus and no other element is focused.\n  if (options.autofocus == null) {\n    var hasFocus = activeElt();\n    options.autofocus = hasFocus == textarea ||\n      textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n  }\n\n  function save() {textarea.value = cm.getValue();}\n\n  var realSubmit;\n  if (textarea.form) {\n    on(textarea.form, \"submit\", save);\n    // Deplorable hack to make the submit method do the right thing.\n    if (!options.leaveSubmitMethodAlone) {\n      var form = textarea.form;\n      realSubmit = form.submit;\n      try {\n        var wrappedSubmit = form.submit = function () {\n          save();\n          form.submit = realSubmit;\n          form.submit();\n          form.submit = wrappedSubmit;\n        };\n      } catch(e) {}\n    }\n  }\n\n  options.finishInit = function (cm) {\n    cm.save = save;\n    cm.getTextArea = function () { return textarea; };\n    cm.toTextArea = function () {\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          { textarea.form.submit = realSubmit; }\n      }\n    };\n  };\n\n  textarea.style.display = \"none\";\n  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n    options);\n  return cm\n}\n\nfunction addLegacyProps(CodeMirror) {\n  CodeMirror.off = off;\n  CodeMirror.on = on;\n  CodeMirror.wheelEventPixels = wheelEventPixels;\n  CodeMirror.Doc = Doc;\n  CodeMirror.splitLines = splitLinesAuto;\n  CodeMirror.countColumn = countColumn;\n  CodeMirror.findColumn = findColumn;\n  CodeMirror.isWordChar = isWordCharBasic;\n  CodeMirror.Pass = Pass;\n  CodeMirror.signal = signal;\n  CodeMirror.Line = Line;\n  CodeMirror.changeEnd = changeEnd;\n  CodeMirror.scrollbarModel = scrollbarModel;\n  CodeMirror.Pos = Pos;\n  CodeMirror.cmpPos = cmp;\n  CodeMirror.modes = modes;\n  CodeMirror.mimeModes = mimeModes;\n  CodeMirror.resolveMode = resolveMode;\n  CodeMirror.getMode = getMode;\n  CodeMirror.modeExtensions = modeExtensions;\n  CodeMirror.extendMode = extendMode;\n  CodeMirror.copyState = copyState;\n  CodeMirror.startState = startState;\n  CodeMirror.innerMode = innerMode;\n  CodeMirror.commands = commands;\n  CodeMirror.keyMap = keyMap;\n  CodeMirror.keyName = keyName;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.normalizeKeyMap = normalizeKeyMap;\n  CodeMirror.StringStream = StringStream;\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  CodeMirror.TextMarker = TextMarker;\n  CodeMirror.LineWidget = LineWidget;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.addClass = addClass;\n  CodeMirror.contains = contains;\n  CodeMirror.rmClass = rmClass;\n  CodeMirror.keyNames = keyNames;\n}\n\n// EDITOR CONSTRUCTOR\n\ndefineOptions(CodeMirror$1);\n\naddEditorMethods(CodeMirror$1);\n\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\nvar dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n  { CodeMirror$1.prototype[prop] = (function(method) {\n    return function() {return method.apply(this.doc, arguments)}\n  })(Doc.prototype[prop]); } }\n\neventMixin(Doc);\n\n// INPUT HANDLING\n\nCodeMirror$1.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n// MODE DEFINITION AND QUERYING\n\n// Extra arguments are stored as the mode's dependencies, which is\n// used by (legacy) mechanisms like loadmode.js to automatically\n// load a mode. (Preferred mechanism is the require/define calls.)\nCodeMirror$1.defineMode = function(name/*, mode, */) {\n  if (!CodeMirror$1.defaults.mode && name != \"null\") { CodeMirror$1.defaults.mode = name; }\n  defineMode.apply(this, arguments);\n};\n\nCodeMirror$1.defineMIME = defineMIME;\n\n// Minimal default mode.\nCodeMirror$1.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\nCodeMirror$1.defineMIME(\"text/plain\", \"null\");\n\n// EXTENSIONS\n\nCodeMirror$1.defineExtension = function (name, func) {\n  CodeMirror$1.prototype[name] = func;\n};\nCodeMirror$1.defineDocExtension = function (name, func) {\n  Doc.prototype[name] = func;\n};\n\nCodeMirror$1.fromTextArea = fromTextArea;\n\naddLegacyProps(CodeMirror$1);\n\nCodeMirror$1.version = \"5.26.0\";\n\nreturn CodeMirror$1;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/codemirror/lib/codemirror.js\n// module id = 149\n// module chunks = 0","/**\n * Super simple wysiwyg editor v0.8.1\n * http://summernote.org/\n *\n * summernote.js\n * Copyright 2013-2015 Alan Hong. and other contributors\n * summernote may be freely distributed under the MIT license./\n *\n * Date: 2016-05-26T08:13Z\n */\n(function (factory) {\n  /* global define */\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['jquery'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = factory(require('jquery'));\n  } else {\n    // Browser globals\n    factory(window.jQuery);\n  }\n}(function ($) {\n  'use strict';\n\n  /**\n   * @class core.func\n   *\n   * func utils (for high-order func's arg)\n   *\n   * @singleton\n   * @alternateClassName func\n   */\n  var func = (function () {\n    var eq = function (itemA) {\n      return function (itemB) {\n        return itemA === itemB;\n      };\n    };\n\n    var eq2 = function (itemA, itemB) {\n      return itemA === itemB;\n    };\n\n    var peq2 = function (propName) {\n      return function (itemA, itemB) {\n        return itemA[propName] === itemB[propName];\n      };\n    };\n\n    var ok = function () {\n      return true;\n    };\n\n    var fail = function () {\n      return false;\n    };\n\n    var not = function (f) {\n      return function () {\n        return !f.apply(f, arguments);\n      };\n    };\n\n    var and = function (fA, fB) {\n      return function (item) {\n        return fA(item) && fB(item);\n      };\n    };\n\n    var self = function (a) {\n      return a;\n    };\n\n    var invoke = function (obj, method) {\n      return function () {\n        return obj[method].apply(obj, arguments);\n      };\n    };\n\n    var idCounter = 0;\n\n    /**\n     * generate a globally-unique id\n     *\n     * @param {String} [prefix]\n     */\n    var uniqueId = function (prefix) {\n      var id = ++idCounter + '';\n      return prefix ? prefix + id : id;\n    };\n\n    /**\n     * returns bnd (bounds) from rect\n     *\n     * - IE Compatibility Issue: http://goo.gl/sRLOAo\n     * - Scroll Issue: http://goo.gl/sNjUc\n     *\n     * @param {Rect} rect\n     * @return {Object} bounds\n     * @return {Number} bounds.top\n     * @return {Number} bounds.left\n     * @return {Number} bounds.width\n     * @return {Number} bounds.height\n     */\n    var rect2bnd = function (rect) {\n      var $document = $(document);\n      return {\n        top: rect.top + $document.scrollTop(),\n        left: rect.left + $document.scrollLeft(),\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n      };\n    };\n\n    /**\n     * returns a copy of the object where the keys have become the values and the values the keys.\n     * @param {Object} obj\n     * @return {Object}\n     */\n    var invertObject = function (obj) {\n      var inverted = {};\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          inverted[obj[key]] = key;\n        }\n      }\n      return inverted;\n    };\n\n    /**\n     * @param {String} namespace\n     * @param {String} [prefix]\n     * @return {String}\n     */\n    var namespaceToCamel = function (namespace, prefix) {\n      prefix = prefix || '';\n      return prefix + namespace.split('.').map(function (name) {\n        return name.substring(0, 1).toUpperCase() + name.substring(1);\n      }).join('');\n    };\n\n    return {\n      eq: eq,\n      eq2: eq2,\n      peq2: peq2,\n      ok: ok,\n      fail: fail,\n      self: self,\n      not: not,\n      and: and,\n      invoke: invoke,\n      uniqueId: uniqueId,\n      rect2bnd: rect2bnd,\n      invertObject: invertObject,\n      namespaceToCamel: namespaceToCamel\n    };\n  })();\n\n  /**\n   * @class core.list\n   *\n   * list utils\n   *\n   * @singleton\n   * @alternateClassName list\n   */\n  var list = (function () {\n    /**\n     * returns the first item of an array.\n     *\n     * @param {Array} array\n     */\n    var head = function (array) {\n      return array[0];\n    };\n\n    /**\n     * returns the last item of an array.\n     *\n     * @param {Array} array\n     */\n    var last = function (array) {\n      return array[array.length - 1];\n    };\n\n    /**\n     * returns everything but the last entry of the array.\n     *\n     * @param {Array} array\n     */\n    var initial = function (array) {\n      return array.slice(0, array.length - 1);\n    };\n\n    /**\n     * returns the rest of the items in an array.\n     *\n     * @param {Array} array\n     */\n    var tail = function (array) {\n      return array.slice(1);\n    };\n\n    /**\n     * returns item of array\n     */\n    var find = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        var item = array[idx];\n        if (pred(item)) {\n          return item;\n        }\n      }\n    };\n\n    /**\n     * returns true if all of the values in the array pass the predicate truth test.\n     */\n    var all = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!pred(array[idx])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    /**\n     * returns index of item\n     */\n    var indexOf = function (array, item) {\n      return $.inArray(item, array);\n    };\n\n    /**\n     * returns true if the value is present in the list.\n     */\n    var contains = function (array, item) {\n      return indexOf(array, item) !== -1;\n    };\n\n    /**\n     * get sum from a list\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - iterator\n     */\n    var sum = function (array, fn) {\n      fn = fn || func.self;\n      return array.reduce(function (memo, v) {\n        return memo + fn(v);\n      }, 0);\n    };\n  \n    /**\n     * returns a copy of the collection with array type.\n     * @param {Collection} collection - collection eg) node.childNodes, ...\n     */\n    var from = function (collection) {\n      var result = [], idx = -1, length = collection.length;\n      while (++idx < length) {\n        result[idx] = collection[idx];\n      }\n      return result;\n    };\n\n    /**\n     * returns whether list is empty or not\n     */\n    var isEmpty = function (array) {\n      return !array || !array.length;\n    };\n  \n    /**\n     * cluster elements by predicate function.\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     * @param {Array[]}\n     */\n    var clusterBy = function (array, fn) {\n      if (!array.length) { return []; }\n      var aTail = tail(array);\n      return aTail.reduce(function (memo, v) {\n        var aLast = last(memo);\n        if (fn(last(aLast), v)) {\n          aLast[aLast.length] = v;\n        } else {\n          memo[memo.length] = [v];\n        }\n        return memo;\n      }, [[head(array)]]);\n    };\n  \n    /**\n     * returns a copy of the array with all falsy values removed\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     */\n    var compact = function (array) {\n      var aResult = [];\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (array[idx]) { aResult.push(array[idx]); }\n      }\n      return aResult;\n    };\n\n    /**\n     * produces a duplicate-free version of the array\n     *\n     * @param {Array} array\n     */\n    var unique = function (array) {\n      var results = [];\n\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!contains(results, array[idx])) {\n          results.push(array[idx]);\n        }\n      }\n\n      return results;\n    };\n\n    /**\n     * returns next item.\n     * @param {Array} array\n     */\n    var next = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx + 1];\n    };\n\n    /**\n     * returns prev item.\n     * @param {Array} array\n     */\n    var prev = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx - 1];\n    };\n\n    return { head: head, last: last, initial: initial, tail: tail,\n             prev: prev, next: next, find: find, contains: contains,\n             all: all, sum: sum, from: from, isEmpty: isEmpty,\n             clusterBy: clusterBy, compact: compact, unique: unique };\n  })();\n\n  var isSupportAmd = typeof define === 'function' && define.amd;\n\n  /**\n   * returns whether font is installed or not.\n   *\n   * @param {String} fontName\n   * @return {Boolean}\n   */\n  var isFontInstalled = function (fontName) {\n    var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';\n    var $tester = $('<div>').css({\n      position: 'absolute',\n      left: '-9999px',\n      top: '-9999px',\n      fontSize: '200px'\n    }).text('mmmmmmmmmwwwwwww').appendTo(document.body);\n\n    var originalWidth = $tester.css('fontFamily', testFontName).width();\n    var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();\n\n    $tester.remove();\n\n    return originalWidth !== width;\n  };\n\n  var userAgent = navigator.userAgent;\n  var isMSIE = /MSIE|Trident/i.test(userAgent);\n  var browserVersion;\n  if (isMSIE) {\n    var matches = /MSIE (\\d+[.]\\d+)/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n    matches = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n  }\n\n  var isEdge = /Edge\\/\\d+/.test(userAgent);\n\n  var hasCodeMirror = !!window.CodeMirror;\n  if (!hasCodeMirror && isSupportAmd) {\n    try {\n      // If CodeMirror can't be resolved, `require.resolve` will throw an\n      // exception and `hasCodeMirror` won't be set to `true`.\n      require.resolve('codemirror');\n      hasCodeMirror = true;\n    } catch (e) {\n      hasCodeMirror = false;\n    }\n  }\n\n  /**\n   * @class core.agent\n   *\n   * Object which check platform and agent\n   *\n   * @singleton\n   * @alternateClassName agent\n   */\n  var agent = {\n    isMac: navigator.appVersion.indexOf('Mac') > -1,\n    isMSIE: isMSIE,\n    isEdge: isEdge,\n    isFF: !isEdge && /firefox/i.test(userAgent),\n    isPhantom: /PhantomJS/i.test(userAgent),\n    isWebkit: !isEdge && /webkit/i.test(userAgent),\n    isChrome: !isEdge && /chrome/i.test(userAgent),\n    isSafari: !isEdge && /safari/i.test(userAgent),\n    browserVersion: browserVersion,\n    jqueryVersion: parseFloat($.fn.jquery),\n    isSupportAmd: isSupportAmd,\n    hasCodeMirror: hasCodeMirror,\n    isFontInstalled: isFontInstalled,\n    isW3CRangeSupport: !!document.createRange\n  };\n\n\n  var NBSP_CHAR = String.fromCharCode(160);\n  var ZERO_WIDTH_NBSP_CHAR = '\\ufeff';\n\n  /**\n   * @class core.dom\n   *\n   * Dom functions\n   *\n   * @singleton\n   * @alternateClassName dom\n   */\n  var dom = (function () {\n    /**\n     * @method isEditable\n     *\n     * returns whether node is `note-editable` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEditable = function (node) {\n      return node && $(node).hasClass('note-editable');\n    };\n\n    /**\n     * @method isControlSizing\n     *\n     * returns whether node is `note-control-sizing` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isControlSizing = function (node) {\n      return node && $(node).hasClass('note-control-sizing');\n    };\n\n    /**\n     * @method makePredByNodeName\n     *\n     * returns predicate which judge whether nodeName is same\n     *\n     * @param {String} nodeName\n     * @return {Function}\n     */\n    var makePredByNodeName = function (nodeName) {\n      nodeName = nodeName.toUpperCase();\n      return function (node) {\n        return node && node.nodeName.toUpperCase() === nodeName;\n      };\n    };\n\n    /**\n     * @method isText\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is text(3)\n     */\n    var isText = function (node) {\n      return node && node.nodeType === 3;\n    };\n\n    /**\n     * @method isElement\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is element(1)\n     */\n    var isElement = function (node) {\n      return node && node.nodeType === 1;\n    };\n\n    /**\n     * ex) br, col, embed, hr, img, input, ...\n     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n     */\n    var isVoid = function (node) {\n      return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPara = function (node) {\n      if (isEditable(node)) {\n        return false;\n      }\n\n      // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph\n      return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHeading = function (node) {\n      return node && /^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPre = makePredByNodeName('PRE');\n\n    var isLi = makePredByNodeName('LI');\n\n    var isPurePara = function (node) {\n      return isPara(node) && !isLi(node);\n    };\n\n    var isTable = makePredByNodeName('TABLE');\n\n    var isInline = function (node) {\n      return !isBodyContainer(node) &&\n             !isList(node) &&\n             !isHr(node) &&\n             !isPara(node) &&\n             !isTable(node) &&\n             !isBlockquote(node);\n    };\n\n    var isList = function (node) {\n      return node && /^UL|^OL/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHr = makePredByNodeName('HR');\n\n    var isCell = function (node) {\n      return node && /^TD|^TH/.test(node.nodeName.toUpperCase());\n    };\n\n    var isBlockquote = makePredByNodeName('BLOCKQUOTE');\n\n    var isBodyContainer = function (node) {\n      return isCell(node) || isBlockquote(node) || isEditable(node);\n    };\n\n    var isAnchor = makePredByNodeName('A');\n\n    var isParaInline = function (node) {\n      return isInline(node) && !!ancestor(node, isPara);\n    };\n\n    var isBodyInline = function (node) {\n      return isInline(node) && !ancestor(node, isPara);\n    };\n\n    var isBody = makePredByNodeName('BODY');\n\n    /**\n     * returns whether nodeB is closest sibling of nodeA\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     * @return {Boolean}\n     */\n    var isClosestSibling = function (nodeA, nodeB) {\n      return nodeA.nextSibling === nodeB ||\n             nodeA.previousSibling === nodeB;\n    };\n\n    /**\n     * returns array of closest siblings with node\n     *\n     * @param {Node} node\n     * @param {function} [pred] - predicate function\n     * @return {Node[]}\n     */\n    var withClosestSiblings = function (node, pred) {\n      pred = pred || func.ok;\n\n      var siblings = [];\n      if (node.previousSibling && pred(node.previousSibling)) {\n        siblings.push(node.previousSibling);\n      }\n      siblings.push(node);\n      if (node.nextSibling && pred(node.nextSibling)) {\n        siblings.push(node.nextSibling);\n      }\n      return siblings;\n    };\n\n    /**\n     * blank HTML for cursor position\n     * - [workaround] old IE only works with &nbsp;\n     * - [workaround] IE11 and other browser works with bogus br\n     */\n    var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';\n\n    /**\n     * @method nodeLength\n     *\n     * returns #text's text size or element's childNodes size\n     *\n     * @param {Node} node\n     */\n    var nodeLength = function (node) {\n      if (isText(node)) {\n        return node.nodeValue.length;\n      }\n\n      return node.childNodes.length;\n    };\n\n    /**\n     * returns whether node is empty or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEmpty = function (node) {\n      var len = nodeLength(node);\n\n      if (len === 0) {\n        return true;\n      } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {\n        // ex) <p><br></p>, <span><br></span>\n        return true;\n      } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {\n        // ex) <p></p>, <span></span>\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * padding blankHTML if node is empty (for cursor position)\n     */\n    var paddingBlankHTML = function (node) {\n      if (!isVoid(node) && !nodeLength(node)) {\n        node.innerHTML = blankHTML;\n      }\n    };\n\n    /**\n     * find nearest ancestor predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var ancestor = function (node, pred) {\n      while (node) {\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * find nearest ancestor only single child blood line and predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var singleChildAncestor = function (node, pred) {\n      node = node.parentNode;\n\n      while (node) {\n        if (nodeLength(node) !== 1) { break; }\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * returns new array of ancestor nodes (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listAncestor = function (node, pred) {\n      pred = pred || func.fail;\n\n      var ancestors = [];\n      ancestor(node, function (el) {\n        if (!isEditable(el)) {\n          ancestors.push(el);\n        }\n\n        return pred(el);\n      });\n      return ancestors;\n    };\n\n    /**\n     * find farthest ancestor predicate hit\n     */\n    var lastAncestor = function (node, pred) {\n      var ancestors = listAncestor(node);\n      return list.last(ancestors.filter(pred));\n    };\n\n    /**\n     * returns common ancestor node between two nodes.\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n    var commonAncestor = function (nodeA, nodeB) {\n      var ancestors = listAncestor(nodeA);\n      for (var n = nodeB; n; n = n.parentNode) {\n        if ($.inArray(n, ancestors) > -1) { return n; }\n      }\n      return null; // difference document area\n    };\n\n    /**\n     * listing all previous siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listPrev = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.previousSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing next siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listNext = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.nextSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing descendant nodes\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listDescendant = function (node, pred) {\n      var descendants = [];\n      pred = pred || func.ok;\n\n      // start DFS(depth first search) with node\n      (function fnWalk(current) {\n        if (node !== current && pred(current)) {\n          descendants.push(current);\n        }\n        for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {\n          fnWalk(current.childNodes[idx]);\n        }\n      })(node);\n\n      return descendants;\n    };\n\n    /**\n     * wrap node with new tag.\n     *\n     * @param {Node} node\n     * @param {Node} tagName of wrapper\n     * @return {Node} - wrapper\n     */\n    var wrap = function (node, wrapperName) {\n      var parent = node.parentNode;\n      var wrapper = $('<' + wrapperName + '>')[0];\n\n      parent.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n\n      return wrapper;\n    };\n\n    /**\n     * insert node after preceding\n     *\n     * @param {Node} node\n     * @param {Node} preceding - predicate function\n     */\n    var insertAfter = function (node, preceding) {\n      var next = preceding.nextSibling, parent = preceding.parentNode;\n      if (next) {\n        parent.insertBefore(node, next);\n      } else {\n        parent.appendChild(node);\n      }\n      return node;\n    };\n\n    /**\n     * append elements.\n     *\n     * @param {Node} node\n     * @param {Collection} aChild\n     */\n    var appendChildNodes = function (node, aChild) {\n      $.each(aChild, function (idx, child) {\n        node.appendChild(child);\n      });\n      return node;\n    };\n\n    /**\n     * returns whether boundaryPoint is left edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isLeftEdgePoint = function (point) {\n      return point.offset === 0;\n    };\n\n    /**\n     * returns whether boundaryPoint is right edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isRightEdgePoint = function (point) {\n      return point.offset === nodeLength(point.node);\n    };\n\n    /**\n     * returns whether boundaryPoint is edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isEdgePoint = function (point) {\n      return isLeftEdgePoint(point) || isRightEdgePoint(point);\n    };\n\n    /**\n     * returns whether node is left edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== 0) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether node is right edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== nodeLength(node.parentNode) - 1) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether point is left edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgePointOf = function (point, ancestor) {\n      return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns whether point is right edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgePointOf = function (point, ancestor) {\n      return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns offset from parent.\n     *\n     * @param {Node} node\n     */\n    var position = function (node) {\n      var offset = 0;\n      while ((node = node.previousSibling)) {\n        offset += 1;\n      }\n      return offset;\n    };\n\n    var hasChildren = function (node) {\n      return !!(node && node.childNodes && node.childNodes.length);\n    };\n\n    /**\n     * returns previous boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var prevPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (point.offset === 0) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node);\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset - 1];\n        offset = nodeLength(node);\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? 0 : point.offset - 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns next boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var nextPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (nodeLength(point.node) === point.offset) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node) + 1;\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset];\n        offset = 0;\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns whether pointA and pointB is same or not.\n     *\n     * @param {BoundaryPoint} pointA\n     * @param {BoundaryPoint} pointB\n     * @return {Boolean}\n     */\n    var isSamePoint = function (pointA, pointB) {\n      return pointA.node === pointB.node && pointA.offset === pointB.offset;\n    };\n\n    /**\n     * returns whether point is visible (can set cursor) or not.\n     * \n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isVisiblePoint = function (point) {\n      if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {\n        return true;\n      }\n\n      var leftNode = point.node.childNodes[point.offset - 1];\n      var rightNode = point.node.childNodes[point.offset];\n      if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * @method prevPointUtil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var prevPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = prevPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * @method nextPointUntil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var nextPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = nextPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * returns whether point has character or not.\n     *\n     * @param {Point} point\n     * @return {Boolean}\n     */\n    var isCharPoint = function (point) {\n      if (!isText(point.node)) {\n        return false;\n      }\n\n      var ch = point.node.nodeValue.charAt(point.offset - 1);\n      return ch && (ch !== ' ' && ch !== NBSP_CHAR);\n    };\n\n    /**\n     * @method walkPoint\n     *\n     * @param {BoundaryPoint} startPoint\n     * @param {BoundaryPoint} endPoint\n     * @param {Function} handler\n     * @param {Boolean} isSkipInnerOffset\n     */\n    var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {\n      var point = startPoint;\n\n      while (point) {\n        handler(point);\n\n        if (isSamePoint(point, endPoint)) {\n          break;\n        }\n\n        var isSkipOffset = isSkipInnerOffset &&\n                           startPoint.node !== point.node &&\n                           endPoint.node !== point.node;\n        point = nextPoint(point, isSkipOffset);\n      }\n    };\n\n    /**\n     * @method makeOffsetPath\n     *\n     * return offsetPath(array of offset) from ancestor\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {Node} node\n     */\n    var makeOffsetPath = function (ancestor, node) {\n      var ancestors = listAncestor(node, func.eq(ancestor));\n      return ancestors.map(position).reverse();\n    };\n\n    /**\n     * @method fromOffsetPath\n     *\n     * return element from offsetPath(array of offset)\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {array} offsets - offsetPath\n     */\n    var fromOffsetPath = function (ancestor, offsets) {\n      var current = ancestor;\n      for (var i = 0, len = offsets.length; i < len; i++) {\n        if (current.childNodes.length <= offsets[i]) {\n          current = current.childNodes[current.childNodes.length - 1];\n        } else {\n          current = current.childNodes[offsets[i]];\n        }\n      }\n      return current;\n    };\n\n    /**\n     * @method splitNode\n     *\n     * split element or #text\n     *\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitNode = function (point, options) {\n      var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;\n      var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;\n\n      // edge case\n      if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {\n        if (isLeftEdgePoint(point)) {\n          return point.node;\n        } else if (isRightEdgePoint(point)) {\n          return point.node.nextSibling;\n        }\n      }\n\n      // split #text\n      if (isText(point.node)) {\n        return point.node.splitText(point.offset);\n      } else {\n        var childNode = point.node.childNodes[point.offset];\n        var clone = insertAfter(point.node.cloneNode(false), point.node);\n        appendChildNodes(clone, listNext(childNode));\n\n        if (!isSkipPaddingBlankHTML) {\n          paddingBlankHTML(point.node);\n          paddingBlankHTML(clone);\n        }\n\n        return clone;\n      }\n    };\n\n    /**\n     * @method splitTree\n     *\n     * split tree by point\n     *\n     * @param {Node} root - split root\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitTree = function (root, point, options) {\n      // ex) [#text, <span>, <p>]\n      var ancestors = listAncestor(point.node, func.eq(root));\n\n      if (!ancestors.length) {\n        return null;\n      } else if (ancestors.length === 1) {\n        return splitNode(point, options);\n      }\n\n      return ancestors.reduce(function (node, parent) {\n        if (node === point.node) {\n          node = splitNode(point, options);\n        }\n\n        return splitNode({\n          node: parent,\n          offset: node ? dom.position(node) : nodeLength(parent)\n        }, options);\n      });\n    };\n\n    /**\n     * split point\n     *\n     * @param {Point} point\n     * @param {Boolean} isInline\n     * @return {Object}\n     */\n    var splitPoint = function (point, isInline) {\n      // find splitRoot, container\n      //  - inline: splitRoot is a child of paragraph\n      //  - block: splitRoot is a child of bodyContainer\n      var pred = isInline ? isPara : isBodyContainer;\n      var ancestors = listAncestor(point.node, pred);\n      var topAncestor = list.last(ancestors) || point.node;\n\n      var splitRoot, container;\n      if (pred(topAncestor)) {\n        splitRoot = ancestors[ancestors.length - 2];\n        container = topAncestor;\n      } else {\n        splitRoot = topAncestor;\n        container = splitRoot.parentNode;\n      }\n\n      // if splitRoot is exists, split with splitTree\n      var pivot = splitRoot && splitTree(splitRoot, point, {\n        isSkipPaddingBlankHTML: isInline,\n        isNotSplitEdgePoint: isInline\n      });\n\n      // if container is point.node, find pivot with point.offset\n      if (!pivot && container === point.node) {\n        pivot = point.node.childNodes[point.offset];\n      }\n\n      return {\n        rightNode: pivot,\n        container: container\n      };\n    };\n\n    var create = function (nodeName) {\n      return document.createElement(nodeName);\n    };\n\n    var createText = function (text) {\n      return document.createTextNode(text);\n    };\n\n    /**\n     * @method remove\n     *\n     * remove node, (isRemoveChild: remove child or not)\n     *\n     * @param {Node} node\n     * @param {Boolean} isRemoveChild\n     */\n    var remove = function (node, isRemoveChild) {\n      if (!node || !node.parentNode) { return; }\n      if (node.removeNode) { return node.removeNode(isRemoveChild); }\n\n      var parent = node.parentNode;\n      if (!isRemoveChild) {\n        var nodes = [];\n        var i, len;\n        for (i = 0, len = node.childNodes.length; i < len; i++) {\n          nodes.push(node.childNodes[i]);\n        }\n\n        for (i = 0, len = nodes.length; i < len; i++) {\n          parent.insertBefore(nodes[i], node);\n        }\n      }\n\n      parent.removeChild(node);\n    };\n\n    /**\n     * @method removeWhile\n     *\n     * @param {Node} node\n     * @param {Function} pred\n     */\n    var removeWhile = function (node, pred) {\n      while (node) {\n        if (isEditable(node) || !pred(node)) {\n          break;\n        }\n\n        var parent = node.parentNode;\n        remove(node);\n        node = parent;\n      }\n    };\n\n    /**\n     * @method replace\n     *\n     * replace node with provided nodeName\n     *\n     * @param {Node} node\n     * @param {String} nodeName\n     * @return {Node} - new node\n     */\n    var replace = function (node, nodeName) {\n      if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {\n        return node;\n      }\n\n      var newNode = create(nodeName);\n\n      if (node.style.cssText) {\n        newNode.style.cssText = node.style.cssText;\n      }\n\n      appendChildNodes(newNode, list.from(node.childNodes));\n      insertAfter(newNode, node);\n      remove(node);\n\n      return newNode;\n    };\n\n    var isTextarea = makePredByNodeName('TEXTAREA');\n\n    /**\n     * @param {jQuery} $node\n     * @param {Boolean} [stripLinebreaks] - default: false\n     */\n    var value = function ($node, stripLinebreaks) {\n      var val = isTextarea($node[0]) ? $node.val() : $node.html();\n      if (stripLinebreaks) {\n        return val.replace(/[\\n\\r]/g, '');\n      }\n      return val;\n    };\n\n    /**\n     * @method html\n     *\n     * get the HTML contents of node\n     *\n     * @param {jQuery} $node\n     * @param {Boolean} [isNewlineOnBlock]\n     */\n    var html = function ($node, isNewlineOnBlock) {\n      var markup = value($node);\n\n      if (isNewlineOnBlock) {\n        var regexTag = /<(\\/?)(\\b(?!!)[^>\\s]*)(.*?)(\\s*\\/?>)/g;\n        markup = markup.replace(regexTag, function (match, endSlash, name) {\n          name = name.toUpperCase();\n          var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&\n                                       !!endSlash;\n          var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);\n\n          return match + ((isEndOfInlineContainer || isBlockNode) ? '\\n' : '');\n        });\n        markup = $.trim(markup);\n      }\n\n      return markup;\n    };\n\n    var posFromPlaceholder = function (placeholder) {\n      var $placeholder = $(placeholder);\n      var pos = $placeholder.offset();\n      var height = $placeholder.outerHeight(true); // include margin\n\n      return {\n        left: pos.left,\n        top: pos.top + height\n      };\n    };\n\n    var attachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.on(key, events[key]);\n      });\n    };\n\n    var detachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.off(key, events[key]);\n      });\n    };\n\n    return {\n      /** @property {String} NBSP_CHAR */\n      NBSP_CHAR: NBSP_CHAR,\n      /** @property {String} ZERO_WIDTH_NBSP_CHAR */\n      ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,\n      /** @property {String} blank */\n      blank: blankHTML,\n      /** @property {String} emptyPara */\n      emptyPara: '<p>' + blankHTML + '</p>',\n      makePredByNodeName: makePredByNodeName,\n      isEditable: isEditable,\n      isControlSizing: isControlSizing,\n      isText: isText,\n      isElement: isElement,\n      isVoid: isVoid,\n      isPara: isPara,\n      isPurePara: isPurePara,\n      isHeading: isHeading,\n      isInline: isInline,\n      isBlock: func.not(isInline),\n      isBodyInline: isBodyInline,\n      isBody: isBody,\n      isParaInline: isParaInline,\n      isPre: isPre,\n      isList: isList,\n      isTable: isTable,\n      isCell: isCell,\n      isBlockquote: isBlockquote,\n      isBodyContainer: isBodyContainer,\n      isAnchor: isAnchor,\n      isDiv: makePredByNodeName('DIV'),\n      isLi: isLi,\n      isBR: makePredByNodeName('BR'),\n      isSpan: makePredByNodeName('SPAN'),\n      isB: makePredByNodeName('B'),\n      isU: makePredByNodeName('U'),\n      isS: makePredByNodeName('S'),\n      isI: makePredByNodeName('I'),\n      isImg: makePredByNodeName('IMG'),\n      isTextarea: isTextarea,\n      isEmpty: isEmpty,\n      isEmptyAnchor: func.and(isAnchor, isEmpty),\n      isClosestSibling: isClosestSibling,\n      withClosestSiblings: withClosestSiblings,\n      nodeLength: nodeLength,\n      isLeftEdgePoint: isLeftEdgePoint,\n      isRightEdgePoint: isRightEdgePoint,\n      isEdgePoint: isEdgePoint,\n      isLeftEdgeOf: isLeftEdgeOf,\n      isRightEdgeOf: isRightEdgeOf,\n      isLeftEdgePointOf: isLeftEdgePointOf,\n      isRightEdgePointOf: isRightEdgePointOf,\n      prevPoint: prevPoint,\n      nextPoint: nextPoint,\n      isSamePoint: isSamePoint,\n      isVisiblePoint: isVisiblePoint,\n      prevPointUntil: prevPointUntil,\n      nextPointUntil: nextPointUntil,\n      isCharPoint: isCharPoint,\n      walkPoint: walkPoint,\n      ancestor: ancestor,\n      singleChildAncestor: singleChildAncestor,\n      listAncestor: listAncestor,\n      lastAncestor: lastAncestor,\n      listNext: listNext,\n      listPrev: listPrev,\n      listDescendant: listDescendant,\n      commonAncestor: commonAncestor,\n      wrap: wrap,\n      insertAfter: insertAfter,\n      appendChildNodes: appendChildNodes,\n      position: position,\n      hasChildren: hasChildren,\n      makeOffsetPath: makeOffsetPath,\n      fromOffsetPath: fromOffsetPath,\n      splitTree: splitTree,\n      splitPoint: splitPoint,\n      create: create,\n      createText: createText,\n      remove: remove,\n      removeWhile: removeWhile,\n      replace: replace,\n      html: html,\n      value: value,\n      posFromPlaceholder: posFromPlaceholder,\n      attachEvents: attachEvents,\n      detachEvents: detachEvents\n    };\n  })();\n\n  /**\n   * @param {jQuery} $note\n   * @param {Object} options\n   * @return {Context}\n   */\n  var Context = function ($note, options) {\n    var self = this;\n\n    var ui = $.summernote.ui;\n    this.memos = {};\n    this.modules = {};\n    this.layoutInfo = {};\n    this.options = options;\n\n    /**\n     * create layout and initialize modules and other resources\n     */\n    this.initialize = function () {\n      this.layoutInfo = ui.createLayout($note, options);\n      this._initialize();\n      $note.hide();\n      return this;\n    };\n\n    /**\n     * destroy modules and other resources and remove layout\n     */\n    this.destroy = function () {\n      this._destroy();\n      $note.removeData('summernote');\n      ui.removeLayout($note, this.layoutInfo);\n    };\n\n    /**\n     * destory modules and other resources and initialize it again\n     */\n    this.reset = function () {\n      var disabled = self.isDisabled();\n      this.code(dom.emptyPara);\n      this._destroy();\n      this._initialize();\n\n      if (disabled) {\n        self.disable();\n      }\n    };\n\n    this._initialize = function () {\n      // add optional buttons\n      var buttons = $.extend({}, this.options.buttons);\n      Object.keys(buttons).forEach(function (key) {\n        self.memo('button.' + key, buttons[key]);\n      });\n\n      var modules = $.extend({}, this.options.modules, $.summernote.plugins || {});\n\n      // add and initialize modules\n      Object.keys(modules).forEach(function (key) {\n        self.module(key, modules[key], true);\n      });\n\n      Object.keys(this.modules).forEach(function (key) {\n        self.initializeModule(key);\n      });\n    };\n\n    this._destroy = function () {\n      // destroy modules with reversed order\n      Object.keys(this.modules).reverse().forEach(function (key) {\n        self.removeModule(key);\n      });\n\n      Object.keys(this.memos).forEach(function (key) {\n        self.removeMemo(key);\n      });\n    };\n\n    this.code = function (html) {\n      var isActivated = this.invoke('codeview.isActivated');\n\n      if (html === undefined) {\n        this.invoke('codeview.sync');\n        return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();\n      } else {\n        if (isActivated) {\n          this.layoutInfo.codable.val(html);\n        } else {\n          this.layoutInfo.editable.html(html);\n        }\n        $note.val(html);\n        this.triggerEvent('change', html);\n      }\n    };\n\n    this.isDisabled = function () {\n      return this.layoutInfo.editable.attr('contenteditable') === 'false';\n    };\n\n    this.enable = function () {\n      this.layoutInfo.editable.attr('contenteditable', true);\n      this.invoke('toolbar.activate', true);\n    };\n\n    this.disable = function () {\n      // close codeview if codeview is opend\n      if (this.invoke('codeview.isActivated')) {\n        this.invoke('codeview.deactivate');\n      }\n      this.layoutInfo.editable.attr('contenteditable', false);\n      this.invoke('toolbar.deactivate', true);\n    };\n\n    this.triggerEvent = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];\n      if (callback) {\n        callback.apply($note[0], args);\n      }\n      $note.trigger('summernote.' + namespace, args);\n    };\n\n    this.initializeModule = function (key) {\n      var module = this.modules[key];\n      module.shouldInitialize = module.shouldInitialize || func.ok;\n      if (!module.shouldInitialize()) {\n        return;\n      }\n\n      // initialize module\n      if (module.initialize) {\n        module.initialize();\n      }\n\n      // attach events\n      if (module.events) {\n        dom.attachEvents($note, module.events);\n      }\n    };\n\n    this.module = function (key, ModuleClass, withoutIntialize) {\n      if (arguments.length === 1) {\n        return this.modules[key];\n      }\n\n      this.modules[key] = new ModuleClass(this);\n\n      if (!withoutIntialize) {\n        this.initializeModule(key);\n      }\n    };\n\n    this.removeModule = function (key) {\n      var module = this.modules[key];\n      if (module.shouldInitialize()) {\n        if (module.events) {\n          dom.detachEvents($note, module.events);\n        }\n\n        if (module.destroy) {\n          module.destroy();\n        }\n      }\n\n      delete this.modules[key];\n    };\n\n    this.memo = function (key, obj) {\n      if (arguments.length === 1) {\n        return this.memos[key];\n      }\n      this.memos[key] = obj;\n    };\n\n    this.removeMemo = function (key) {\n      if (this.memos[key] && this.memos[key].destroy) {\n        this.memos[key].destroy();\n      }\n\n      delete this.memos[key];\n    };\n\n    this.createInvokeHandler = function (namespace, value) {\n      return function (event) {\n        event.preventDefault();\n        self.invoke(namespace, value || $(event.target).closest('[data-value]').data('value'));\n      };\n    };\n\n    this.invoke = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var splits = namespace.split('.');\n      var hasSeparator = splits.length > 1;\n      var moduleName = hasSeparator && list.head(splits);\n      var methodName = hasSeparator ? list.last(splits) : list.head(splits);\n\n      var module = this.modules[moduleName || 'editor'];\n      if (!moduleName && this[methodName]) {\n        return this[methodName].apply(this, args);\n      } else if (module && module[methodName] && module.shouldInitialize()) {\n        return module[methodName].apply(module, args);\n      }\n    };\n\n    return this.initialize();\n  };\n\n  $.fn.extend({\n    /**\n     * Summernote API\n     *\n     * @param {Object|String}\n     * @return {this}\n     */\n    summernote: function () {\n      var type = $.type(list.head(arguments));\n      var isExternalAPICalled = type === 'string';\n      var hasInitOptions = type === 'object';\n\n      var options = hasInitOptions ? list.head(arguments) : {};\n\n      options = $.extend({}, $.summernote.options, options);\n      options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);\n\n      this.each(function (idx, note) {\n        var $note = $(note);\n        if (!$note.data('summernote')) {\n          var context = new Context($note, options);\n          $note.data('summernote', context);\n          $note.data('summernote').triggerEvent('init', context.layoutInfo);\n        }\n      });\n\n      var $note = this.first();\n      if ($note.length) {\n        var context = $note.data('summernote');\n        if (isExternalAPICalled) {\n          return context.invoke.apply(context, list.from(arguments));\n        } else if (options.focus) {\n          context.invoke('editor.focus');\n        }\n      }\n\n      return this;\n    }\n  });\n\n\n  var Renderer = function (markup, children, options, callback) {\n    this.render = function ($parent) {\n      var $node = $(markup);\n\n      if (options && options.contents) {\n        $node.html(options.contents);\n      }\n\n      if (options && options.className) {\n        $node.addClass(options.className);\n      }\n\n      if (options && options.data) {\n        $.each(options.data, function (k, v) {\n          $node.attr('data-' + k, v);\n        });\n      }\n\n      if (options && options.click) {\n        $node.on('click', options.click);\n      }\n\n      if (children) {\n        var $container = $node.find('.note-children-container');\n        children.forEach(function (child) {\n          child.render($container.length ? $container : $node);\n        });\n      }\n\n      if (callback) {\n        callback($node, options);\n      }\n\n      if (options && options.callback) {\n        options.callback($node);\n      }\n\n      if ($parent) {\n        $parent.append($node);\n      }\n\n      return $node;\n    };\n  };\n\n  var renderer = {\n    create: function (markup, callback) {\n      return function () {\n        var children = $.isArray(arguments[0]) ? arguments[0] : [];\n        var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];\n        if (options && options.children) {\n          children = options.children;\n        }\n        return new Renderer(markup, children, options, callback);\n      };\n    }\n  };\n\n  var editor = renderer.create('<div class=\"note-editor note-frame panel panel-default\"/>');\n  var toolbar = renderer.create('<div class=\"note-toolbar panel-heading\"/>');\n  var editingArea = renderer.create('<div class=\"note-editing-area\"/>');\n  var codable = renderer.create('<textarea class=\"note-codable\"/>');\n  var editable = renderer.create('<div class=\"note-editable panel-body\" contentEditable=\"true\"/>');\n  var statusbar = renderer.create([\n    '<div class=\"note-statusbar\">',\n    '  <div class=\"note-resizebar\">',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '  </div>',\n    '</div>'\n  ].join(''));\n\n  var airEditor = renderer.create('<div class=\"note-editor\"/>');\n  var airEditable = renderer.create('<div class=\"note-editable\" contentEditable=\"true\"/>');\n\n  var buttonGroup = renderer.create('<div class=\"note-btn-group btn-group\">');\n  var button = renderer.create('<button type=\"button\" class=\"note-btn btn btn-default btn-sm\">', function ($node, options) {\n    if (options && options.tooltip) {\n      $node.attr({\n        title: options.tooltip\n      }).tooltip({\n        container: 'body',\n        trigger: 'hover',\n        placement: 'bottom'\n      });\n    }\n  });\n\n  var dropdown = renderer.create('<div class=\"dropdown-menu\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + content + '</a></li>';\n    }).join('') : options.items;\n\n    $node.html(markup);\n  });\n\n  var dropdownCheck = renderer.create('<div class=\"dropdown-menu note-check\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + icon(options.checkClassName) + ' ' + content + '</a></li>';\n    }).join('') : options.items;\n    $node.html(markup);\n  });\n\n  var palette = renderer.create('<div class=\"note-color-palette\"/>', function ($node, options) {\n    var contents = [];\n    for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {\n      var eventName = options.eventName;\n      var colors = options.colors[row];\n      var buttons = [];\n      for (var col = 0, colSize = colors.length; col < colSize; col++) {\n        var color = colors[col];\n        buttons.push([\n          '<button type=\"button\" class=\"note-color-btn\"',\n          'style=\"background-color:', color, '\" ',\n          'data-event=\"', eventName, '\" ',\n          'data-value=\"', color, '\" ',\n          'title=\"', color, '\" ',\n          'data-toggle=\"button\" tabindex=\"-1\"></button>'\n        ].join(''));\n      }\n      contents.push('<div class=\"note-color-row\">' + buttons.join('') + '</div>');\n    }\n    $node.html(contents.join(''));\n\n    $node.find('.note-color-btn').tooltip({\n      container: 'body',\n      trigger: 'hover',\n      placement: 'bottom'\n    });\n  });\n\n  var dialog = renderer.create('<div class=\"modal\" aria-hidden=\"false\" tabindex=\"-1\"/>', function ($node, options) {\n    if (options.fade) {\n      $node.addClass('fade');\n    }\n    $node.html([\n      '<div class=\"modal-dialog\">',\n      '  <div class=\"modal-content\">',\n      (options.title ?\n      '    <div class=\"modal-header\">' +\n      '      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>' +\n      '      <h4 class=\"modal-title\">' + options.title + '</h4>' +\n      '    </div>' : ''\n      ),\n      '    <div class=\"modal-body\">' + options.body + '</div>',\n      (options.footer ?\n      '    <div class=\"modal-footer\">' + options.footer + '</div>' : ''\n      ),\n      '  </div>',\n      '</div>'\n    ].join(''));\n  });\n\n  var popover = renderer.create([\n    '<div class=\"note-popover popover in\">',\n    '  <div class=\"arrow\"/>',\n    '  <div class=\"popover-content note-children-container\"/>',\n    '</div>'\n  ].join(''), function ($node, options) {\n    var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';\n\n    $node.addClass(direction);\n\n    if (options.hideArrow) {\n      $node.find('.arrow').hide();\n    }\n  });\n\n  var icon = function (iconClassName, tagName) {\n    tagName = tagName || 'i';\n    return '<' + tagName + ' class=\"' + iconClassName + '\"/>';\n  };\n\n  var ui = {\n    editor: editor,\n    toolbar: toolbar,\n    editingArea: editingArea,\n    codable: codable,\n    editable: editable,\n    statusbar: statusbar,\n    airEditor: airEditor,\n    airEditable: airEditable,\n    buttonGroup: buttonGroup,\n    button: button,\n    dropdown: dropdown,\n    dropdownCheck: dropdownCheck,\n    palette: palette,\n    dialog: dialog,\n    popover: popover,\n    icon: icon,\n\n    toggleBtn: function ($btn, isEnable) {\n      $btn.toggleClass('disabled', !isEnable);\n      $btn.attr('disabled', !isEnable);\n    },\n\n    toggleBtnActive: function ($btn, isActive) {\n      $btn.toggleClass('active', isActive);\n    },\n\n    onDialogShown: function ($dialog, handler) {\n      $dialog.one('shown.bs.modal', handler);\n    },\n\n    onDialogHidden: function ($dialog, handler) {\n      $dialog.one('hidden.bs.modal', handler);\n    },\n\n    showDialog: function ($dialog) {\n      $dialog.modal('show');\n    },\n\n    hideDialog: function ($dialog) {\n      $dialog.modal('hide');\n    },\n\n    createLayout: function ($note, options) {\n      var $editor = (options.airMode ? ui.airEditor([\n        ui.editingArea([\n          ui.airEditable()\n        ])\n      ]) : ui.editor([\n        ui.toolbar(),\n        ui.editingArea([\n          ui.codable(),\n          ui.editable()\n        ]),\n        ui.statusbar()\n      ])).render();\n\n      $editor.insertAfter($note);\n\n      return {\n        note: $note,\n        editor: $editor,\n        toolbar: $editor.find('.note-toolbar'),\n        editingArea: $editor.find('.note-editing-area'),\n        editable: $editor.find('.note-editable'),\n        codable: $editor.find('.note-codable'),\n        statusbar: $editor.find('.note-statusbar')\n      };\n    },\n\n    removeLayout: function ($note, layoutInfo) {\n      $note.html(layoutInfo.editable.html());\n      layoutInfo.editor.remove();\n      $note.show();\n    }\n  };\n\n  $.summernote = $.summernote || {\n    lang: {}\n  };\n\n  $.extend($.summernote.lang, {\n    'en-US': {\n      font: {\n        bold: 'Bold',\n        italic: 'Italic',\n        underline: 'Underline',\n        clear: 'Remove Font Style',\n        height: 'Line Height',\n        name: 'Font Family',\n        strikethrough: 'Strikethrough',\n        subscript: 'Subscript',\n        superscript: 'Superscript',\n        size: 'Font Size'\n      },\n      image: {\n        image: 'Picture',\n        insert: 'Insert Image',\n        resizeFull: 'Resize Full',\n        resizeHalf: 'Resize Half',\n        resizeQuarter: 'Resize Quarter',\n        floatLeft: 'Float Left',\n        floatRight: 'Float Right',\n        floatNone: 'Float None',\n        shapeRounded: 'Shape: Rounded',\n        shapeCircle: 'Shape: Circle',\n        shapeThumbnail: 'Shape: Thumbnail',\n        shapeNone: 'Shape: None',\n        dragImageHere: 'Drag image or text here',\n        dropImage: 'Drop image or Text',\n        selectFromFiles: 'Select from files',\n        maximumFileSize: 'Maximum file size',\n        maximumFileSizeError: 'Maximum file size exceeded.',\n        url: 'Image URL',\n        remove: 'Remove Image'\n      },\n      video: {\n        video: 'Video',\n        videoLink: 'Video Link',\n        insert: 'Insert Video',\n        url: 'Video URL?',\n        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'\n      },\n      link: {\n        link: 'Link',\n        insert: 'Insert Link',\n        unlink: 'Unlink',\n        edit: 'Edit',\n        textToDisplay: 'Text to display',\n        url: 'To what URL should this link go?',\n        openInNewWindow: 'Open in new window'\n      },\n      table: {\n        table: 'Table'\n      },\n      hr: {\n        insert: 'Insert Horizontal Rule'\n      },\n      style: {\n        style: 'Style',\n        normal: 'Normal',\n        blockquote: 'Quote',\n        pre: 'Code',\n        h1: 'Header 1',\n        h2: 'Header 2',\n        h3: 'Header 3',\n        h4: 'Header 4',\n        h5: 'Header 5',\n        h6: 'Header 6'\n      },\n      lists: {\n        unordered: 'Unordered list',\n        ordered: 'Ordered list'\n      },\n      options: {\n        help: 'Help',\n        fullscreen: 'Full Screen',\n        codeview: 'Code View'\n      },\n      paragraph: {\n        paragraph: 'Paragraph',\n        outdent: 'Outdent',\n        indent: 'Indent',\n        left: 'Align left',\n        center: 'Align center',\n        right: 'Align right',\n        justify: 'Justify full'\n      },\n      color: {\n        recent: 'Recent Color',\n        more: 'More Color',\n        background: 'Background Color',\n        foreground: 'Foreground Color',\n        transparent: 'Transparent',\n        setTransparent: 'Set transparent',\n        reset: 'Reset',\n        resetToDefault: 'Reset to default'\n      },\n      shortcut: {\n        shortcuts: 'Keyboard shortcuts',\n        close: 'Close',\n        textFormatting: 'Text formatting',\n        action: 'Action',\n        paragraphFormatting: 'Paragraph formatting',\n        documentStyle: 'Document Style',\n        extraKeys: 'Extra keys'\n      },\n      help: {\n        'insertParagraph': 'Insert Paragraph',\n        'undo': 'Undoes the last command',\n        'redo': 'Redoes the last command',\n        'tab': 'Tab',\n        'untab': 'Untab',\n        'bold': 'Set a bold style',\n        'italic': 'Set a italic style',\n        'underline': 'Set a underline style',\n        'strikethrough': 'Set a strikethrough style',\n        'removeFormat': 'Clean a style',\n        'justifyLeft': 'Set left align',\n        'justifyCenter': 'Set center align',\n        'justifyRight': 'Set right align',\n        'justifyFull': 'Set full align',\n        'insertUnorderedList': 'Toggle unordered list',\n        'insertOrderedList': 'Toggle ordered list',\n        'outdent': 'Outdent on current paragraph',\n        'indent': 'Indent on current paragraph',\n        'formatPara': 'Change current block\\'s format as a paragraph(P tag)',\n        'formatH1': 'Change current block\\'s format as H1',\n        'formatH2': 'Change current block\\'s format as H2',\n        'formatH3': 'Change current block\\'s format as H3',\n        'formatH4': 'Change current block\\'s format as H4',\n        'formatH5': 'Change current block\\'s format as H5',\n        'formatH6': 'Change current block\\'s format as H6',\n        'insertHorizontalRule': 'Insert horizontal rule',\n        'linkDialog.show': 'Show Link Dialog'\n      },\n      history: {\n        undo: 'Undo',\n        redo: 'Redo'\n      },\n      specialChar: {\n        specialChar: 'SPECIAL CHARACTERS',\n        select: 'Select Special characters'\n      }\n    }\n  });\n\n\n  /**\n   * @class core.key\n   *\n   * Object for keycodes.\n   *\n   * @singleton\n   * @alternateClassName key\n   */\n  var key = (function () {\n    var keyMap = {\n      'BACKSPACE': 8,\n      'TAB': 9,\n      'ENTER': 13,\n      'SPACE': 32,\n\n      // Arrow\n      'LEFT': 37,\n      'UP': 38,\n      'RIGHT': 39,\n      'DOWN': 40,\n\n      // Number: 0-9\n      'NUM0': 48,\n      'NUM1': 49,\n      'NUM2': 50,\n      'NUM3': 51,\n      'NUM4': 52,\n      'NUM5': 53,\n      'NUM6': 54,\n      'NUM7': 55,\n      'NUM8': 56,\n\n      // Alphabet: a-z\n      'B': 66,\n      'E': 69,\n      'I': 73,\n      'J': 74,\n      'K': 75,\n      'L': 76,\n      'R': 82,\n      'S': 83,\n      'U': 85,\n      'V': 86,\n      'Y': 89,\n      'Z': 90,\n\n      'SLASH': 191,\n      'LEFTBRACKET': 219,\n      'BACKSLASH': 220,\n      'RIGHTBRACKET': 221\n    };\n\n    return {\n      /**\n       * @method isEdit\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isEdit: function (keyCode) {\n        return list.contains([\n          keyMap.BACKSPACE,\n          keyMap.TAB,\n          keyMap.ENTER,\n          keyMap.SPACE\n        ], keyCode);\n      },\n      /**\n       * @method isMove\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isMove: function (keyCode) {\n        return list.contains([\n          keyMap.LEFT,\n          keyMap.UP,\n          keyMap.RIGHT,\n          keyMap.DOWN\n        ], keyCode);\n      },\n      /**\n       * @property {Object} nameFromCode\n       * @property {String} nameFromCode.8 \"BACKSPACE\"\n       */\n      nameFromCode: func.invertObject(keyMap),\n      code: keyMap\n    };\n  })();\n\n  var range = (function () {\n\n    /**\n     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js\n     *\n     * @param {TextRange} textRange\n     * @param {Boolean} isStart\n     * @return {BoundaryPoint}\n     *\n     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx\n     */\n    var textRangeToPoint = function (textRange, isStart) {\n      var container = textRange.parentElement(), offset;\n  \n      var tester = document.body.createTextRange(), prevContainer;\n      var childNodes = list.from(container.childNodes);\n      for (offset = 0; offset < childNodes.length; offset++) {\n        if (dom.isText(childNodes[offset])) {\n          continue;\n        }\n        tester.moveToElementText(childNodes[offset]);\n        if (tester.compareEndPoints('StartToStart', textRange) >= 0) {\n          break;\n        }\n        prevContainer = childNodes[offset];\n      }\n  \n      if (offset !== 0 && dom.isText(childNodes[offset - 1])) {\n        var textRangeStart = document.body.createTextRange(), curTextNode = null;\n        textRangeStart.moveToElementText(prevContainer || container);\n        textRangeStart.collapse(!prevContainer);\n        curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;\n  \n        var pointTester = textRange.duplicate();\n        pointTester.setEndPoint('StartToStart', textRangeStart);\n        var textCount = pointTester.text.replace(/[\\r\\n]/g, '').length;\n  \n        while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        /* jshint ignore:start */\n        var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack\n        /* jshint ignore:end */\n  \n        if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&\n            textCount === curTextNode.nodeValue.length) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        container = curTextNode;\n        offset = textCount;\n      }\n  \n      return {\n        cont: container,\n        offset: offset\n      };\n    };\n    \n    /**\n     * return TextRange from boundary point (inspired by google closure-library)\n     * @param {BoundaryPoint} point\n     * @return {TextRange}\n     */\n    var pointToTextRange = function (point) {\n      var textRangeInfo = function (container, offset) {\n        var node, isCollapseToStart;\n  \n        if (dom.isText(container)) {\n          var prevTextNodes = dom.listPrev(container, func.not(dom.isText));\n          var prevContainer = list.last(prevTextNodes).previousSibling;\n          node =  prevContainer || container.parentNode;\n          offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);\n          isCollapseToStart = !prevContainer;\n        } else {\n          node = container.childNodes[offset] || container;\n          if (dom.isText(node)) {\n            return textRangeInfo(node, 0);\n          }\n  \n          offset = 0;\n          isCollapseToStart = false;\n        }\n  \n        return {\n          node: node,\n          collapseToStart: isCollapseToStart,\n          offset: offset\n        };\n      };\n  \n      var textRange = document.body.createTextRange();\n      var info = textRangeInfo(point.node, point.offset);\n  \n      textRange.moveToElementText(info.node);\n      textRange.collapse(info.collapseToStart);\n      textRange.moveStart('character', info.offset);\n      return textRange;\n    };\n    \n    /**\n     * Wrapped Range\n     *\n     * @constructor\n     * @param {Node} sc - start container\n     * @param {Number} so - start offset\n     * @param {Node} ec - end container\n     * @param {Number} eo - end offset\n     */\n    var WrappedRange = function (sc, so, ec, eo) {\n      this.sc = sc;\n      this.so = so;\n      this.ec = ec;\n      this.eo = eo;\n  \n      // nativeRange: get nativeRange from sc, so, ec, eo\n      var nativeRange = function () {\n        if (agent.isW3CRangeSupport) {\n          var w3cRange = document.createRange();\n          w3cRange.setStart(sc, so);\n          w3cRange.setEnd(ec, eo);\n\n          return w3cRange;\n        } else {\n          var textRange = pointToTextRange({\n            node: sc,\n            offset: so\n          });\n\n          textRange.setEndPoint('EndToEnd', pointToTextRange({\n            node: ec,\n            offset: eo\n          }));\n\n          return textRange;\n        }\n      };\n\n      this.getPoints = function () {\n        return {\n          sc: sc,\n          so: so,\n          ec: ec,\n          eo: eo\n        };\n      };\n\n      this.getStartPoint = function () {\n        return {\n          node: sc,\n          offset: so\n        };\n      };\n\n      this.getEndPoint = function () {\n        return {\n          node: ec,\n          offset: eo\n        };\n      };\n\n      /**\n       * select update visible range\n       */\n      this.select = function () {\n        var nativeRng = nativeRange();\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (selection.rangeCount > 0) {\n            selection.removeAllRanges();\n          }\n          selection.addRange(nativeRng);\n        } else {\n          nativeRng.select();\n        }\n        \n        return this;\n      };\n\n      /**\n       * Moves the scrollbar to start container(sc) of current range\n       *\n       * @return {WrappedRange}\n       */\n      this.scrollIntoView = function (container) {\n        var height = $(container).height();\n        if (container.scrollTop + height < this.sc.offsetTop) {\n          container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);\n        }\n\n        return this;\n      };\n\n      /**\n       * @return {WrappedRange}\n       */\n      this.normalize = function () {\n\n        /**\n         * @param {BoundaryPoint} point\n         * @param {Boolean} isLeftToRight\n         * @return {BoundaryPoint}\n         */\n        var getVisiblePoint = function (point, isLeftToRight) {\n          if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||\n              (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {\n            return point;\n          }\n\n          // point on block's edge\n          var block = dom.ancestor(point.node, dom.isBlock);\n          if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||\n              ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {\n\n            // returns point already on visible point\n            if (dom.isVisiblePoint(point)) {\n              return point;\n            }\n            // reverse direction \n            isLeftToRight = !isLeftToRight;\n          }\n\n          var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) :\n                                          dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);\n          return nextPoint || point;\n        };\n\n        var endPoint = getVisiblePoint(this.getEndPoint(), false);\n        var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n\n      /**\n       * returns matched nodes on range\n       *\n       * @param {Function} [pred] - predicate function\n       * @param {Object} [options]\n       * @param {Boolean} [options.includeAncestor]\n       * @param {Boolean} [options.fullyContains]\n       * @return {Node[]}\n       */\n      this.nodes = function (pred, options) {\n        pred = pred || func.ok;\n\n        var includeAncestor = options && options.includeAncestor;\n        var fullyContains = options && options.fullyContains;\n\n        // TODO compare points and sort\n        var startPoint = this.getStartPoint();\n        var endPoint = this.getEndPoint();\n\n        var nodes = [];\n        var leftEdgeNodes = [];\n\n        dom.walkPoint(startPoint, endPoint, function (point) {\n          if (dom.isEditable(point.node)) {\n            return;\n          }\n\n          var node;\n          if (fullyContains) {\n            if (dom.isLeftEdgePoint(point)) {\n              leftEdgeNodes.push(point.node);\n            }\n            if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {\n              node = point.node;\n            }\n          } else if (includeAncestor) {\n            node = dom.ancestor(point.node, pred);\n          } else {\n            node = point.node;\n          }\n\n          if (node && pred(node)) {\n            nodes.push(node);\n          }\n        }, true);\n\n        return list.unique(nodes);\n      };\n\n      /**\n       * returns commonAncestor of range\n       * @return {Element} - commonAncestor\n       */\n      this.commonAncestor = function () {\n        return dom.commonAncestor(sc, ec);\n      };\n\n      /**\n       * returns expanded range by pred\n       *\n       * @param {Function} pred - predicate function\n       * @return {WrappedRange}\n       */\n      this.expand = function (pred) {\n        var startAncestor = dom.ancestor(sc, pred);\n        var endAncestor = dom.ancestor(ec, pred);\n\n        if (!startAncestor && !endAncestor) {\n          return new WrappedRange(sc, so, ec, eo);\n        }\n\n        var boundaryPoints = this.getPoints();\n\n        if (startAncestor) {\n          boundaryPoints.sc = startAncestor;\n          boundaryPoints.so = 0;\n        }\n\n        if (endAncestor) {\n          boundaryPoints.ec = endAncestor;\n          boundaryPoints.eo = dom.nodeLength(endAncestor);\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * @param {Boolean} isCollapseToStart\n       * @return {WrappedRange}\n       */\n      this.collapse = function (isCollapseToStart) {\n        if (isCollapseToStart) {\n          return new WrappedRange(sc, so, sc, so);\n        } else {\n          return new WrappedRange(ec, eo, ec, eo);\n        }\n      };\n\n      /**\n       * splitText on range\n       */\n      this.splitText = function () {\n        var isSameContainer = sc === ec;\n        var boundaryPoints = this.getPoints();\n\n        if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {\n          ec.splitText(eo);\n        }\n\n        if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {\n          boundaryPoints.sc = sc.splitText(so);\n          boundaryPoints.so = 0;\n\n          if (isSameContainer) {\n            boundaryPoints.ec = boundaryPoints.sc;\n            boundaryPoints.eo = eo - so;\n          }\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * delete contents on range\n       * @return {WrappedRange}\n       */\n      this.deleteContents = function () {\n        if (this.isCollapsed()) {\n          return this;\n        }\n\n        var rng = this.splitText();\n        var nodes = rng.nodes(null, {\n          fullyContains: true\n        });\n\n        // find new cursor point\n        var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {\n          return !list.contains(nodes, point.node);\n        });\n\n        var emptyParents = [];\n        $.each(nodes, function (idx, node) {\n          // find empty parents\n          var parent = node.parentNode;\n          if (point.node !== parent && dom.nodeLength(parent) === 1) {\n            emptyParents.push(parent);\n          }\n          dom.remove(node, false);\n        });\n\n        // remove empty parents\n        $.each(emptyParents, function (idx, node) {\n          dom.remove(node, false);\n        });\n\n        return new WrappedRange(\n          point.node,\n          point.offset,\n          point.node,\n          point.offset\n        ).normalize();\n      };\n      \n      /**\n       * makeIsOn: return isOn(pred) function\n       */\n      var makeIsOn = function (pred) {\n        return function () {\n          var ancestor = dom.ancestor(sc, pred);\n          return !!ancestor && (ancestor === dom.ancestor(ec, pred));\n        };\n      };\n  \n      // isOnEditable: judge whether range is on editable or not\n      this.isOnEditable = makeIsOn(dom.isEditable);\n      // isOnList: judge whether range is on list node or not\n      this.isOnList = makeIsOn(dom.isList);\n      // isOnAnchor: judge whether range is on anchor node or not\n      this.isOnAnchor = makeIsOn(dom.isAnchor);\n      // isOnAnchor: judge whether range is on cell node or not\n      this.isOnCell = makeIsOn(dom.isCell);\n\n      /**\n       * @param {Function} pred\n       * @return {Boolean}\n       */\n      this.isLeftEdgeOf = function (pred) {\n        if (!dom.isLeftEdgePoint(this.getStartPoint())) {\n          return false;\n        }\n\n        var node = dom.ancestor(this.sc, pred);\n        return node && dom.isLeftEdgeOf(this.sc, node);\n      };\n\n      /**\n       * returns whether range was collapsed or not\n       */\n      this.isCollapsed = function () {\n        return sc === ec && so === eo;\n      };\n\n      /**\n       * wrap inline nodes which children of body with paragraph\n       *\n       * @return {WrappedRange}\n       */\n      this.wrapBodyInlineWithPara = function () {\n        if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {\n          sc.innerHTML = dom.emptyPara;\n          return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);\n        }\n\n        /**\n         * [workaround] firefox often create range on not visible point. so normalize here.\n         *  - firefox: |<p>text</p>|\n         *  - chrome: <p>|text|</p>\n         */\n        var rng = this.normalize();\n        if (dom.isParaInline(sc) || dom.isPara(sc)) {\n          return rng;\n        }\n\n        // find inline top ancestor\n        var topAncestor;\n        if (dom.isInline(rng.sc)) {\n          var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));\n          topAncestor = list.last(ancestors);\n          if (!dom.isInline(topAncestor)) {\n            topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];\n          }\n        } else {\n          topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];\n        }\n\n        // siblings not in paragraph\n        var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();\n        inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));\n\n        // wrap with paragraph\n        if (inlineSiblings.length) {\n          var para = dom.wrap(list.head(inlineSiblings), 'p');\n          dom.appendChildNodes(para, list.tail(inlineSiblings));\n        }\n\n        return this.normalize();\n      };\n\n      /**\n       * insert node at current cursor\n       *\n       * @param {Node} node\n       * @return {Node}\n       */\n      this.insertNode = function (node) {\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n        var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));\n\n        if (info.rightNode) {\n          info.rightNode.parentNode.insertBefore(node, info.rightNode);\n        } else {\n          info.container.appendChild(node);\n        }\n\n        return node;\n      };\n\n      /**\n       * insert html at current cursor\n       */\n      this.pasteHTML = function (markup) {\n        var contentsContainer = $('<div></div>').html(markup)[0];\n        var childNodes = list.from(contentsContainer.childNodes);\n\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n\n        return childNodes.reverse().map(function (childNode) {\n          return rng.insertNode(childNode);\n        }).reverse();\n      };\n  \n      /**\n       * returns text in range\n       *\n       * @return {String}\n       */\n      this.toString = function () {\n        var nativeRng = nativeRange();\n        return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;\n      };\n\n      /**\n       * returns range for word before cursor\n       *\n       * @param {Boolean} [findAfter] - find after cursor, default: false\n       * @return {WrappedRange}\n       */\n      this.getWordRange = function (findAfter) {\n        var endPoint = this.getEndPoint();\n\n        if (!dom.isCharPoint(endPoint)) {\n          return this;\n        }\n\n        var startPoint = dom.prevPointUntil(endPoint, function (point) {\n          return !dom.isCharPoint(point);\n        });\n\n        if (findAfter) {\n          endPoint = dom.nextPointUntil(endPoint, function (point) {\n            return !dom.isCharPoint(point);\n          });\n        }\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n  \n      /**\n       * create offsetPath bookmark\n       *\n       * @param {Node} editable\n       */\n      this.bookmark = function (editable) {\n        return {\n          s: {\n            path: dom.makeOffsetPath(editable, sc),\n            offset: so\n          },\n          e: {\n            path: dom.makeOffsetPath(editable, ec),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * create offsetPath bookmark base on paragraph\n       *\n       * @param {Node[]} paras\n       */\n      this.paraBookmark = function (paras) {\n        return {\n          s: {\n            path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),\n            offset: so\n          },\n          e: {\n            path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * getClientRects\n       * @return {Rect[]}\n       */\n      this.getClientRects = function () {\n        var nativeRng = nativeRange();\n        return nativeRng.getClientRects();\n      };\n    };\n\n  /**\n   * @class core.range\n   *\n   * Data structure\n   *  * BoundaryPoint: a point of dom tree\n   *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range\n   *\n   * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position\n   *\n   * @singleton\n   * @alternateClassName range\n   */\n    return {\n      /**\n       * create Range Object From arguments or Browser Selection\n       *\n       * @param {Node} sc - start container\n       * @param {Number} so - start offset\n       * @param {Node} ec - end container\n       * @param {Number} eo - end offset\n       * @return {WrappedRange}\n       */\n      create: function (sc, so, ec, eo) {\n        if (arguments.length === 4) {\n          return new WrappedRange(sc, so, ec, eo);\n        } else if (arguments.length === 2) { //collapsed\n          ec = sc;\n          eo = so;\n          return new WrappedRange(sc, so, ec, eo);\n        } else {\n          var wrappedRange = this.createFromSelection();\n          if (!wrappedRange && arguments.length === 1) {\n            wrappedRange = this.createFromNode(arguments[0]);\n            return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);\n          }\n          return wrappedRange;\n        }\n      },\n\n      createFromSelection: function () {\n        var sc, so, ec, eo;\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (!selection || selection.rangeCount === 0) {\n            return null;\n          } else if (dom.isBody(selection.anchorNode)) {\n            // Firefox: returns entire body as range on initialization.\n            // We won't never need it.\n            return null;\n          }\n\n          var nativeRng = selection.getRangeAt(0);\n          sc = nativeRng.startContainer;\n          so = nativeRng.startOffset;\n          ec = nativeRng.endContainer;\n          eo = nativeRng.endOffset;\n        } else { // IE8: TextRange\n          var textRange = document.selection.createRange();\n          var textRangeEnd = textRange.duplicate();\n          textRangeEnd.collapse(false);\n          var textRangeStart = textRange;\n          textRangeStart.collapse(true);\n\n          var startPoint = textRangeToPoint(textRangeStart, true),\n          endPoint = textRangeToPoint(textRangeEnd, false);\n\n          // same visible point case: range was collapsed.\n          if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&\n              dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&\n              endPoint.node.nextSibling === startPoint.node) {\n            startPoint = endPoint;\n          }\n\n          sc = startPoint.cont;\n          so = startPoint.offset;\n          ec = endPoint.cont;\n          eo = endPoint.offset;\n        }\n\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from node\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNode: function (node) {\n        var sc = node;\n        var so = 0;\n        var ec = node;\n        var eo = dom.nodeLength(ec);\n\n        // browsers can't target a picture or void node\n        if (dom.isVoid(sc)) {\n          so = dom.listPrev(sc).length - 1;\n          sc = sc.parentNode;\n        }\n        if (dom.isBR(ec)) {\n          eo = dom.listPrev(ec).length - 1;\n          ec = ec.parentNode;\n        } else if (dom.isVoid(ec)) {\n          eo = dom.listPrev(ec).length;\n          ec = ec.parentNode;\n        }\n\n        return this.create(sc, so, ec, eo);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeBefore: function (node) {\n        return this.createFromNode(node).collapse(true);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeAfter: function (node) {\n        return this.createFromNode(node).collapse();\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from bookmark\n       *\n       * @param {Node} editable\n       * @param {Object} bookmark\n       * @return {WrappedRange}\n       */\n      createFromBookmark: function (editable, bookmark) {\n        var sc = dom.fromOffsetPath(editable, bookmark.s.path);\n        var so = bookmark.s.offset;\n        var ec = dom.fromOffsetPath(editable, bookmark.e.path);\n        var eo = bookmark.e.offset;\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       *\n       * create WrappedRange from paraBookmark\n       *\n       * @param {Object} bookmark\n       * @param {Node[]} paras\n       * @return {WrappedRange}\n       */\n      createFromParaBookmark: function (bookmark, paras) {\n        var so = bookmark.s.offset;\n        var eo = bookmark.e.offset;\n        var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);\n        var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);\n\n        return new WrappedRange(sc, so, ec, eo);\n      }\n    };\n  })();\n\n  /**\n   * @class core.async\n   *\n   * Async functions which returns `Promise`\n   *\n   * @singleton\n   * @alternateClassName async\n   */\n  var async = (function () {\n    /**\n     * @method readFileAsDataURL\n     *\n     * read contents of file as representing URL\n     *\n     * @param {File} file\n     * @return {Promise} - then: dataUrl\n     */\n    var readFileAsDataURL = function (file) {\n      return $.Deferred(function (deferred) {\n        $.extend(new FileReader(), {\n          onload: function (e) {\n            var dataURL = e.target.result;\n            deferred.resolve(dataURL);\n          },\n          onerror: function () {\n            deferred.reject(this);\n          }\n        }).readAsDataURL(file);\n      }).promise();\n    };\n  \n    /**\n     * @method createImage\n     *\n     * create `<image>` from url string\n     *\n     * @param {String} url\n     * @return {Promise} - then: $image\n     */\n    var createImage = function (url) {\n      return $.Deferred(function (deferred) {\n        var $img = $('<img>');\n\n        $img.one('load', function () {\n          $img.off('error abort');\n          deferred.resolve($img);\n        }).one('error abort', function () {\n          $img.off('load').detach();\n          deferred.reject($img);\n        }).css({\n          display: 'none'\n        }).appendTo(document.body).attr('src', url);\n      }).promise();\n    };\n\n    return {\n      readFileAsDataURL: readFileAsDataURL,\n      createImage: createImage\n    };\n  })();\n\n  /**\n   * @class editing.History\n   *\n   * Editor History\n   *\n   */\n  var History = function ($editable) {\n    var stack = [], stackOffset = -1;\n    var editable = $editable[0];\n\n    var makeSnapshot = function () {\n      var rng = range.create(editable);\n      var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};\n\n      return {\n        contents: $editable.html(),\n        bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)\n      };\n    };\n\n    var applySnapshot = function (snapshot) {\n      if (snapshot.contents !== null) {\n        $editable.html(snapshot.contents);\n      }\n      if (snapshot.bookmark !== null) {\n        range.createFromBookmark(editable, snapshot.bookmark).select();\n      }\n    };\n\n    /**\n    * @method rewind\n    * Rewinds the history stack back to the first snapshot taken.\n    * Leaves the stack intact, so that \"Redo\" can still be used.\n    */\n    this.rewind = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      // Return to the first available snapshot.\n      stackOffset = 0;\n\n      // Apply that snapshot.\n      applySnapshot(stack[stackOffset]);\n    };\n\n    /**\n    * @method reset\n    * Resets the history stack completely; reverting to an empty editor.\n    */\n    this.reset = function () {\n      // Clear the stack.\n      stack = [];\n\n      // Restore stackOffset to its original value.\n      stackOffset = -1;\n\n      // Clear the editable area.\n      $editable.html('');\n\n      // Record our first snapshot (of nothing).\n      this.recordUndo();\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      if (0 < stackOffset) {\n        stackOffset--;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      if (stack.length - 1 > stackOffset) {\n        stackOffset++;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * recorded undo\n     */\n    this.recordUndo = function () {\n      stackOffset++;\n\n      // Wash out stack after stackOffset\n      if (stack.length > stackOffset) {\n        stack = stack.slice(0, stackOffset);\n      }\n\n      // Create new snapshot and push it to the end\n      stack.push(makeSnapshot());\n    };\n  };\n\n  /**\n   * @class editing.Style\n   *\n   * Style\n   *\n   */\n  var Style = function () {\n    /**\n     * @method jQueryCSS\n     *\n     * [workaround] for old jQuery\n     * passing an array of style properties to .css()\n     * will result in an object of property-value pairs.\n     * (compability with version < 1.9)\n     *\n     * @private\n     * @param  {jQuery} $obj\n     * @param  {Array} propertyNames - An array of one or more CSS properties.\n     * @return {Object}\n     */\n    var jQueryCSS = function ($obj, propertyNames) {\n      if (agent.jqueryVersion < 1.9) {\n        var result = {};\n        $.each(propertyNames, function (idx, propertyName) {\n          result[propertyName] = $obj.css(propertyName);\n        });\n        return result;\n      }\n      return $obj.css.call($obj, propertyNames);\n    };\n\n    /**\n     * returns style object from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.fromNode = function ($node) {\n      var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];\n      var styleInfo = jQueryCSS($node, properties) || {};\n      styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);\n      return styleInfo;\n    };\n\n    /**\n     * paragraph level style\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} styleInfo\n     */\n    this.stylePara = function (rng, styleInfo) {\n      $.each(rng.nodes(dom.isPara, {\n        includeAncestor: true\n      }), function (idx, para) {\n        $(para).css(styleInfo);\n      });\n    };\n\n    /**\n     * insert and returns styleNodes on range.\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} [options] - options for styleNodes\n     * @param {String} [options.nodeName] - default: `SPAN`\n     * @param {Boolean} [options.expandClosestSibling] - default: `false`\n     * @param {Boolean} [options.onlyPartialContains] - default: `false`\n     * @return {Node[]}\n     */\n    this.styleNodes = function (rng, options) {\n      rng = rng.splitText();\n\n      var nodeName = options && options.nodeName || 'SPAN';\n      var expandClosestSibling = !!(options && options.expandClosestSibling);\n      var onlyPartialContains = !!(options && options.onlyPartialContains);\n\n      if (rng.isCollapsed()) {\n        return [rng.insertNode(dom.create(nodeName))];\n      }\n\n      var pred = dom.makePredByNodeName(nodeName);\n      var nodes = rng.nodes(dom.isText, {\n        fullyContains: true\n      }).map(function (text) {\n        return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);\n      });\n\n      if (expandClosestSibling) {\n        if (onlyPartialContains) {\n          var nodesInRange = rng.nodes();\n          // compose with partial contains predication\n          pred = func.and(pred, function (node) {\n            return list.contains(nodesInRange, node);\n          });\n        }\n\n        return nodes.map(function (node) {\n          var siblings = dom.withClosestSiblings(node, pred);\n          var head = list.head(siblings);\n          var tails = list.tail(siblings);\n          $.each(tails, function (idx, elem) {\n            dom.appendChildNodes(head, elem.childNodes);\n            dom.remove(elem);\n          });\n          return list.head(siblings);\n        });\n      } else {\n        return nodes;\n      }\n    };\n\n    /**\n     * get current style on cursor\n     *\n     * @param {WrappedRange} rng\n     * @return {Object} - object contains style properties.\n     */\n    this.current = function (rng) {\n      var $cont = $(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);\n      var styleInfo = this.fromNode($cont);\n\n      // document.queryCommandState for toggle state\n      // [workaround] prevent Firefox nsresult: \"0x80004005 (NS_ERROR_FAILURE)\"\n      try {\n        styleInfo = $.extend(styleInfo, {\n          'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',\n          'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',\n          'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',\n          'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',\n          'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',\n          'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal'\n        });\n      } catch (e) {}\n\n      // list-style-type to list-style(unordered, ordered)\n      if (!rng.isOnList()) {\n        styleInfo['list-style'] = 'none';\n      } else {\n        var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];\n        var isUnordered = $.inArray(styleInfo['list-style-type'], orderedTypes) > -1;\n        styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';\n      }\n\n      var para = dom.ancestor(rng.sc, dom.isPara);\n      if (para && para.style['line-height']) {\n        styleInfo['line-height'] = para.style.lineHeight;\n      } else {\n        var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);\n        styleInfo['line-height'] = lineHeight.toFixed(1);\n      }\n\n      styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);\n      styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);\n      styleInfo.range = rng;\n\n      return styleInfo;\n    };\n  };\n\n\n  /**\n   * @class editing.Bullet\n   *\n   * @alternateClassName Bullet\n   */\n  var Bullet = function () {\n    var self = this;\n\n    /**\n     * toggle ordered list\n     */\n    this.insertOrderedList = function (editable) {\n      this.toggleList('OL', editable);\n    };\n\n    /**\n     * toggle unordered list\n     */\n    this.insertUnorderedList = function (editable) {\n      this.toggleList('UL', editable);\n    };\n\n    /**\n     * indent\n     */\n    this.indent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.wrapList(paras, head.parentNode.nodeName);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              return (parseInt(val, 10) || 0) + 25;\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * outdent\n     */\n    this.outdent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.releaseList([paras]);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              val = (parseInt(val, 10) || 0);\n              return val > 25 ? val - 25 : '';\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * toggle list\n     *\n     * @param {String} listName - OL or UL\n     */\n    this.toggleList = function (listName, editable) {\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var bookmark = rng.paraBookmark(paras);\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      // paragraph to list\n      if (list.find(paras, dom.isPurePara)) {\n        var wrappedParas = [];\n        $.each(clustereds, function (idx, paras) {\n          wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));\n        });\n        paras = wrappedParas;\n      // list to paragraph or change list style\n      } else {\n        var diffLists = rng.nodes(dom.isList, {\n          includeAncestor: true\n        }).filter(function (listNode) {\n          return !$.nodeName(listNode, listName);\n        });\n\n        if (diffLists.length) {\n          $.each(diffLists, function (idx, listNode) {\n            dom.replace(listNode, listName);\n          });\n        } else {\n          paras = this.releaseList(clustereds, true);\n        }\n      }\n\n      range.createFromParaBookmark(bookmark, paras).select();\n    };\n\n    /**\n     * @param {Node[]} paras\n     * @param {String} listName\n     * @return {Node[]}\n     */\n    this.wrapList = function (paras, listName) {\n      var head = list.head(paras);\n      var last = list.last(paras);\n\n      var prevList = dom.isList(head.previousSibling) && head.previousSibling;\n      var nextList = dom.isList(last.nextSibling) && last.nextSibling;\n\n      var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);\n\n      // P to LI\n      paras = paras.map(function (para) {\n        return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;\n      });\n\n      // append to list(<ul>, <ol>)\n      dom.appendChildNodes(listNode, paras);\n\n      if (nextList) {\n        dom.appendChildNodes(listNode, list.from(nextList.childNodes));\n        dom.remove(nextList);\n      }\n\n      return paras;\n    };\n\n    /**\n     * @method releaseList\n     *\n     * @param {Array[]} clustereds\n     * @param {Boolean} isEscapseToBody\n     * @return {Node[]}\n     */\n    this.releaseList = function (clustereds, isEscapseToBody) {\n      var releasedParas = [];\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        var last = list.last(paras);\n\n        var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :\n                                         head.parentNode;\n        var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {\n          node: last.parentNode,\n          offset: dom.position(last) + 1\n        }, {\n          isSkipPaddingBlankHTML: true\n        }) : null;\n\n        var middleList = dom.splitTree(headList, {\n          node: head.parentNode,\n          offset: dom.position(head)\n        }, {\n          isSkipPaddingBlankHTML: true\n        });\n\n        paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :\n                                  list.from(middleList.childNodes).filter(dom.isLi);\n\n        // LI to P\n        if (isEscapseToBody || !dom.isList(headList.parentNode)) {\n          paras = paras.map(function (para) {\n            return dom.replace(para, 'P');\n          });\n        }\n\n        $.each(list.from(paras).reverse(), function (idx, para) {\n          dom.insertAfter(para, headList);\n        });\n\n        // remove empty lists\n        var rootLists = list.compact([headList, middleList, lastList]);\n        $.each(rootLists, function (idx, rootList) {\n          var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));\n          $.each(listNodes.reverse(), function (idx, listNode) {\n            if (!dom.nodeLength(listNode)) {\n              dom.remove(listNode, true);\n            }\n          });\n        });\n\n        releasedParas = releasedParas.concat(paras);\n      });\n\n      return releasedParas;\n    };\n  };\n\n\n  /**\n   * @class editing.Typing\n   *\n   * Typing\n   *\n   */\n  var Typing = function () {\n\n    // a Bullet instance to toggle lists off\n    var bullet = new Bullet();\n\n    /**\n     * insert tab\n     *\n     * @param {WrappedRange} rng\n     * @param {Number} tabsize\n     */\n    this.insertTab = function (rng, tabsize) {\n      var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));\n      rng = rng.deleteContents();\n      rng.insertNode(tab, true);\n\n      rng = range.create(tab, tabsize);\n      rng.select();\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = function (editable) {\n      var rng = range.create(editable);\n\n      // deleteContents on range.\n      rng = rng.deleteContents();\n\n      // Wrap range if it needs to be wrapped by paragraph\n      rng = rng.wrapBodyInlineWithPara();\n\n      // finding paragraph\n      var splitRoot = dom.ancestor(rng.sc, dom.isPara);\n\n      var nextPara;\n      // on paragraph: split paragraph\n      if (splitRoot) {\n        // if it is an empty line with li\n        if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {\n          // toogle UL/OL and escape\n          bullet.toggleList(splitRoot.parentNode.nodeName);\n          return;\n        // if it is an empty line with para on blockquote\n        } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {\n          // escape blockquote\n          dom.insertAfter(splitRoot, splitRoot.parentNode);\n          nextPara = splitRoot;\n        // if new line has content (not a line break)\n        } else {\n          nextPara = dom.splitTree(splitRoot, rng.getStartPoint());\n\n          var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);\n          emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));\n\n          $.each(emptyAnchors, function (idx, anchor) {\n            dom.remove(anchor);\n          });\n\n          // replace empty heading or pre with P tag\n          if ((dom.isHeading(nextPara) || dom.isPre(nextPara)) && dom.isEmpty(nextPara)) {\n            nextPara = dom.replace(nextPara, 'p');\n          }\n        }\n      // no paragraph: insert empty paragraph\n      } else {\n        var next = rng.sc.childNodes[rng.so];\n        nextPara = $(dom.emptyPara)[0];\n        if (next) {\n          rng.sc.insertBefore(nextPara, next);\n        } else {\n          rng.sc.appendChild(nextPara);\n        }\n      }\n\n      range.create(nextPara, 0).normalize().select().scrollIntoView(editable);\n    };\n  };\n\n  /**\n   * @class editing.Table\n   *\n   * Table\n   *\n   */\n  var Table = function () {\n    /**\n     * handle tab key\n     *\n     * @param {WrappedRange} rng\n     * @param {Boolean} isShift\n     */\n    this.tab = function (rng, isShift) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var table = dom.ancestor(cell, dom.isTable);\n      var cells = dom.listDescendant(table, dom.isCell);\n\n      var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);\n      if (nextCell) {\n        range.create(nextCell, 0).select();\n      }\n    };\n\n    /**\n     * create empty table element\n     *\n     * @param {Number} rowCount\n     * @param {Number} colCount\n     * @return {Node}\n     */\n    this.createTable = function (colCount, rowCount, options) {\n      var tds = [], tdHTML;\n      for (var idxCol = 0; idxCol < colCount; idxCol++) {\n        tds.push('<td>' + dom.blank + '</td>');\n      }\n      tdHTML = tds.join('');\n\n      var trs = [], trHTML;\n      for (var idxRow = 0; idxRow < rowCount; idxRow++) {\n        trs.push('<tr>' + tdHTML + '</tr>');\n      }\n      trHTML = trs.join('');\n      var $table = $('<table>' + trHTML + '</table>');\n      if (options && options.tableClassName) {\n        $table.addClass(options.tableClassName);\n      }\n\n      return $table[0];\n    };\n  };\n\n\n  var KEY_BOGUS = 'bogus';\n\n  /**\n   * @class Editor\n   */\n  var Editor = function (context) {\n    var self = this;\n\n    var $note = context.layoutInfo.note;\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var editable = $editable[0];\n    var lastRange = null;\n\n    var style = new Style();\n    var table = new Table();\n    var typing = new Typing();\n    var bullet = new Bullet();\n    var history = new History($editable);\n\n    this.initialize = function () {\n      // bind custom events\n      $editable.on('keydown', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          context.triggerEvent('enter', event);\n        }\n        context.triggerEvent('keydown', event);\n\n        if (options.shortcuts && !event.isDefaultPrevented()) {\n          self.handleKeyMap(event);\n        }\n      }).on('keyup', function (event) {\n        context.triggerEvent('keyup', event);\n      }).on('focus', function (event) {\n        context.triggerEvent('focus', event);\n      }).on('blur', function (event) {\n        context.triggerEvent('blur', event);\n      }).on('mousedown', function (event) {\n        context.triggerEvent('mousedown', event);\n      }).on('mouseup', function (event) {\n        context.triggerEvent('mouseup', event);\n      }).on('scroll', function (event) {\n        context.triggerEvent('scroll', event);\n      }).on('paste', function (event) {\n        context.triggerEvent('paste', event);\n      });\n\n      // init content before set event\n      $editable.html(dom.html($note) || dom.emptyPara);\n\n      // [workaround] IE doesn't have input events for contentEditable\n      // - see: https://goo.gl/4bfIvA\n      var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';\n      $editable.on(changeEventName, function () {\n        context.triggerEvent('change', $editable.html());\n      });\n\n      $editor.on('focusin', function (event) {\n        context.triggerEvent('focusin', event);\n      }).on('focusout', function (event) {\n        context.triggerEvent('focusout', event);\n      });\n\n      if (!options.airMode && options.height) {\n        this.setHeight(options.height);\n      }\n      if (!options.airMode && options.maxHeight) {\n        $editable.css('max-height', options.maxHeight);\n      }\n      if (!options.airMode && options.minHeight) {\n        $editable.css('min-height', options.minHeight);\n      }\n\n      history.recordUndo();\n    };\n\n    this.destroy = function () {\n      $editable.off();\n    };\n\n    this.handleKeyMap = function (event) {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      var keys = [];\n\n      if (event.metaKey) { keys.push('CMD'); }\n      if (event.ctrlKey && !event.altKey) { keys.push('CTRL'); }\n      if (event.shiftKey) { keys.push('SHIFT'); }\n\n      var keyName = key.nameFromCode[event.keyCode];\n      if (keyName) {\n        keys.push(keyName);\n      }\n\n      var eventName = keyMap[keys.join('+')];\n      if (eventName) {\n        event.preventDefault();\n        context.invoke(eventName);\n      } else if (key.isEdit(event.keyCode)) {\n        this.afterCommand();\n      }\n    };\n\n    /**\n     * create range\n     * @return {WrappedRange}\n     */\n    this.createRange = function () {\n      this.focus();\n      return range.create(editable);\n    };\n\n    /**\n     * saveRange\n     *\n     * save current range\n     *\n     * @param {Boolean} [thenCollapse=false]\n     */\n    this.saveRange = function (thenCollapse) {\n      lastRange = this.createRange();\n      if (thenCollapse) {\n        lastRange.collapse().select();\n      }\n    };\n\n    /**\n     * restoreRange\n     *\n     * restore lately range\n     */\n    this.restoreRange = function () {\n      if (lastRange) {\n        lastRange.select();\n        this.focus();\n      }\n    };\n\n    this.saveTarget = function (node) {\n      $editable.data('target', node);\n    };\n\n    this.clearTarget = function () {\n      $editable.removeData('target');\n    };\n\n    this.restoreTarget = function () {\n      return $editable.data('target');\n    };\n\n    /**\n     * currentStyle\n     *\n     * current style\n     * @return {Object|Boolean} unfocus\n     */\n    this.currentStyle = function () {\n      var rng = range.create();\n      if (rng) {\n        rng = rng.normalize();\n      }\n      return rng ? style.current(rng) : style.fromNode($editable);\n    };\n\n    /**\n     * style from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.styleFromNode = function ($node) {\n      return style.fromNode($node);\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.undo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.undo', lang.help.undo);\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.redo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.redo', lang.help.redo);\n\n    /**\n     * before command\n     */\n    var beforeCommand = this.beforeCommand = function () {\n      context.triggerEvent('before.command', $editable.html());\n      // keep focus on editable before command execution\n      self.focus();\n    };\n\n    /**\n     * after command\n     * @param {Boolean} isPreventTrigger\n     */\n    var afterCommand = this.afterCommand = function (isPreventTrigger) {\n      history.recordUndo();\n      if (!isPreventTrigger) {\n        context.triggerEvent('change', $editable.html());\n      }\n    };\n\n    /* jshint ignore:start */\n    // native commands(with execCommand), generate function for execCommand\n    var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',\n                    'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',\n                    'formatBlock', 'removeFormat',\n                    'backColor', 'foreColor', 'fontName'];\n\n    for (var idx = 0, len = commands.length; idx < len; idx ++) {\n      this[commands[idx]] = (function (sCmd) {\n        return function (value) {\n          beforeCommand();\n          document.execCommand(sCmd, false, value);\n          afterCommand(true);\n        };\n      })(commands[idx]);\n      context.memo('help.' + commands[idx], lang.help[commands[idx]]);\n    }\n    /* jshint ignore:end */\n\n    /**\n     * handle tab key\n     */\n    this.tab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng);\n      } else {\n        beforeCommand();\n        typing.insertTab(rng, options.tabSize);\n        afterCommand();\n      }\n    };\n    context.memo('help.tab', lang.help.tab);\n\n    /**\n     * handle shift+tab key\n     */\n    this.untab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng, true);\n      }\n    };\n    context.memo('help.untab', lang.help.untab);\n\n    /**\n     * run given function between beforeCommand and afterCommand\n     */\n    this.wrapCommand = function (fn) {\n      return function () {\n        beforeCommand();\n        fn.apply(self, arguments);\n        afterCommand();\n      };\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = this.wrapCommand(function () {\n      typing.insertParagraph(editable);\n    });\n    context.memo('help.insertParagraph', lang.help.insertParagraph);\n\n    this.insertOrderedList = this.wrapCommand(function () {\n      bullet.insertOrderedList(editable);\n    });\n    context.memo('help.insertOrderedList', lang.help.insertOrderedList);\n\n    this.insertUnorderedList = this.wrapCommand(function () {\n      bullet.insertUnorderedList(editable);\n    });\n    context.memo('help.insertUnorderedList', lang.help.insertUnorderedList);\n\n    this.indent = this.wrapCommand(function () {\n      bullet.indent(editable);\n    });\n    context.memo('help.indent', lang.help.indent);\n\n    this.outdent = this.wrapCommand(function () {\n      bullet.outdent(editable);\n    });\n    context.memo('help.outdent', lang.help.outdent);\n\n    /**\n     * insert image\n     *\n     * @param {String} src\n     * @param {String|Function} param\n     * @return {Promise}\n     */\n    this.insertImage = function (src, param) {\n      return async.createImage(src, param).then(function ($image) {\n        beforeCommand();\n\n        if (typeof param === 'function') {\n          param($image);\n        } else {\n          if (typeof param === 'string') {\n            $image.attr('data-filename', param);\n          }\n          $image.css('width', Math.min($editable.width(), $image.width()));\n        }\n\n        $image.show();\n        range.create(editable).insertNode($image[0]);\n        range.createFromNodeAfter($image[0]).select();\n        afterCommand();\n      }).fail(function (e) {\n        context.triggerEvent('image.upload.error', e);\n      });\n    };\n\n    /**\n     * insertImages\n     * @param {File[]} files\n     */\n    this.insertImages = function (files) {\n      $.each(files, function (idx, file) {\n        var filename = file.name;\n        if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {\n          context.triggerEvent('image.upload.error', lang.image.maximumFileSizeError);\n        } else {\n          async.readFileAsDataURL(file).then(function (dataURL) {\n            return self.insertImage(dataURL, filename);\n          }).fail(function () {\n            context.triggerEvent('image.upload.error');\n          });\n        }\n      });\n    };\n\n    /**\n     * insertImagesOrCallback\n     * @param {File[]} files\n     */\n    this.insertImagesOrCallback = function (files) {\n      var callbacks = options.callbacks;\n\n      // If onImageUpload options setted\n      if (callbacks.onImageUpload) {\n        context.triggerEvent('image.upload', files);\n      // else insert Image as dataURL\n      } else {\n        this.insertImages(files);\n      }\n    };\n\n    /**\n     * insertNode\n     * insert node\n     * @param {Node} node\n     */\n    this.insertNode = this.wrapCommand(function (node) {\n      var rng = this.createRange();\n      rng.insertNode(node);\n      range.createFromNodeAfter(node).select();\n    });\n\n    /**\n     * insert text\n     * @param {String} text\n     */\n    this.insertText = this.wrapCommand(function (text) {\n      var rng = this.createRange();\n      var textNode = rng.insertNode(dom.createText(text));\n      range.create(textNode, dom.nodeLength(textNode)).select();\n    });\n\n    /**\n     * return selected plain text\n     * @return {String} text\n     */\n    this.getSelectedText = function () {\n      var rng = this.createRange();\n\n      // if range on anchor, expand range with anchor\n      if (rng.isOnAnchor()) {\n        rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));\n      }\n\n      return rng.toString();\n    };\n\n    /**\n     * paste HTML\n     * @param {String} markup\n     */\n    this.pasteHTML = this.wrapCommand(function (markup) {\n      var contents = this.createRange().pasteHTML(markup);\n      range.createFromNodeAfter(list.last(contents)).select();\n    });\n\n    /**\n     * formatBlock\n     *\n     * @param {String} tagName\n     */\n    this.formatBlock = this.wrapCommand(function (tagName) {\n      // [workaround] for MSIE, IE need `<`\n      tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;\n      document.execCommand('FormatBlock', false, tagName);\n    });\n\n    this.formatPara = function () {\n      this.formatBlock('P');\n    };\n    context.memo('help.formatPara', lang.help.formatPara);\n\n    /* jshint ignore:start */\n    for (var idx = 1; idx <= 6; idx ++) {\n      this['formatH' + idx] = function (idx) {\n        return function () {\n          this.formatBlock('H' + idx);\n        };\n      }(idx);\n      context.memo('help.formatH'+idx, lang.help['formatH' + idx]);\n    };\n    /* jshint ignore:end */\n\n    /**\n     * fontSize\n     *\n     * @param {String} value - px\n     */\n    this.fontSize = function (value) {\n      var rng = this.createRange();\n\n      if (rng && rng.isCollapsed()) {\n        var spans = style.styleNodes(rng);\n        var firstSpan = list.head(spans);\n\n        $(spans).css({\n          'font-size': value + 'px'\n        });\n\n        // [workaround] added styled bogus span for style\n        //  - also bogus character needed for cursor position\n        if (firstSpan && !dom.nodeLength(firstSpan)) {\n          firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;\n          range.createFromNodeAfter(firstSpan.firstChild).select();\n          $editable.data(KEY_BOGUS, firstSpan);\n        }\n      } else {\n        beforeCommand();\n        $(style.styleNodes(rng)).css({\n          'font-size': value + 'px'\n        });\n        afterCommand();\n      }\n    };\n\n    /**\n     * insert horizontal rule\n     */\n    this.insertHorizontalRule = this.wrapCommand(function () {\n      var hrNode = this.createRange().insertNode(dom.create('HR'));\n      if (hrNode.nextSibling) {\n        range.create(hrNode.nextSibling, 0).normalize().select();\n      }\n    });\n    context.memo('help.insertHorizontalRule', lang.help.insertHorizontalRule);\n\n    /**\n     * remove bogus node and character\n     */\n    this.removeBogus = function () {\n      var bogusNode = $editable.data(KEY_BOGUS);\n      if (!bogusNode) {\n        return;\n      }\n\n      var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);\n\n      var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);\n      if (bogusCharIdx !== -1) {\n        textNode.deleteData(bogusCharIdx, 1);\n      }\n\n      if (dom.isEmpty(bogusNode)) {\n        dom.remove(bogusNode);\n      }\n\n      $editable.removeData(KEY_BOGUS);\n    };\n\n    /**\n     * lineHeight\n     * @param {String} value\n     */\n    this.lineHeight = this.wrapCommand(function (value) {\n      style.stylePara(this.createRange(), {\n        lineHeight: value\n      });\n    });\n\n    /**\n     * unlink\n     *\n     * @type command\n     */\n    this.unlink = function () {\n      var rng = this.createRange();\n      if (rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        rng = range.createFromNode(anchor);\n        rng.select();\n\n        beforeCommand();\n        document.execCommand('unlink');\n        afterCommand();\n      }\n    };\n\n    /**\n     * create link (command)\n     *\n     * @param {Object} linkInfo\n     */\n    this.createLink = this.wrapCommand(function (linkInfo) {\n      var linkUrl = linkInfo.url;\n      var linkText = linkInfo.text;\n      var isNewWindow = linkInfo.isNewWindow;\n      var rng = linkInfo.range || this.createRange();\n      var isTextChanged = rng.toString() !== linkText;\n\n      if (options.onCreateLink) {\n        linkUrl = options.onCreateLink(linkUrl);\n      }\n\n      var anchors = [];\n      if (isTextChanged) {\n        rng = rng.deleteContents();\n        var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);\n        anchors.push(anchor);\n      } else {\n        anchors = style.styleNodes(rng, {\n          nodeName: 'A',\n          expandClosestSibling: true,\n          onlyPartialContains: true\n        });\n      }\n\n      $.each(anchors, function (idx, anchor) {\n        $(anchor).attr('href', linkUrl);\n        if (isNewWindow) {\n          $(anchor).attr('target', '_blank');\n        } else {\n          $(anchor).removeAttr('target');\n        }\n      });\n\n      var startRange = range.createFromNodeBefore(list.head(anchors));\n      var startPoint = startRange.getStartPoint();\n      var endRange = range.createFromNodeAfter(list.last(anchors));\n      var endPoint = endRange.getEndPoint();\n\n      range.create(\n        startPoint.node,\n        startPoint.offset,\n        endPoint.node,\n        endPoint.offset\n      ).select();\n    });\n\n    /**\n     * returns link info\n     *\n     * @return {Object}\n     * @return {WrappedRange} return.range\n     * @return {String} return.text\n     * @return {Boolean} [return.isNewWindow=true]\n     * @return {String} [return.url=\"\"]\n     */\n    this.getLinkInfo = function () {\n      var rng = this.createRange().expand(dom.isAnchor);\n\n      // Get the first anchor on range(for edit).\n      var $anchor = $(list.head(rng.nodes(dom.isAnchor)));\n\n      return {\n        range: rng,\n        text: rng.toString(),\n        isNewWindow: $anchor.length ? $anchor.attr('target') === '_blank' : false,\n        url: $anchor.length ? $anchor.attr('href') : ''\n      };\n    };\n\n    /**\n     * setting color\n     *\n     * @param {Object} sObjColor  color code\n     * @param {String} sObjColor.foreColor foreground color\n     * @param {String} sObjColor.backColor background color\n     */\n    this.color = this.wrapCommand(function (colorInfo) {\n      var foreColor = colorInfo.foreColor;\n      var backColor = colorInfo.backColor;\n\n      if (foreColor) { document.execCommand('foreColor', false, foreColor); }\n      if (backColor) { document.execCommand('backColor', false, backColor); }\n    });\n\n    /**\n     * insert Table\n     *\n     * @param {String} dimension of table (ex : \"5x5\")\n     */\n    this.insertTable = this.wrapCommand(function (dim) {\n      var dimension = dim.split('x');\n\n      var rng = this.createRange().deleteContents();\n      rng.insertNode(table.createTable(dimension[0], dimension[1], options));\n    });\n\n    /**\n     * float me\n     *\n     * @param {String} value\n     */\n    this.floatMe = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css('float', value);\n    });\n\n    /**\n     * resize overlay element\n     * @param {String} value\n     */\n    this.resize = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css({\n        width: value * 100 + '%',\n        height: ''\n      });\n    });\n\n    /**\n     * @param {Position} pos\n     * @param {jQuery} $target - target element\n     * @param {Boolean} [bKeepRatio] - keep ratio\n     */\n    this.resizeTo = function (pos, $target, bKeepRatio) {\n      var imageSize;\n      if (bKeepRatio) {\n        var newRatio = pos.y / pos.x;\n        var ratio = $target.data('ratio');\n        imageSize = {\n          width: ratio > newRatio ? pos.x : pos.y / ratio,\n          height: ratio > newRatio ? pos.x * ratio : pos.y\n        };\n      } else {\n        imageSize = {\n          width: pos.x,\n          height: pos.y\n        };\n      }\n\n      $target.css(imageSize);\n    };\n\n    /**\n     * remove media object\n     */\n    this.removeMedia = this.wrapCommand(function () {\n      var $target = $(this.restoreTarget()).detach();\n      context.triggerEvent('media.delete', $target, $editable);\n    });\n\n    /**\n     * returns whether editable area has focus or not.\n     */\n    this.hasFocus = function () {\n      return $editable.is(':focus');\n    };\n\n    /**\n     * set focus\n     */\n    this.focus = function () {\n      // [workaround] Screen will move when page is scolled in IE.\n      //  - do focus when not focused\n      if (!this.hasFocus()) {\n        $editable.focus();\n      }\n    };\n\n    /**\n     * returns whether contents is empty or not.\n     * @return {Boolean}\n     */\n    this.isEmpty = function () {\n      return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();\n    };\n\n    /**\n     * Removes all contents and restores the editable instance to an _emptyPara_.\n     */\n    this.empty = function () {\n      context.invoke('code', dom.emptyPara);\n    };\n\n    /**\n     * set height for editable\n     */\n    this.setHeight = function (height) {\n      $editable.outerHeight(height);\n    };\n  };\n\n  var Clipboard = function (context) {\n    var self = this;\n\n    var $editable = context.layoutInfo.editable;\n\n    this.events = {\n      'summernote.keydown': function (we, e) {\n        if (self.needKeydownHook()) {\n          if ((e.ctrlKey || e.metaKey) && e.keyCode === key.code.V) {\n            context.invoke('editor.saveRange');\n            self.$paste.focus();\n\n            setTimeout(function () {\n              self.pasteByHook();\n            }, 0);\n          }\n        }\n      }\n    };\n\n    this.needKeydownHook = function () {\n      return (agent.isMSIE && agent.browserVersion > 10) || agent.isFF;\n    };\n\n    this.initialize = function () {\n      // [workaround] getting image from clipboard\n      //  - IE11 and Firefox: CTRL+v hook\n      //  - Webkit: event.clipboardData\n      if (this.needKeydownHook()) {\n        this.$paste = $('<div />').attr('contenteditable', true).css({\n          position: 'absolute',\n          left: -100000,\n          opacity: 0\n        });\n        $editable.before(this.$paste);\n\n        this.$paste.on('paste', function (event) {\n          context.triggerEvent('paste', event);\n        });\n      } else {\n        $editable.on('paste', this.pasteByEvent);\n      }\n    };\n\n    this.destroy = function () {\n      if (this.needKeydownHook()) {\n        this.$paste.remove();\n        this.$paste = null;\n      }\n    };\n\n    this.pasteByHook = function () {\n      var node = this.$paste[0].firstChild;\n\n      if (dom.isImg(node)) {\n        var dataURI = node.src;\n        var decodedData = atob(dataURI.split(',')[1]);\n        var array = new Uint8Array(decodedData.length);\n        for (var i = 0; i < decodedData.length; i++) {\n          array[i] = decodedData.charCodeAt(i);\n        }\n\n        var blob = new Blob([array], { type: 'image/png' });\n        blob.name = 'clipboard.png';\n\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n        context.invoke('editor.insertImagesOrCallback', [blob]);\n      } else {\n        var pasteContent = $('<div />').html(this.$paste.html()).html();\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n\n        if (pasteContent) {\n          context.invoke('editor.pasteHTML', pasteContent);\n        }\n      }\n\n      this.$paste.empty();\n    };\n\n    /**\n     * paste by clipboard event\n     *\n     * @param {Event} event\n     */\n    this.pasteByEvent = function (event) {\n      var clipboardData = event.originalEvent.clipboardData;\n      if (clipboardData && clipboardData.items && clipboardData.items.length) {\n        var item = list.head(clipboardData.items);\n        if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {\n          context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);\n        }\n        context.invoke('editor.afterCommand');\n      }\n    };\n  };\n\n  var Dropzone = function (context) {\n    var $document = $(document);\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var $dropzone = $([\n      '<div class=\"note-dropzone\">',\n      '  <div class=\"note-dropzone-message\"/>',\n      '</div>'\n    ].join('')).prependTo($editor);\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.initialize = function () {\n      if (options.disableDragAndDrop) {\n        // prevent default drop event\n        $document.on('drop', function (e) {\n          e.preventDefault();\n        });\n      } else {\n        this.attachDragAndDropEvent();\n      }\n    };\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.attachDragAndDropEvent = function () {\n      var collection = $(),\n          $dropzoneMessage = $dropzone.find('.note-dropzone-message');\n\n      // show dropzone on dragenter when dragging a object to document\n      // -but only if the editor is visible, i.e. has a positive width and height\n      $document.on('dragenter', function (e) {\n        var isCodeview = context.invoke('codeview.isActivated');\n        var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;\n        if (!isCodeview && !collection.length && hasEditorSize) {\n          $editor.addClass('dragover');\n          $dropzone.width($editor.width());\n          $dropzone.height($editor.height());\n          $dropzoneMessage.text(lang.image.dragImageHere);\n        }\n        collection = collection.add(e.target);\n      }).on('dragleave', function (e) {\n        collection = collection.not(e.target);\n        if (!collection.length) {\n          $editor.removeClass('dragover');\n        }\n      }).on('drop', function () {\n        collection = $();\n        $editor.removeClass('dragover');\n      });\n\n      // change dropzone's message on hover.\n      $dropzone.on('dragenter', function () {\n        $dropzone.addClass('hover');\n        $dropzoneMessage.text(lang.image.dropImage);\n      }).on('dragleave', function () {\n        $dropzone.removeClass('hover');\n        $dropzoneMessage.text(lang.image.dragImageHere);\n      });\n\n      // attach dropImage\n      $dropzone.on('drop', function (event) {\n        var dataTransfer = event.originalEvent.dataTransfer;\n\n        if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n          event.preventDefault();\n          $editable.focus();\n          context.invoke('editor.insertImagesOrCallback', dataTransfer.files);\n        } else {\n          $.each(dataTransfer.types, function (idx, type) {\n            var content = dataTransfer.getData(type);\n\n            if (type.toLowerCase().indexOf('text') > -1) {\n              context.invoke('editor.pasteHTML', content);\n            } else {\n              $(content).each(function () {\n                context.invoke('editor.insertNode', this);\n              });\n            }\n          });\n        }\n      }).on('dragover', false); // prevent default dragover event\n    };\n  };\n\n\n  var CodeMirror;\n  if (agent.hasCodeMirror) {\n    if (agent.isSupportAmd) {\n      require(['codemirror'], function (cm) {\n        CodeMirror = cm;\n      });\n    } else {\n      CodeMirror = window.CodeMirror;\n    }\n  }\n\n  /**\n   * @class Codeview\n   */\n  var Codeview = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n    var options = context.options;\n\n    this.sync = function () {\n      var isCodeview = this.isActivated();\n      if (isCodeview && agent.hasCodeMirror) {\n        $codable.data('cmEditor').save();\n      }\n    };\n\n    /**\n     * @return {Boolean}\n     */\n    this.isActivated = function () {\n      return $editor.hasClass('codeview');\n    };\n\n    /**\n     * toggle codeview\n     */\n    this.toggle = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n      context.triggerEvent('codeview.toggled');\n    };\n\n    /**\n     * activate code view\n     */\n    this.activate = function () {\n      $codable.val(dom.html($editable, options.prettifyHtml));\n      $codable.height($editable.height());\n\n      context.invoke('toolbar.updateCodeview', true);\n      $editor.addClass('codeview');\n      $codable.focus();\n\n      // activate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);\n\n        // CodeMirror TernServer\n        if (options.codemirror.tern) {\n          var server = new CodeMirror.TernServer(options.codemirror.tern);\n          cmEditor.ternServer = server;\n          cmEditor.on('cursorActivity', function (cm) {\n            server.updateArgHints(cm);\n          });\n        }\n\n        // CodeMirror hasn't Padding.\n        cmEditor.setSize(null, $editable.outerHeight());\n        $codable.data('cmEditor', cmEditor);\n      }\n    };\n\n    /**\n     * deactivate code view\n     */\n    this.deactivate = function () {\n      // deactivate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = $codable.data('cmEditor');\n        $codable.val(cmEditor.getValue());\n        cmEditor.toTextArea();\n      }\n\n      var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;\n      var isChange = $editable.html() !== value;\n\n      $editable.html(value);\n      $editable.height(options.height ? $codable.height() : 'auto');\n      $editor.removeClass('codeview');\n\n      if (isChange) {\n        context.triggerEvent('change', $editable.html(), $editable);\n      }\n\n      $editable.focus();\n\n      context.invoke('toolbar.updateCodeview', false);\n    };\n\n    this.destroy = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      }\n    };\n  };\n\n  var EDITABLE_PADDING = 24;\n\n  var Statusbar = function (context) {\n    var $document = $(document);\n    var $statusbar = context.layoutInfo.statusbar;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n\n    this.initialize = function () {\n      if (options.airMode || options.disableResizeEditor) {\n        return;\n      }\n\n      $statusbar.on('mousedown', function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        var editableTop = $editable.offset().top - $document.scrollTop();\n\n        $document.on('mousemove', function (event) {\n          var height = event.clientY - (editableTop + EDITABLE_PADDING);\n\n          height = (options.minheight > 0) ? Math.max(height, options.minheight) : height;\n          height = (options.maxHeight > 0) ? Math.min(height, options.maxHeight) : height;\n\n          $editable.height(height);\n        }).one('mouseup', function () {\n          $document.off('mousemove');\n        });\n      });\n    };\n\n    this.destroy = function () {\n      $statusbar.off();\n    };\n  };\n\n  var Fullscreen = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $toolbar = context.layoutInfo.toolbar;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n\n    var $window = $(window);\n    var $scrollbar = $('html, body');\n\n    /**\n     * toggle fullscreen\n     */\n    this.toggle = function () {\n      var resize = function (size) {\n        $editable.css('height', size.h);\n        $codable.css('height', size.h);\n        if ($codable.data('cmeditor')) {\n          $codable.data('cmeditor').setsize(null, size.h);\n        }\n      };\n\n      $editor.toggleClass('fullscreen');\n      if (this.isFullscreen()) {\n        $editable.data('orgHeight', $editable.css('height'));\n\n        $window.on('resize', function () {\n          resize({\n            h: $window.height() - $toolbar.outerHeight()\n          });\n        }).trigger('resize');\n\n        $scrollbar.css('overflow', 'hidden');\n      } else {\n        $window.off('resize');\n        resize({\n          h: $editable.data('orgHeight')\n        });\n        $scrollbar.css('overflow', 'visible');\n      }\n\n      context.invoke('toolbar.updateFullscreen', this.isFullscreen());\n    };\n\n    this.isFullscreen = function () {\n      return $editor.hasClass('fullscreen');\n    };\n  };\n\n  var Handle = function (context) {\n    var self = this;\n\n    var $document = $(document);\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.mousedown': function (we, e) {\n        if (self.update(e.target)) {\n          e.preventDefault();\n        }\n      },\n      'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {\n        self.update();\n      }\n    };\n\n    this.initialize = function () {\n      this.$handle = $([\n        '<div class=\"note-handle\">',\n        '<div class=\"note-control-selection\">',\n        '<div class=\"note-control-selection-bg\"></div>',\n        '<div class=\"note-control-holder note-control-nw\"></div>',\n        '<div class=\"note-control-holder note-control-ne\"></div>',\n        '<div class=\"note-control-holder note-control-sw\"></div>',\n        '<div class=\"',\n        (options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),\n        ' note-control-se\"></div>',\n        (options.disableResizeImage ? '' : '<div class=\"note-control-selection-info\"></div>'),\n        '</div>',\n        '</div>'\n      ].join('')).prependTo($editingArea);\n\n      this.$handle.on('mousedown', function (event) {\n        if (dom.isControlSizing(event.target)) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          var $target = self.$handle.find('.note-control-selection').data('target'),\n              posStart = $target.offset(),\n              scrollTop = $document.scrollTop();\n\n          $document.on('mousemove', function (event) {\n            context.invoke('editor.resizeTo', {\n              x: event.clientX - posStart.left,\n              y: event.clientY - (posStart.top - scrollTop)\n            }, $target, !event.shiftKey);\n\n            self.update($target[0]);\n          }).one('mouseup', function (e) {\n            e.preventDefault();\n            $document.off('mousemove');\n            context.invoke('editor.afterCommand');\n          });\n\n          if (!$target.data('ratio')) { // original ratio.\n            $target.data('ratio', $target.height() / $target.width());\n          }\n        }\n      });\n    };\n\n    this.destroy = function () {\n      this.$handle.remove();\n    };\n\n    this.update = function (target) {\n      var isImage = dom.isImg(target);\n      var $selection = this.$handle.find('.note-control-selection');\n\n      context.invoke('imagePopover.update', target);\n\n      if (isImage) {\n        var $image = $(target);\n        var pos = $image.position();\n\n        // include margin\n        var imageSize = {\n          w: $image.outerWidth(true),\n          h: $image.outerHeight(true)\n        };\n\n        $selection.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top,\n          width: imageSize.w,\n          height: imageSize.h\n        }).data('target', $image); // save current image element.\n\n        var sizingText = imageSize.w + 'x' + imageSize.h;\n        $selection.find('.note-control-selection-info').text(sizingText);\n        context.invoke('editor.saveTarget', target);\n      } else {\n        this.hide();\n      }\n\n      return isImage;\n    };\n\n    /**\n     * hide\n     *\n     * @param {jQuery} $handle\n     */\n    this.hide = function () {\n      context.invoke('editor.clearTarget');\n      this.$handle.children().hide();\n    };\n  };\n\n  var AutoLink = function (context) {\n    var self = this;\n    var defaultScheme = 'http://';\n    var linkPattern = /^(https?:\\/\\/|ssh:\\/\\/|ftp:\\/\\/|file:\\/|mailto:[A-Z0-9._%+-]+@)?(www\\.)?(.+)$/i;\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      }\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n    };\n\n    this.destroy = function () {\n      this.lastWordRange = null;\n    };\n\n    this.replace = function () {\n      if (!this.lastWordRange) {\n        return;\n      }\n\n      var keyword = this.lastWordRange.toString();\n      var match = keyword.match(linkPattern);\n\n      if (match && (match[1] || match[2])) {\n        var link = match[1] ? keyword : defaultScheme + keyword;\n        var node = $('<a />').html(keyword).attr('href', link)[0];\n\n        this.lastWordRange.insertNode(node);\n        this.lastWordRange = null;\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.handleKeydown = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        this.lastWordRange = wordRange;\n      }\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        this.replace();\n      }\n    };\n  };\n\n  /**\n   * textarea auto sync.\n   */\n  var AutoSync = function (context) {\n    var $note = context.layoutInfo.note;\n\n    this.events = {\n      'summernote.change': function () {\n        $note.val(context.invoke('code'));\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return dom.isTextarea($note[0]);\n    };\n  };\n\n  var Placeholder = function (context) {\n    var self = this;\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.init summernote.change': function () {\n        self.update();\n      },\n      'summernote.codeview.toggled': function () {\n        self.update();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !!options.placeholder;\n    };\n\n    this.initialize = function () {\n      this.$placeholder = $('<div class=\"note-placeholder\">');\n      this.$placeholder.on('click', function () {\n        context.invoke('focus');\n      }).text(options.placeholder).prependTo($editingArea);\n    };\n\n    this.destroy = function () {\n      this.$placeholder.remove();\n    };\n\n    this.update = function () {\n      var isShow = !context.invoke('codeview.isActivated') && context.invoke('editor.isEmpty');\n      this.$placeholder.toggle(isShow);\n    };\n  };\n\n  var Buttons = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var invertedKeyMap = func.invertObject(options.keyMap[agent.isMac ? 'mac' : 'pc']);\n\n    var representShortcut = this.representShortcut = function (editorMethod) {\n      var shortcut = invertedKeyMap[editorMethod];\n      if (agent.isMac) {\n        shortcut = shortcut.replace('CMD', '').replace('SHIFT', '');\n      }\n\n      shortcut = shortcut.replace('BACKSLASH', '\\\\')\n                         .replace('SLASH', '/')\n                         .replace('LEFTBRACKET', '[')\n                         .replace('RIGHTBRACKET', ']');\n\n      return ' (' + shortcut + ')';\n    };\n\n    this.initialize = function () {\n      this.addToolbarButtons();\n      this.addImagePopoverButtons();\n      this.addLinkPopoverButtons();\n      this.fontInstalledMap = {};\n    };\n\n    this.destroy = function () {\n      delete this.fontInstalledMap;\n    };\n\n    this.isFontInstalled = function (name) {\n      if (!self.fontInstalledMap.hasOwnProperty(name)) {\n        self.fontInstalledMap[name] = agent.isFontInstalled(name) ||\n          list.contains(options.fontNamesIgnoreCheck, name);\n      }\n\n      return self.fontInstalledMap[name];\n    };\n\n    this.addToolbarButtons = function () {\n      context.memo('button.style', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.magic) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.style.style,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'dropdown-style',\n            items: context.options.styleTags,\n            template: function (item) {\n\n              if (typeof item === 'string') {\n                item = { tag: item, title: item };\n              }\n\n              var tag = item.tag;\n              var title = item.title;\n              var style = item.style ? ' style=\"' + item.style + '\" ' : '';\n              var className = item.className ? ' className=\"' + item.className + '\"' : '';\n\n              return '<' + tag + style + className + '>' + title + '</' + tag +  '>';\n            },\n            click: context.createInvokeHandler('editor.formatBlock')\n          })\n        ]).render();\n      });\n\n      context.memo('button.bold', function () {\n        return ui.button({\n          className: 'note-btn-bold',\n          contents: ui.icon(options.icons.bold),\n          tooltip: lang.font.bold + representShortcut('bold'),\n          click: context.createInvokeHandler('editor.bold')\n        }).render();\n      });\n\n      context.memo('button.italic', function () {\n        return ui.button({\n          className: 'note-btn-italic',\n          contents: ui.icon(options.icons.italic),\n          tooltip: lang.font.italic + representShortcut('italic'),\n          click: context.createInvokeHandler('editor.italic')\n        }).render();\n      });\n\n      context.memo('button.underline', function () {\n        return ui.button({\n          className: 'note-btn-underline',\n          contents: ui.icon(options.icons.underline),\n          tooltip: lang.font.underline + representShortcut('underline'),\n          click: context.createInvokeHandler('editor.underline')\n        }).render();\n      });\n\n      context.memo('button.clear', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.eraser),\n          tooltip: lang.font.clear + representShortcut('removeFormat'),\n          click: context.createInvokeHandler('editor.removeFormat')\n        }).render();\n      });\n\n      context.memo('button.strikethrough', function () {\n        return ui.button({\n          className: 'note-btn-strikethrough',\n          contents: ui.icon(options.icons.strikethrough),\n          tooltip: lang.font.strikethrough + representShortcut('strikethrough'),\n          click: context.createInvokeHandler('editor.strikethrough')\n        }).render();\n      });\n\n      context.memo('button.superscript', function () {\n        return ui.button({\n          className: 'note-btn-superscript',\n          contents: ui.icon(options.icons.superscript),\n          tooltip: lang.font.superscript,\n          click: context.createInvokeHandler('editor.superscript')\n        }).render();\n      });\n\n      context.memo('button.subscript', function () {\n        return ui.button({\n          className: 'note-btn-subscript',\n          contents: ui.icon(options.icons.subscript),\n          tooltip: lang.font.subscript,\n          click: context.createInvokeHandler('editor.subscript')\n        }).render();\n      });\n\n      context.memo('button.fontname', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: '<span class=\"note-current-fontname\"/> ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.name,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontname',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontNames.filter(self.isFontInstalled),\n            template: function (item) {\n              return '<span style=\"font-family:' + item + '\">' + item + '</span>';\n            },\n            click: context.createInvokeHandler('editor.fontName')\n          })\n        ]).render();\n      });\n\n      context.memo('button.fontsize', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: '<span class=\"note-current-fontsize\"/>' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.size,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontsize',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontSizes,\n            click: context.createInvokeHandler('editor.fontSize')\n          })\n        ]).render();\n      });\n\n      context.memo('button.color', function () {\n        return ui.buttonGroup({\n          className: 'note-color',\n          children: [\n            ui.button({\n              className: 'note-current-color-button',\n              contents: ui.icon(options.icons.font + ' note-recent-color'),\n              tooltip: lang.color.recent,\n              click: function (e) {\n                var $button = $(e.currentTarget);\n                context.invoke('editor.color', {\n                  backColor: $button.attr('data-backColor'),\n                  foreColor: $button.attr('data-foreColor')\n                });\n              },\n              callback: function ($button) {\n                var $recentColor = $button.find('.note-recent-color');\n                $recentColor.css('background-color', '#FFFF00');\n                $button.attr('data-backColor', '#FFFF00');\n              }\n            }),\n            ui.button({\n              className: 'dropdown-toggle',\n              contents: ui.icon(options.icons.caret, 'span'),\n              tooltip: lang.color.more,\n              data: {\n                toggle: 'dropdown'\n              }\n            }),\n            ui.dropdown({\n              items: [\n                '<li>',\n                '<div class=\"btn-group\">',\n                '  <div class=\"note-palette-title\">' + lang.color.background + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"backColor\" data-value=\"inherit\">',\n                lang.color.transparent,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"backColor\"/>',\n                '</div>',\n                '<div class=\"btn-group\">',\n                '  <div class=\"note-palette-title\">' + lang.color.foreground + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"removeFormat\" data-value=\"foreColor\">',\n                lang.color.resetToDefault,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"foreColor\"/>',\n                '</div>',\n                '</li>'\n              ].join(''),\n              callback: function ($dropdown) {\n                $dropdown.find('.note-holder').each(function () {\n                  var $holder = $(this);\n                  $holder.append(ui.palette({\n                    colors: options.colors,\n                    eventName: $holder.data('event')\n                  }).render());\n                });\n              },\n              click: function (event) {\n                var $button = $(event.target);\n                var eventName = $button.data('event');\n                var value = $button.data('value');\n\n                if (eventName && value) {\n                  var key = eventName === 'backColor' ? 'background-color' : 'color';\n                  var $color = $button.closest('.note-color').find('.note-recent-color');\n                  var $currentButton = $button.closest('.note-color').find('.note-current-color-button');\n\n                  $color.css(key, value);\n                  $currentButton.attr('data-' + eventName, value);\n                  context.invoke('editor.' + eventName, value);\n                }\n              }\n            })\n          ]\n        }).render();\n      });\n\n      context.memo('button.ul',  function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unorderedlist),\n          tooltip: lang.lists.unordered + representShortcut('insertUnorderedList'),\n          click: context.createInvokeHandler('editor.insertUnorderedList')\n        }).render();\n      });\n\n      context.memo('button.ol', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.orderedlist),\n          tooltip: lang.lists.ordered + representShortcut('insertOrderedList'),\n          click:  context.createInvokeHandler('editor.insertOrderedList')\n        }).render();\n      });\n\n      var justifyLeft = ui.button({\n        contents: ui.icon(options.icons.alignLeft),\n        tooltip: lang.paragraph.left + representShortcut('justifyLeft'),\n        click: context.createInvokeHandler('editor.justifyLeft')\n      });\n\n      var justifyCenter = ui.button({\n        contents: ui.icon(options.icons.alignCenter),\n        tooltip: lang.paragraph.center + representShortcut('justifyCenter'),\n        click: context.createInvokeHandler('editor.justifyCenter')\n      });\n\n      var justifyRight = ui.button({\n        contents: ui.icon(options.icons.alignRight),\n        tooltip: lang.paragraph.right + representShortcut('justifyRight'),\n        click: context.createInvokeHandler('editor.justifyRight')\n      });\n\n      var justifyFull = ui.button({\n        contents: ui.icon(options.icons.alignJustify),\n        tooltip: lang.paragraph.justify + representShortcut('justifyFull'),\n        click: context.createInvokeHandler('editor.justifyFull')\n      });\n\n      var outdent = ui.button({\n        contents: ui.icon(options.icons.outdent),\n        tooltip: lang.paragraph.outdent + representShortcut('outdent'),\n        click: context.createInvokeHandler('editor.outdent')\n      });\n\n      var indent = ui.button({\n        contents: ui.icon(options.icons.indent),\n        tooltip: lang.paragraph.indent + representShortcut('indent'),\n        click: context.createInvokeHandler('editor.indent')\n      });\n\n      context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));\n      context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));\n      context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));\n      context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));\n      context.memo('button.outdent', func.invoke(outdent, 'render'));\n      context.memo('button.indent', func.invoke(indent, 'render'));\n\n      context.memo('button.paragraph', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.alignLeft) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.paragraph.paragraph,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown([\n            ui.buttonGroup({\n              className: 'note-align',\n              children: [justifyLeft, justifyCenter, justifyRight, justifyFull]\n            }),\n            ui.buttonGroup({\n              className: 'note-list',\n              children: [outdent, indent]\n            })\n          ])\n        ]).render();\n      });\n\n      context.memo('button.height', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.textHeight) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.height,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            items: options.lineHeights,\n            checkClassName: options.icons.menuCheck,\n            className: 'dropdown-line-height',\n            click: context.createInvokeHandler('editor.lineHeight')\n          })\n        ]).render();\n      });\n\n      context.memo('button.table', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.table) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.table.table,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'note-table',\n            items: [\n              '<div class=\"note-dimension-picker\">',\n              '  <div class=\"note-dimension-picker-mousecatcher\" data-event=\"insertTable\" data-value=\"1x1\"/>',\n              '  <div class=\"note-dimension-picker-highlighted\"/>',\n              '  <div class=\"note-dimension-picker-unhighlighted\"/>',\n              '</div>',\n              '<div class=\"note-dimension-display\">1 x 1</div>'\n            ].join('')\n          })\n        ], {\n          callback: function ($node) {\n            var $catcher = $node.find('.note-dimension-picker-mousecatcher');\n            $catcher.css({\n              width: options.insertTableMaxSize.col + 'em',\n              height: options.insertTableMaxSize.row + 'em'\n            }).mousedown(context.createInvokeHandler('editor.insertTable'))\n              .on('mousemove', self.tableMoveHandler);\n          }\n        }).render();\n      });\n\n      context.memo('button.link', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.link,\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.picture', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.picture),\n          tooltip: lang.image.image,\n          click: context.createInvokeHandler('imageDialog.show')\n        }).render();\n      });\n\n      context.memo('button.video', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.video),\n          tooltip: lang.video.video,\n          click: context.createInvokeHandler('videoDialog.show')\n        }).render();\n      });\n\n      context.memo('button.hr', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.minus),\n          tooltip: lang.hr.insert + representShortcut('insertHorizontalRule'),\n          click: context.createInvokeHandler('editor.insertHorizontalRule')\n        }).render();\n      });\n\n      context.memo('button.fullscreen', function () {\n        return ui.button({\n          className: 'btn-fullscreen',\n          contents: ui.icon(options.icons.arrowsAlt),\n          tooltip: lang.options.fullscreen,\n          click: context.createInvokeHandler('fullscreen.toggle')\n        }).render();\n      });\n\n      context.memo('button.codeview', function () {\n        return ui.button({\n          className: 'btn-codeview',\n          contents: ui.icon(options.icons.code),\n          tooltip: lang.options.codeview,\n          click: context.createInvokeHandler('codeview.toggle')\n        }).render();\n      });\n\n      context.memo('button.redo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.redo),\n          tooltip: lang.history.redo + representShortcut('redo'),\n          click: context.createInvokeHandler('editor.redo')\n        }).render();\n      });\n\n      context.memo('button.undo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.undo),\n          tooltip: lang.history.undo + representShortcut('undo'),\n          click: context.createInvokeHandler('editor.undo')\n        }).render();\n      });\n\n      context.memo('button.help', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.question),\n          tooltip: lang.options.help,\n          click: context.createInvokeHandler('helpDialog.show')\n        }).render();\n      });\n    };\n\n    /**\n     * image : [\n     *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n     *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],\n     *   ['remove', ['removeMedia']]\n     * ],\n     */\n    this.addImagePopoverButtons = function () {\n      // Image Size Buttons\n      context.memo('button.imageSize100', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">100%</span>',\n          tooltip: lang.image.resizeFull,\n          click: context.createInvokeHandler('editor.resize', '1')\n        }).render();\n      });\n      context.memo('button.imageSize50', function () {\n        return  ui.button({\n          contents: '<span class=\"note-fontsize-10\">50%</span>',\n          tooltip: lang.image.resizeHalf,\n          click: context.createInvokeHandler('editor.resize', '0.5')\n        }).render();\n      });\n      context.memo('button.imageSize25', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">25%</span>',\n          tooltip: lang.image.resizeQuarter,\n          click: context.createInvokeHandler('editor.resize', '0.25')\n        }).render();\n      });\n\n      // Float Buttons\n      context.memo('button.floatLeft', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignLeft),\n          tooltip: lang.image.floatLeft,\n          click: context.createInvokeHandler('editor.floatMe', 'left')\n        }).render();\n      });\n\n      context.memo('button.floatRight', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignRight),\n          tooltip: lang.image.floatRight,\n          click: context.createInvokeHandler('editor.floatMe', 'right')\n        }).render();\n      });\n\n      context.memo('button.floatNone', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignJustify),\n          tooltip: lang.image.floatNone,\n          click: context.createInvokeHandler('editor.floatMe', 'none')\n        }).render();\n      });\n\n      // Remove Buttons\n      context.memo('button.removeMedia', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.trash),\n          tooltip: lang.image.remove,\n          click: context.createInvokeHandler('editor.removeMedia')\n        }).render();\n      });\n    };\n\n    this.addLinkPopoverButtons = function () {\n      context.memo('button.linkDialogShow', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.edit,\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.unlink', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unlink),\n          tooltip: lang.link.unlink,\n          click: context.createInvokeHandler('editor.unlink')\n        }).render();\n      });\n    };\n\n    this.build = function ($container, groups) {\n      for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {\n        var group = groups[groupIdx];\n        var groupName = group[0];\n        var buttons = group[1];\n\n        var $group = ui.buttonGroup({\n          className: 'note-' + groupName\n        }).render();\n\n        for (var idx = 0, len = buttons.length; idx < len; idx++) {\n          var button = context.memo('button.' + buttons[idx]);\n          if (button) {\n            $group.append(typeof button === 'function' ? button(context) : button);\n          }\n        }\n        $group.appendTo($container);\n      }\n    };\n\n    this.updateCurrentStyle = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      this.updateBtnStates({\n        '.note-btn-bold': function () {\n          return styleInfo['font-bold'] === 'bold';\n        },\n        '.note-btn-italic': function () {\n          return styleInfo['font-italic'] === 'italic';\n        },\n        '.note-btn-underline': function () {\n          return styleInfo['font-underline'] === 'underline';\n        },\n        '.note-btn-subscript': function () {\n          return styleInfo['font-subscript'] === 'subscript';\n        },\n        '.note-btn-superscript': function () {\n          return styleInfo['font-superscript'] === 'superscript';\n        },\n        '.note-btn-strikethrough': function () {\n          return styleInfo['font-strikethrough'] === 'strikethrough';\n        }\n      });\n\n      if (styleInfo['font-family']) {\n        var fontNames = styleInfo['font-family'].split(',').map(function (name) {\n          return name.replace(/[\\'\\\"]/g, '')\n            .replace(/\\s+$/, '')\n            .replace(/^\\s+/, '');\n        });\n        var fontName = list.find(fontNames, self.isFontInstalled);\n\n        $toolbar.find('.dropdown-fontname li a').each(function () {\n          // always compare string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (fontName + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n        $toolbar.find('.note-current-fontname').text(fontName);\n      }\n\n      if (styleInfo['font-size']) {\n        var fontSize = styleInfo['font-size'];\n        $toolbar.find('.dropdown-fontsize li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (fontSize + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n        $toolbar.find('.note-current-fontsize').text(fontSize);\n      }\n\n      if (styleInfo['line-height']) {\n        var lineHeight = styleInfo['line-height'];\n        $toolbar.find('.dropdown-line-height li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (lineHeight + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n      }\n    };\n\n    this.updateBtnStates = function (infos) {\n      $.each(infos, function (selector, pred) {\n        ui.toggleBtnActive($toolbar.find(selector), pred());\n      });\n    };\n\n    this.tableMoveHandler = function (event) {\n      var PX_PER_EM = 18;\n      var $picker = $(event.target.parentNode); // target is mousecatcher\n      var $dimensionDisplay = $picker.next();\n      var $catcher = $picker.find('.note-dimension-picker-mousecatcher');\n      var $highlighted = $picker.find('.note-dimension-picker-highlighted');\n      var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');\n\n      var posOffset;\n      // HTML5 with jQuery - e.offsetX is undefined in Firefox\n      if (event.offsetX === undefined) {\n        var posCatcher = $(event.target).offset();\n        posOffset = {\n          x: event.pageX - posCatcher.left,\n          y: event.pageY - posCatcher.top\n        };\n      } else {\n        posOffset = {\n          x: event.offsetX,\n          y: event.offsetY\n        };\n      }\n\n      var dim = {\n        c: Math.ceil(posOffset.x / PX_PER_EM) || 1,\n        r: Math.ceil(posOffset.y / PX_PER_EM) || 1\n      };\n\n      $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });\n      $catcher.data('value', dim.c + 'x' + dim.r);\n\n      if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {\n        $unhighlighted.css({ width: dim.c + 1 + 'em'});\n      }\n\n      if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {\n        $unhighlighted.css({ height: dim.r + 1 + 'em'});\n      }\n\n      $dimensionDisplay.html(dim.c + ' x ' + dim.r);\n    };\n  };\n\n  var Toolbar = function (context) {\n    var ui = $.summernote.ui;\n\n    var $note = context.layoutInfo.note;\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !options.airMode;\n    };\n\n    this.initialize = function () {\n      options.toolbar = options.toolbar || [];\n\n      if (!options.toolbar.length) {\n        $toolbar.hide();\n      } else {\n        context.invoke('buttons.build', $toolbar, options.toolbar);\n      }\n\n      if (options.toolbarContainer) {\n        $toolbar.appendTo(options.toolbarContainer);\n      }\n\n      $note.on('summernote.keyup summernote.mouseup summernote.change', function () {\n        context.invoke('buttons.updateCurrentStyle');\n      });\n\n      context.invoke('buttons.updateCurrentStyle');\n    };\n\n    this.destroy = function () {\n      $toolbar.children().remove();\n    };\n\n    this.updateFullscreen = function (isFullscreen) {\n      ui.toggleBtnActive($toolbar.find('.btn-fullscreen'), isFullscreen);\n    };\n\n    this.updateCodeview = function (isCodeview) {\n      ui.toggleBtnActive($toolbar.find('.btn-codeview'), isCodeview);\n      if (isCodeview) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n    };\n\n    this.activate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, true);\n    };\n\n    this.deactivate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, false);\n    };\n  };\n\n  var LinkDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group\">' +\n                   '<label>' + lang.link.textToDisplay + '</label>' +\n                   '<input class=\"note-link-text form-control\" type=\"text\" />' +\n                 '</div>' +\n                 '<div class=\"form-group\">' +\n                   '<label>' + lang.link.url + '</label>' +\n                   '<input class=\"note-link-url form-control\" type=\"text\" value=\"http://\" />' +\n                 '</div>' +\n                 (!options.disableLinkTarget ?\n                   '<div class=\"checkbox\">' +\n                     '<label>' + '<input type=\"checkbox\" checked> ' + lang.link.openInNewWindow + '</label>' +\n                   '</div>' : ''\n                 );\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-link-btn disabled\" disabled>' + lang.link.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        className: 'link-dialog',\n        title: lang.link.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    /**\n     * Show link dialog and set event handlers on dialog controls.\n     *\n     * @param {Object} linkInfo\n     * @return {Promise}\n     */\n    this.showLinkDialog = function (linkInfo) {\n      return $.Deferred(function (deferred) {\n        var $linkText = self.$dialog.find('.note-link-text'),\n        $linkUrl = self.$dialog.find('.note-link-url'),\n        $linkBtn = self.$dialog.find('.note-link-btn'),\n        $openInNewWindow = self.$dialog.find('input[type=checkbox]');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          $linkText.val(linkInfo.text);\n\n          $linkText.on('input', function () {\n            ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n            // if linktext was modified by keyup,\n            // stop cloning text from linkUrl\n            linkInfo.text = $linkText.val();\n          });\n\n          // if no url was given, copy text to url\n          if (!linkInfo.url) {\n            linkInfo.url = linkInfo.text || 'http://';\n            ui.toggleBtn($linkBtn, linkInfo.text);\n          }\n\n          $linkUrl.on('input', function () {\n            ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n            // display same link on `Text to display` input\n            // when create a new link\n            if (!linkInfo.text) {\n              $linkText.val($linkUrl.val());\n            }\n          }).val(linkInfo.url).trigger('focus');\n\n          self.bindEnterKey($linkUrl, $linkBtn);\n          self.bindEnterKey($linkText, $linkBtn);\n\n          $openInNewWindow.prop('checked', linkInfo.isNewWindow);\n\n          $linkBtn.one('click', function (event) {\n            event.preventDefault();\n\n            deferred.resolve({\n              range: linkInfo.range,\n              url: $linkUrl.val(),\n              text: $linkText.val(),\n              isNewWindow: $openInNewWindow.is(':checked')\n            });\n            self.$dialog.modal('hide');\n          });\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          // detach events\n          $linkText.off('input keypress');\n          $linkUrl.off('input keypress');\n          $linkBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    /**\n     * @param {Object} layoutInfo\n     */\n    this.show = function () {\n      var linkInfo = context.invoke('editor.getLinkInfo');\n\n      context.invoke('editor.saveRange');\n      this.showLinkDialog(linkInfo).then(function (linkInfo) {\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.createLink', linkInfo);\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n    context.memo('help.linkDialog.show', options.langInfo.help['linkDialog.show']);\n  };\n\n  var LinkPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.link);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-link-popover',\n        callback: function ($node) {\n          var $content = $node.find('.popover-content');\n          $content.prepend('<span><a target=\"_blank\"></a>&nbsp;</span>');\n        }\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.link);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      // Prevent focusing on editable when invoke('code') is executed\n      if (!context.invoke('editor.hasFocus')) {\n        this.hide();\n        return;\n      }\n\n      var rng = context.invoke('editor.createRange');\n      if (rng.isCollapsed() && rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        var href = $(anchor).attr('href');\n        this.$popover.find('a').attr('href', href).html(href);\n\n        var pos = dom.posFromPlaceholder(anchor);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var ImageDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var imageLimitation = '';\n      if (options.maximumImageFileSize) {\n        var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));\n        var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +\n                           ' ' + ' KMGTP'[unit] + 'B';\n        imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';\n      }\n\n      var body = '<div class=\"form-group note-group-select-from-files\">' +\n                   '<label>' + lang.image.selectFromFiles + '</label>' +\n                   '<input class=\"note-image-input form-control\" type=\"file\" name=\"files\" accept=\"image/*\" multiple=\"multiple\" />' +\n                   imageLimitation +\n                 '</div>' +\n                 '<div class=\"form-group\" style=\"overflow:auto;\">' +\n                   '<label>' + lang.image.url + '</label>' +\n                   '<input class=\"note-image-url form-control col-md-12\" type=\"text\" />' +\n                 '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-image-btn disabled\" disabled>' + lang.image.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.image.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showImageDialog().then(function (data) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        if (typeof data === 'string') { // image url\n          context.invoke('editor.insertImage', data);\n        } else { // array of files\n          context.invoke('editor.insertImagesOrCallback', data);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showImageDialog = function () {\n      return $.Deferred(function (deferred) {\n        var $imageInput = self.$dialog.find('.note-image-input'),\n            $imageUrl = self.$dialog.find('.note-image-url'),\n            $imageBtn = self.$dialog.find('.note-image-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          // Cloning imageInput to clear element.\n          $imageInput.replaceWith($imageInput.clone()\n            .on('change', function () {\n              deferred.resolve(this.files || this.value);\n            })\n            .val('')\n          );\n\n          $imageBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($imageUrl.val());\n          });\n\n          $imageUrl.on('keyup paste', function () {\n            var url = $imageUrl.val();\n            ui.toggleBtn($imageBtn, url);\n          }).val('').trigger('focus');\n          self.bindEnterKey($imageUrl, $imageBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $imageInput.off('change');\n          $imageUrl.off('keyup paste keypress');\n          $imageBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var ImagePopover = function (context) {\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.image);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-image-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.image);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function (target) {\n      if (dom.isImg(target)) {\n        var pos = dom.posFromPlaceholder(target);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var VideoDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group row-fluid\">' +\n          '<label>' + lang.video.url + ' <small class=\"text-muted\">' + lang.video.providers + '</small></label>' +\n          '<input class=\"note-video-url form-control span12\" type=\"text\" />' +\n          '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-video-btn disabled\" disabled>' + lang.video.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.video.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.createVideoNode = function (url) {\n      // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)\n      var ytRegExp = /^(?:https?:\\/\\/)?(?:www\\.)?(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))((\\w|-){11})(?:\\S+)?$/;\n      var ytMatch = url.match(ytRegExp);\n\n      var igRegExp = /\\/\\/instagram.com\\/p\\/(.[a-zA-Z0-9_-]*)/;\n      var igMatch = url.match(igRegExp);\n\n      var vRegExp = /\\/\\/vine.co\\/v\\/(.[a-zA-Z0-9]*)/;\n      var vMatch = url.match(vRegExp);\n\n      var vimRegExp = /\\/\\/(player.)?vimeo.com\\/([a-z]*\\/)*([0-9]{6,11})[?]?.*/;\n      var vimMatch = url.match(vimRegExp);\n\n      var dmRegExp = /.+dailymotion.com\\/(video|hub)\\/([^_]+)[^#]*(#video=([^_&]+))?/;\n      var dmMatch = url.match(dmRegExp);\n\n      var youkuRegExp = /\\/\\/v\\.youku\\.com\\/v_show\\/id_(\\w+)=*\\.html/;\n      var youkuMatch = url.match(youkuRegExp);\n\n      var mp4RegExp = /^.+.(mp4|m4v)$/;\n      var mp4Match = url.match(mp4RegExp);\n\n      var oggRegExp = /^.+.(ogg|ogv)$/;\n      var oggMatch = url.match(oggRegExp);\n\n      var webmRegExp = /^.+.(webm)$/;\n      var webmMatch = url.match(webmRegExp);\n\n      var $video;\n      if (ytMatch && ytMatch[1].length === 11) {\n        var youtubeId = ytMatch[1];\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.youtube.com/embed/' + youtubeId)\n            .attr('width', '640').attr('height', '360');\n      } else if (igMatch && igMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', igMatch[0] + '/embed/')\n            .attr('width', '612').attr('height', '710')\n            .attr('scrolling', 'no')\n            .attr('allowtransparency', 'true');\n      } else if (vMatch && vMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', vMatch[0] + '/embed/simple')\n            .attr('width', '600').attr('height', '600')\n            .attr('class', 'vine-embed');\n      } else if (vimMatch && vimMatch[3].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('src', '//player.vimeo.com/video/' + vimMatch[3])\n            .attr('width', '640').attr('height', '360');\n      } else if (dmMatch && dmMatch[2].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])\n            .attr('width', '640').attr('height', '360');\n      } else if (youkuMatch && youkuMatch[1].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('height', '498')\n            .attr('width', '510')\n            .attr('src', '//player.youku.com/embed/' + youkuMatch[1]);\n      } else if (mp4Match || oggMatch || webmMatch) {\n        $video = $('<video controls>')\n            .attr('src', url)\n            .attr('width', '640').attr('height', '360');\n      } else {\n        // this is not a known video link. Now what, Cat? Now what?\n        return false;\n      }\n\n      $video.addClass('note-video-clip');\n\n      return $video[0];\n    };\n\n    this.show = function () {\n      var text = context.invoke('editor.getSelectedText');\n      context.invoke('editor.saveRange');\n      this.showVideoDialog(text).then(function (url) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        // build node\n        var $node = self.createVideoNode(url);\n\n        if ($node) {\n          // insert video node\n          context.invoke('editor.insertNode', $node);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showVideoDialog = function (text) {\n      return $.Deferred(function (deferred) {\n        var $videoUrl = self.$dialog.find('.note-video-url'),\n            $videoBtn = self.$dialog.find('.note-video-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          $videoUrl.val(text).on('input', function () {\n            ui.toggleBtn($videoBtn, $videoUrl.val());\n          }).trigger('focus');\n\n          $videoBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($videoUrl.val());\n          });\n\n          self.bindEnterKey($videoUrl, $videoBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $videoUrl.off('input');\n          $videoBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var HelpDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.createShortCutList = function () {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      return Object.keys(keyMap).map(function (key) {\n        var command = keyMap[key];\n        var $row = $('<div><div class=\"help-list-item\"/></div>');\n        $row.append($('<label><kbd>' + key + '</kdb></label>').css({\n          'width': 180,\n          'margin-right': 10\n        })).append($('<span/>').html(context.memo('help.' + command) || command));\n        return $row.html();\n      }).join('');\n    };\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = [\n        '<p class=\"text-center\">',\n        '<a href=\"//summernote.org/\" target=\"_blank\">Summernote 0.8.1</a>  ',\n        '<a href=\"//github.com/summernote/summernote\" target=\"_blank\">Project</a>  ',\n        '<a href=\"//github.com/summernote/summernote/issues\" target=\"_blank\">Issues</a>',\n        '</p>'\n      ].join('');\n\n      this.$dialog = ui.dialog({\n        title: lang.options.help,\n        fade: options.dialogsFade,\n        body: this.createShortCutList(),\n        footer: body,\n        callback: function ($node) {\n          $node.find('.modal-body').css({\n            'max-height': 300,\n            'overflow': 'scroll'\n          });\n        }\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    /**\n     * show help dialog\n     *\n     * @return {Promise}\n     */\n    this.showHelpDialog = function () {\n      return $.Deferred(function (deferred) {\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n          deferred.resolve();\n        });\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showHelpDialog().then(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n  };\n\n  var AirPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    var AIR_MODE_POPOVER_X_OFFSET = 20;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.change summernote.dialog.shown': function () {\n        self.hide();\n      },\n      'summernote.focusout': function (we, e) {\n        // [workaround] Firefox doesn't support relatedTarget on focusout\n        //  - Ignore hide action on focus out in FF.\n        if (agent.isFF) {\n          return;\n        }\n\n        if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(self.$popover[0]))) {\n          self.hide();\n        }\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return options.airMode && !list.isEmpty(options.popover.air);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-air-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.air);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      if (styleInfo.range && !styleInfo.range.isCollapsed()) {\n        var rect = list.last(styleInfo.range.getClientRects());\n        if (rect) {\n          var bnd = func.rect2bnd(rect);\n          this.$popover.css({\n            display: 'block',\n            left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,\n            top: bnd.top + bnd.height\n          });\n        }\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var HintPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var POPOVER_DIST = 5;\n    var hint = context.options.hint || [];\n    var direction = context.options.hintDirection || 'bottom';\n    var hints = $.isArray(hint) ? hint : [hint];\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      },\n      'summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return hints.length > 0;\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n      this.$popover = ui.popover({\n        className: 'note-hint-popover',\n        hideArrow: true,\n        direction: ''\n      }).render().appendTo('body');\n\n      this.$popover.hide();\n\n      this.$content = this.$popover.find('.popover-content');\n\n      this.$content.on('click', '.note-hint-item', function () {\n        self.$content.find('.active').removeClass('active');\n        $(this).addClass('active');\n        self.replace();\n      });\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.selectItem = function ($item) {\n      this.$content.find('.active').removeClass('active');\n      $item.addClass('active');\n\n      this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);\n    };\n\n    this.moveDown = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $next = $current.next();\n\n      if ($next.length) {\n        this.selectItem($next);\n      } else {\n        var $nextGroup = $current.parent().next();\n\n        if (!$nextGroup.length) {\n          $nextGroup = this.$content.find('.note-hint-group').first();\n        }\n\n        this.selectItem($nextGroup.find('.note-hint-item').first());\n      }\n    };\n\n    this.moveUp = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $prev = $current.prev();\n\n      if ($prev.length) {\n        this.selectItem($prev);\n      } else {\n        var $prevGroup = $current.parent().prev();\n\n        if (!$prevGroup.length) {\n          $prevGroup = this.$content.find('.note-hint-group').last();\n        }\n\n        this.selectItem($prevGroup.find('.note-hint-item').last());\n      }\n    };\n\n    this.replace = function () {\n      var $item = this.$content.find('.note-hint-item.active');\n\n      if ($item.length) {\n        var node = this.nodeFromItem($item);\n        this.lastWordRange.insertNode(node);\n        range.createFromNode(node).collapse().select();\n\n        this.lastWordRange = null;\n        this.hide();\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.nodeFromItem = function ($item) {\n      var hint = hints[$item.data('index')];\n      var item = $item.data('item');\n      var node = hint.content ? hint.content(item) : item;\n      if (typeof node === 'string') {\n        node = dom.createText(node);\n      }\n      return node;\n    };\n\n    this.createItemTemplates = function (hintIdx, items) {\n      var hint = hints[hintIdx];\n      return items.map(function (item, idx) {\n        var $item = $('<div class=\"note-hint-item\"/>');\n        $item.append(hint.template ? hint.template(item) : item + '');\n        $item.data({\n          'index': hintIdx,\n          'item': item\n        });\n\n        if (hintIdx === 0 && idx === 0) {\n          $item.addClass('active');\n        }\n        return $item;\n      });\n    };\n\n    this.handleKeydown = function (e) {\n      if (!this.$popover.is(':visible')) {\n        return;\n      }\n\n      if (e.keyCode === key.code.ENTER) {\n        e.preventDefault();\n        this.replace();\n      } else if (e.keyCode === key.code.UP) {\n        e.preventDefault();\n        this.moveUp();\n      } else if (e.keyCode === key.code.DOWN) {\n        e.preventDefault();\n        this.moveDown();\n      }\n    };\n\n    this.searchKeyword = function (index, keyword, callback) {\n      var hint = hints[index];\n      if (hint && hint.match.test(keyword) && hint.search) {\n        var matches = hint.match.exec(keyword);\n        hint.search(matches[1], callback);\n      } else {\n        callback();\n      }\n    };\n\n    this.createGroup = function (idx, keyword) {\n      var $group = $('<div class=\"note-hint-group note-hint-group-' + idx + '\"/>');\n      this.searchKeyword(idx, keyword, function (items) {\n        items = items || [];\n        if (items.length) {\n          $group.html(self.createItemTemplates(idx, items));\n          self.show();\n        }\n      });\n\n      return $group;\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {\n        if (e.keyCode === key.code.ENTER) {\n          if (this.$popover.is(':visible')) {\n            return;\n          }\n        }\n      } else {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        var keyword = wordRange.toString();\n        if (hints.length && keyword) {\n          this.$content.empty();\n\n          var bnd = func.rect2bnd(list.last(wordRange.getClientRects()));\n          if (bnd) {\n\n            this.$popover.hide();\n\n            this.lastWordRange = wordRange;\n\n            hints.forEach(function (hint, idx) {\n              if (hint.match.test(keyword)) {\n                self.createGroup(idx, keyword).appendTo(self.$content);\n              }\n            });\n\n            // set position for popover after group is created\n            if (direction === 'top') {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST\n              });\n            } else {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top + bnd.height + POPOVER_DIST\n              });\n            }\n\n          }\n        } else {\n          this.hide();\n        }\n      }\n    };\n\n    this.show = function () {\n      this.$popover.show();\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n\n  $.summernote = $.extend($.summernote, {\n    version: '0.8.1',\n    ui: ui,\n\n    plugins: {},\n\n    options: {\n      modules: {\n        'editor': Editor,\n        'clipboard': Clipboard,\n        'dropzone': Dropzone,\n        'codeview': Codeview,\n        'statusbar': Statusbar,\n        'fullscreen': Fullscreen,\n        'handle': Handle,\n        // FIXME: HintPopover must be front of autolink\n        //  - Script error about range when Enter key is pressed on hint popover\n        'hintPopover': HintPopover,\n        'autoLink': AutoLink,\n        'autoSync': AutoSync,\n        'placeholder': Placeholder,\n        'buttons': Buttons,\n        'toolbar': Toolbar,\n        'linkDialog': LinkDialog,\n        'linkPopover': LinkPopover,\n        'imageDialog': ImageDialog,\n        'imagePopover': ImagePopover,\n        'videoDialog': VideoDialog,\n        'helpDialog': HelpDialog,\n        'airPopover': AirPopover\n      },\n\n      buttons: {},\n      \n      lang: 'en-US',\n\n      // toolbar\n      toolbar: [\n        ['style', ['style']],\n        ['font', ['bold', 'underline', 'clear']],\n        ['fontname', ['fontname']],\n        ['color', ['color']],\n        ['para', ['ul', 'ol', 'paragraph']],\n        ['table', ['table']],\n        ['insert', ['link', 'picture', 'video']],\n        ['view', ['fullscreen', 'codeview', 'help']]\n      ],\n\n      // popover\n      popover: {\n        image: [\n          ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n          ['float', ['floatLeft', 'floatRight', 'floatNone']],\n          ['remove', ['removeMedia']]\n        ],\n        link: [\n          ['link', ['linkDialogShow', 'unlink']]\n        ],\n        air: [\n          ['color', ['color']],\n          ['font', ['bold', 'underline', 'clear']],\n          ['para', ['ul', 'paragraph']],\n          ['table', ['table']],\n          ['insert', ['link', 'picture']]\n        ]\n      },\n\n      // air mode: inline editor\n      airMode: false,\n\n      width: null,\n      height: null,\n\n      focus: false,\n      tabSize: 4,\n      styleWithSpan: true,\n      shortcuts: true,\n      textareaAutoSync: true,\n      direction: null,\n\n      styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\n      fontNames: [\n        'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',\n        'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',\n        'Tahoma', 'Times New Roman', 'Verdana'\n      ],\n\n      fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],\n\n      // pallete colors(n x n)\n      colors: [\n        ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],\n        ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],\n        ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],\n        ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],\n        ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],\n        ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],\n        ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],\n        ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']\n      ],\n\n      lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],\n\n      tableClassName: 'table table-bordered',\n\n      insertTableMaxSize: {\n        col: 10,\n        row: 10\n      },\n\n      dialogsInBody: false,\n      dialogsFade: false,\n\n      maximumImageFileSize: null,\n\n      callbacks: {\n        onInit: null,\n        onFocus: null,\n        onBlur: null,\n        onEnter: null,\n        onKeyup: null,\n        onKeydown: null,\n        onSubmit: null,\n        onImageUpload: null,\n        onImageUploadError: null\n      },\n\n      codemirror: {\n        mode: 'text/html',\n        htmlMode: true,\n        lineNumbers: true\n      },\n\n      keyMap: {\n        pc: {\n          'ENTER': 'insertParagraph',\n          'CTRL+Z': 'undo',\n          'CTRL+Y': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CTRL+B': 'bold',\n          'CTRL+I': 'italic',\n          'CTRL+U': 'underline',\n          'CTRL+SHIFT+S': 'strikethrough',\n          'CTRL+BACKSLASH': 'removeFormat',\n          'CTRL+SHIFT+L': 'justifyLeft',\n          'CTRL+SHIFT+E': 'justifyCenter',\n          'CTRL+SHIFT+R': 'justifyRight',\n          'CTRL+SHIFT+J': 'justifyFull',\n          'CTRL+SHIFT+NUM7': 'insertUnorderedList',\n          'CTRL+SHIFT+NUM8': 'insertOrderedList',\n          'CTRL+LEFTBRACKET': 'outdent',\n          'CTRL+RIGHTBRACKET': 'indent',\n          'CTRL+NUM0': 'formatPara',\n          'CTRL+NUM1': 'formatH1',\n          'CTRL+NUM2': 'formatH2',\n          'CTRL+NUM3': 'formatH3',\n          'CTRL+NUM4': 'formatH4',\n          'CTRL+NUM5': 'formatH5',\n          'CTRL+NUM6': 'formatH6',\n          'CTRL+ENTER': 'insertHorizontalRule',\n          'CTRL+K': 'linkDialog.show'\n        },\n\n        mac: {\n          'ENTER': 'insertParagraph',\n          'CMD+Z': 'undo',\n          'CMD+SHIFT+Z': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CMD+B': 'bold',\n          'CMD+I': 'italic',\n          'CMD+U': 'underline',\n          'CMD+SHIFT+S': 'strikethrough',\n          'CMD+BACKSLASH': 'removeFormat',\n          'CMD+SHIFT+L': 'justifyLeft',\n          'CMD+SHIFT+E': 'justifyCenter',\n          'CMD+SHIFT+R': 'justifyRight',\n          'CMD+SHIFT+J': 'justifyFull',\n          'CMD+SHIFT+NUM7': 'insertUnorderedList',\n          'CMD+SHIFT+NUM8': 'insertOrderedList',\n          'CMD+LEFTBRACKET': 'outdent',\n          'CMD+RIGHTBRACKET': 'indent',\n          'CMD+NUM0': 'formatPara',\n          'CMD+NUM1': 'formatH1',\n          'CMD+NUM2': 'formatH2',\n          'CMD+NUM3': 'formatH3',\n          'CMD+NUM4': 'formatH4',\n          'CMD+NUM5': 'formatH5',\n          'CMD+NUM6': 'formatH6',\n          'CMD+ENTER': 'insertHorizontalRule',\n          'CMD+K': 'linkDialog.show'\n        }\n      },\n      icons: {\n        'align': 'note-icon-align',\n        'alignCenter': 'note-icon-align-center',\n        'alignJustify': 'note-icon-align-justify',\n        'alignLeft': 'note-icon-align-left',\n        'alignRight': 'note-icon-align-right',\n        'indent': 'note-icon-align-indent',\n        'outdent': 'note-icon-align-outdent',\n        'arrowsAlt': 'note-icon-arrows-alt',\n        'bold': 'note-icon-bold',\n        'caret': 'note-icon-caret',\n        'circle': 'note-icon-circle',\n        'close': 'note-icon-close',\n        'code': 'note-icon-code',\n        'eraser': 'note-icon-eraser',\n        'font': 'note-icon-font',\n        'frame': 'note-icon-frame',\n        'italic': 'note-icon-italic',\n        'link': 'note-icon-link',\n        'unlink': 'note-icon-chain-broken',\n        'magic': 'note-icon-magic',\n        'menuCheck': 'note-icon-check',\n        'minus': 'note-icon-minus',\n        'orderedlist': 'note-icon-orderedlist',\n        'pencil': 'note-icon-pencil',\n        'picture': 'note-icon-picture',\n        'question': 'note-icon-question',\n        'redo': 'note-icon-redo',\n        'square': 'note-icon-square',\n        'strikethrough': 'note-icon-strikethrough',\n        'subscript': 'note-icon-subscript',\n        'superscript': 'note-icon-superscript',\n        'table': 'note-icon-table',\n        'textHeight': 'note-icon-text-height',\n        'trash': 'note-icon-trash',\n        'underline': 'note-icon-underline',\n        'undo': 'note-icon-undo',\n        'unorderedlist': 'note-icon-unorderedlist',\n        'video': 'note-icon-video'\n      }\n    }\n  });\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/summernote-webpack/dist/summernote.js\n// module id = 151\n// module chunks = 0","/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-options.js\n// module id = 152\n// module chunks = 0"],"sourceRoot":""}