<?php

/**
 * Dewdrop
 *
 * @link      https://github.com/DeltaSystems/dewdrop
 * @copyright Delta Systems (http://deltasys.com)
 * @license   https://github.com/DeltaSystems/dewdrop/LICENSE
 */

namespace Dewdrop\Admin\Env;

use Dewdrop\Admin\Component\ComponentInterface;
use Dewdrop\Admin\Component\ShellIntegrationInterface;
use Dewdrop\Admin\Response;
use Dewdrop\Pimple;
use Dewdrop\View\View;
use Zend\View\Helper\HeadLink;
use Zend\View\Helper\HeadScript;

/**
 * Enable Dewdrop admin components to work within the WP admin shell.
 */
class Wp extends EnvAbstract
{
    /**
     * The output generated by rendering the page.  We have to store this
     * temporarily because on a typical request, we render our page before
     * WP has had a chance to render the shell layout
     * (@see renderOutputIntoShell()).
     *
     * @var string
     */
    private $output;

    /**
     * The only "layout" needed in the case of the WP admin is to wrap the page
     * content with the wpWrap() view helper, which applies some basic structure
     * to WP admin pages and wraps everything in the .bootstrap-wrapper class so
     * that bootstrap styles can work without conflicting with WP styles.
     *
     * @param string $content
     * @param HeadScript $headScript
     * @param HeadLink $headLink
     * @return string
     */
    public function renderLayout($content, HeadScript $headScript = null, HeadLink $headLink = null)
    {
        global $wp_version;

        $view = new View();

        $output  = $view->wpWrap()->open();
        $output .= $content;
        $output .= $view->wpWrap()->close();

        foreach ($headScript as $script) {
            // We're prefixing the name here so we don't conflict with WP names
            wp_enqueue_script(
                'dewdrop-' . basename($script->attributes['src'], '.js'),
                $script->attributes['src'],
                [],
                $wp_version,
                true
            );
        }

        foreach ($headLink as $link) {
            if ('stylesheet' === $link->rel) {
                wp_enqueue_style(
                    'dewdrop-' . basename($link->href, '.css'),
                    $link->href
                );
            }
        }

        return $output;
    }

    /**
     * Get a URL for a page in this component.  This method will automatically
     * return submenu-friendly URLs when a submenu item matches the supplied
     * page and params arguments.
     *
     * @param ComponentInterface $component
     * @param string $page
     * @param array $params
     * @return string
     */
    public function url(ComponentInterface $component, $page, array $params = array())
    {
        $base  = get_bloginfo('wpurl') . '/wp-admin/admin.php?page=' . $component->getSlug();
        $query = $this->assembleQueryString($params, $separator = '&');

        foreach ($component->getSubmenuPages() as $submenu) {
            if ($submenu['route'] === $page) {
                $submenuParams  = $submenu['params'];
                $matchesSubmenu = true;

                foreach ($params as $name => $value) {
                    if (!isset($submenuParams[$name]) || $submenuParams['value'] !== $value) {
                        $matchesSubmenu = false;
                        break;
                    }
                }

                if ($matchesSubmenu) {
                    if ('Index' === $submenu['route']) {
                        $route = '';
                    } else {
                        $route = '/' . $submenu['route'];
                    }

                    return $this->filterUrl("{$base}{$route}{$query}");
                }
            }
        }

        return $this->filterUrl("{$base}&route={$page}{$query}");
    }

    protected function filterUrl($url)
    {
        if (Pimple::hasResource('url-filter')) {
            /* @var $filter callable */
            $filter = Pimple::getResource('url-filter');
            $url    = $filter($url);
        }

        return $url;
    }

    /**
     * Redirect to the supplied URL using WP's wp_safe_redirect() function and
     * then exit.  You may need to mock this method during testing.
     *
     * @param string $url
     * @return void
     */
    public function redirect($url)
    {
        wp_safe_redirect($url);
        exit;
    }

    /**
     * Hook into admin_init, admin_menu and wp_ajax APIs in WordPress so that we
     * can route requests to the supplied component.  We use closures for all the
     * event handlers so that we can supply the ComponentAbstract object to those
     * functions.
     *
     * @param ComponentInterface $component
     * @return void
     */
    public function initComponent(ComponentInterface $component)
    {
        add_action(
            'admin_init',
            function () use ($component) {
                return $this->adminInit($component);
            }
        );

        add_action(
            'admin_menu',
            function () use ($component) {
                return $this->registerMenuPage($component);
            }
        );

        // Also allow routing via WP's ajax facility to avoid rendering layout
        add_action(
            'wp_ajax_' . $component->getSlug(),
            function () use ($component) {
                $this->renderOutputIntoShell($component);
            }
        );
    }

    /**
     * Handle the admin_init action.  All page handling is done on admin_init
     * so we have the opportunity to run code prior to WP rendering any output.
     *
     * @param string $page The name of the page to route to (e.g. "Index" or "Edit").
     * @param Response $response Inject a response object, usually for tests.
     *
     * @param ComponentInterface $component
     * @param string|null $page
     * @param Response|null $response
     * @return ComponentInterface
     */
    public function adminInit(ComponentInterface $component, $page = null, Response $response = null)
    {
        if ($this->componentIsCurrentlyActive($component)) {
            $page = $component->createPageObject($component->getRequest()->getQuery('route', 'Index'));

            $this->enqueueClientSideDependencies($page->getView());

            if (null === $response) {
                $response = new Response();
            }

            if ($page) {
                $response->setPage($page);

                $this->output = $component->dispatchPage($page, $response);

                // If AJAX or non-layout response, render now to avoid WP shell mucking it up
                if ($component->getRequest()->isAjax() || !$component->shouldRenderLayout()) {
                    echo $this->output;
                    exit;
                }
            }
        }

        return $this;
    }

    /**
     * Enqueue the core Dewdrop client-side dependencies early in the process,
     * before the page is dispatched, so that they come before the page-specific
     * scripts.
     *
     * @param View $view
     * @return void
     */
    protected function enqueueClientSideDependencies(View $view)
    {
        global $wp_version;

        // Use jQuery and Backbone from WP core
        wp_enqueue_script('jquery-core');
        wp_enqueue_script('wp-backbone');

        $wpCoreScripts = array('jquery', 'backbone');

        // Enqueue non-WP core scripts
        foreach ($this->coreClientSideDependencies['js'] as $name => $script) {
            if (!in_array($name, $wpCoreScripts)) {
                wp_enqueue_script($name, $view->bowerUrl($script), ['jquery', 'wp-backbone'], $wp_version, true);
            }
        }

        wp_enqueue_style('bootstrap', $view->bowerUrl('/dewdrop/www/css/bootstrap-wp.css'));

        foreach ($this->coreClientSideDependencies['css'] as $name => $css) {
            // We need to use a special, prefixed version of the Bootstrap CSS for WP
            if ('bootstrap' !== $name) {
                wp_enqueue_style($name, $view->bowerUrl($css));
            }
        }

        wp_enqueue_style('dewdrop-admin-wp', $view->bowerUrl('/dewdrop/www/css/admin-wp.css'));
    }

    /**
     * This is the callback we added to the "admin_menu" action in the
     * register() method.  It essentially tells WP to call this component's
     * route() method whenever the component is accessed.
     *
     * @param ComponentInterface $component
     */
    public function registerMenuPage(ComponentInterface $component)
    {
        $slug = $component->getSlug();

        $this->registerComponentHandlingCallback($component);

        if ($component instanceof ShellIntegrationInterface && count($component->getSubmenuPages())) {
            global $submenu_file;

            foreach ($component->getSubmenuPages() as $page) {
                $url = $slug;

                if ('Index' !== $page['route']) {
                    $url .= '/' . $page['route'];
                }

                // If the current route matches the page linked then mark it as selected
                if ($url === $component->getRequest()->getQuery('page')) {
                    $submenu_file = $url;
                }

                $this->addSubmenuPage(
                    $component->getSlug(),
                    $page['title'],
                    $page['title'],
                    'add_users',
                    $url,
                    function () use ($component) {
                        $this->renderOutputIntoShell($component);
                    }
                );
            }
        }
    }

    /**
     * Registering a component in WordPress means registering a handler
     * for a hook.  Typically, add_object_page is used, but that implies
     * an entry in the top-level admin menu.  Because we want to support
     * components that don't appear in the menu, we check the display-menu
     * permission here and then use add_submenu_page() with no slug to
     * get our callback over to WP without displaying anything in the
     * menu.
     *
     * @param ComponentInterface $component
     * @throws \Dewdrop\Exception
     */
    protected function registerComponentHandlingCallback(ComponentInterface $component)
    {
        if ($component->getPermissions()->can('display-menu')) {
            $this->addObjectPage(
                $component->getTitle(),
                $component->getTitle(),
                'add_users',
                $component->getSlug(),
                function () use ($component) {
                    $this->renderOutputIntoShell($component);
                },
                $component->getIcon(),
                $component->getMenuPosition()
            );
        } else {
            $this->addSubmenuPage(
                null,
                $component->getTitle(),
                $component->getTitle(),
                'add_users',
                $component->getSlug(),
                function () use ($component) {
                    $this->renderOutputIntoShell($component);
                }
            );
        }
    }

    /**
     * A mock wrapper for WP's add_object_page() function.  Allows calls
     * during testing without error.
     *
     * @return void
     */
    protected function addObjectPage()
    {
        if (function_exists('add_object_page')) {
            call_user_func_array('add_object_page', func_get_args());
        }
    }

    /**
     * A mock wrapper for WP's add_submenu_page() function.  Allows calls
     * during testing without error.
     *
     * @return void
     */
    protected function addSubmenuPage()
    {
        if (function_exists('add_submenu_page')) {
            call_user_func_array('add_submenu_page', func_get_args());
        }
    }

    /**
     * On typical admin pages, we don't want to display our output until the
     * WP shell itself is rendered.  This method is attached to the appropiate
     * hooks to allow that to happen.
     *
     * @param ComponentInterface $component
     * @return void
     */
    public function renderOutputIntoShell(ComponentInterface $component)
    {
        echo $this->output;
    }

    /**
     * Check to see if this component is currently being accessed.  We do this
     * manually because we want to know whether the component is in use before
     * WP would itself be able to tell us.  This allows us to dispatch pages on
     * admin_init, which is early enough in the process that we can easily enqueue
     * other resources.  Also, this gives us the chance to run code before WP has
     * rendered any output.
     *
     *
     * @return boolean
     */
    protected function componentIsCurrentlyActive(ComponentInterface $component)
    {
        return preg_match('/^' . $component->getSlug() . '($|\/)/i', $component->getRequest()->getQuery('page')) ||
            $component->getSlug() === $component->getRequest()->getPost('action');
    }
}
